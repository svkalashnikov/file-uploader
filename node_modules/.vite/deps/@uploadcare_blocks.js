import {
  PACKAGE_NAME,
  PACKAGE_VERSION
} from "./chunk-H6AWKSEN.js";
import {
  __publicField
} from "./chunk-TYRVL62N.js";

// node_modules/@symbiotejs/symbiote/build/symbiote.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function cloneObj(obj) {
  let clone = (o) => {
    var _a2;
    for (let prop in o) {
      if (((_a2 = o[prop]) == null ? void 0 : _a2.constructor) === Object) {
        o[prop] = clone(o[prop]);
      }
    }
    return { ...o };
  };
  return clone(obj);
}
var Data = class {
  constructor(schema) {
    if (schema.constructor === Object) {
      this.store = cloneObj(schema);
    } else {
      this._storeIsProxy = true;
      this.store = schema;
    }
    this.callbackMap = /* @__PURE__ */ Object.create(null);
  }
  static warn(actionName, prop) {
    console.warn(`Symbiote Data: cannot ${actionName}. Prop name: ` + prop);
  }
  read(prop) {
    if (!this._storeIsProxy && !this.store.hasOwnProperty(prop)) {
      Data.warn("read", prop);
      return null;
    }
    return this.store[prop];
  }
  has(prop) {
    return this._storeIsProxy ? this.store[prop] !== void 0 : this.store.hasOwnProperty(prop);
  }
  add(prop, val, rewrite = false) {
    if (!rewrite && Object.keys(this.store).includes(prop)) {
      return;
    }
    this.store[prop] = val;
    this.notify(prop);
  }
  pub(prop, val) {
    if (!this._storeIsProxy && !this.store.hasOwnProperty(prop)) {
      Data.warn("publish", prop);
      return;
    }
    this.store[prop] = val;
    this.notify(prop);
  }
  multiPub(updObj) {
    for (let prop in updObj) {
      this.pub(prop, updObj[prop]);
    }
  }
  notify(prop) {
    if (this.callbackMap[prop]) {
      this.callbackMap[prop].forEach((callback) => {
        callback(this.store[prop]);
      });
    }
  }
  sub(prop, callback, init = true) {
    if (!this._storeIsProxy && !this.store.hasOwnProperty(prop)) {
      Data.warn("subscribe", prop);
      return null;
    }
    if (!this.callbackMap[prop]) {
      this.callbackMap[prop] = /* @__PURE__ */ new Set();
    }
    this.callbackMap[prop].add(callback);
    if (init) {
      callback(this.store[prop]);
    }
    return {
      remove: () => {
        this.callbackMap[prop].delete(callback);
        if (!this.callbackMap[prop].size) {
          delete this.callbackMap[prop];
        }
      },
      callback
    };
  }
  static registerCtx(schema, uid = Symbol()) {
    let data = Data.globalStore.get(uid);
    if (data) {
      console.warn('State: context UID "' + uid + '" already in use');
    } else {
      data = new Data(schema);
      Data.globalStore.set(uid, data);
    }
    return data;
  }
  static deleteCtx(uid) {
    Data.globalStore.delete(uid);
  }
  static getCtx(uid, notify = true) {
    return Data.globalStore.get(uid) || (notify && console.warn('State: wrong context UID - "' + uid + '"'), null);
  }
};
Data.globalStore = /* @__PURE__ */ new Map();
var DICT = Object.freeze({
  BIND_ATTR: "set",
  ATTR_BIND_PRFX: "@",
  EXT_DATA_CTX_PRFX: "*",
  NAMED_DATA_CTX_SPLTR: "/",
  CTX_NAME_ATTR: "ctx-name",
  CTX_OWNER_ATTR: "ctx-owner",
  CSS_CTX_PROP: "--ctx-name",
  EL_REF_ATTR: "ref",
  AUTO_TAG_PRFX: "sym",
  REPEAT_ATTR: "repeat",
  REPEAT_ITEM_TAG_ATTR: "repeat-item-tag",
  SET_LATER_KEY: "__toSetLater__",
  USE_TPL: "use-template",
  ROOT_STYLE_ATTR_NAME: "sym-component"
});
var CHARS = "1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";
var CHLENGTH = CHARS.length - 1;
var UID = class {
  static generate(pattern = "XXXXXXXXX-XXX") {
    let uid = "";
    for (let i = 0; i < pattern.length; i++) {
      uid += pattern[i] === "-" ? pattern[i] : CHARS.charAt(Math.random() * CHLENGTH);
    }
    return uid;
  }
};
function setNestedProp(parent, path, value) {
  let success = true;
  let lastStep;
  let propPath = path.split(".");
  propPath.forEach((step, idx) => {
    if (idx < propPath.length - 1) {
      parent = parent[step];
    } else {
      lastStep = step;
    }
  });
  if (parent) {
    parent[lastStep] = value;
  } else {
    success = false;
  }
  return success;
}
function kebabToCamel(string) {
  return string.split("-").map((p, i) => {
    return p && i ? p[0].toUpperCase() + p.slice(1) : p;
  }).join("").split("_").map((p, i) => {
    return p && i ? p.toUpperCase() : p;
  }).join("");
}
function repeatProcessor(fr, fnCtx) {
  [...fr.querySelectorAll(`[${DICT.REPEAT_ATTR}]`)].forEach((el) => {
    let itemTag = el.getAttribute(DICT.REPEAT_ITEM_TAG_ATTR);
    let itemClass;
    if (itemTag) {
      itemClass = window.customElements.get(itemTag);
    }
    if (!itemClass) {
      itemClass = class extends fnCtx.BaseComponent {
        constructor() {
          super();
          if (!itemTag) {
            this.style.display = "contents";
          }
        }
      };
      let itemTpl = el.innerHTML;
      itemClass.template = itemTpl;
      itemClass.reg(itemTag);
    }
    while (el.firstChild) {
      el.firstChild.remove();
    }
    let repeatDataKey = el.getAttribute(DICT.REPEAT_ATTR);
    fnCtx.sub(repeatDataKey, (data) => {
      if (!data) {
        while (el.firstChild) {
          el.firstChild.remove();
        }
        return;
      }
      let currentList = [...el.children];
      let fragment;
      let fillItems = (items) => {
        items.forEach((item, idx) => {
          if (currentList[idx]) {
            if (currentList[idx].set$) {
              setTimeout(() => {
                currentList[idx].set$(item);
              });
            } else {
              for (let k in item) {
                currentList[idx][k] = item[k];
              }
            }
          } else {
            if (!fragment) {
              fragment = new DocumentFragment();
            }
            let repeatItem = new itemClass();
            Object.assign(repeatItem.init$, item);
            fragment.appendChild(repeatItem);
          }
        });
        fragment && el.appendChild(fragment);
        let oversize = currentList.slice(items.length, currentList.length);
        for (let exItm of oversize) {
          exItm.remove();
        }
      };
      if (data.constructor === Array) {
        fillItems(data);
      } else if (data.constructor === Object) {
        let items = [];
        for (let itemKey in data) {
          let init = data[itemKey];
          Object.defineProperty(init, "_KEY_", {
            value: itemKey,
            enumerable: true
          });
          items.push(init);
        }
        fillItems(items);
      } else {
        console.warn("Symbiote repeat data type error:");
        console.log(data);
      }
    });
    el.removeAttribute(DICT.REPEAT_ATTR);
    el.removeAttribute(DICT.REPEAT_ITEM_TAG_ATTR);
  });
}
var DEFAULT_SLOT_KEY = "__default__";
function slotProcessor(fr, fnCtx) {
  if (fnCtx.shadowRoot) {
    return;
  }
  let slots = [...fr.querySelectorAll("slot")];
  if (!slots.length) {
    return;
  }
  let slotMap = {};
  slots.forEach((slot) => {
    let slotName = slot.getAttribute("name") || DEFAULT_SLOT_KEY;
    slotMap[slotName] = {
      slot,
      fr: document.createDocumentFragment()
    };
  });
  fnCtx.initChildren.forEach((child) => {
    var _a2;
    let slotName = DEFAULT_SLOT_KEY;
    if (child instanceof Element && child.hasAttribute("slot")) {
      slotName = child.getAttribute("slot");
      child.removeAttribute("slot");
    }
    (_a2 = slotMap[slotName]) == null ? void 0 : _a2.fr.appendChild(child);
  });
  Object.values(slotMap).forEach((mapObj) => {
    if (mapObj.fr.childNodes.length) {
      mapObj.slot.parentNode.replaceChild(mapObj.fr, mapObj.slot);
    } else if (mapObj.slot.childNodes.length) {
      let slotFr = document.createDocumentFragment();
      slotFr.append(...mapObj.slot.childNodes);
      mapObj.slot.parentNode.replaceChild(slotFr, mapObj.slot);
    } else {
      mapObj.slot.remove();
    }
  });
}
function refProcessor(fr, fnCtx) {
  [...fr.querySelectorAll(`[${DICT.EL_REF_ATTR}]`)].forEach((el) => {
    let refName = el.getAttribute(DICT.EL_REF_ATTR);
    fnCtx.ref[refName] = el;
    el.removeAttribute(DICT.EL_REF_ATTR);
  });
}
function domSetProcessor(fr, fnCtx) {
  [...fr.querySelectorAll(`[${DICT.BIND_ATTR}]`)].forEach((el) => {
    let subStr = el.getAttribute(DICT.BIND_ATTR);
    let keyValArr = subStr.split(";");
    [...el.attributes].forEach((attr) => {
      if (attr.name.startsWith("-") && attr.value) {
        let key = kebabToCamel(attr.name.replace("-", ""));
        keyValArr.push(key + ":" + attr.value);
        el.removeAttribute(attr.name);
      }
    });
    keyValArr.forEach((keyValStr) => {
      if (!keyValStr) {
        return;
      }
      let kv = keyValStr.split(":").map((str) => str.trim());
      let prop = kv[0];
      let isAttr;
      if (prop.indexOf(DICT.ATTR_BIND_PRFX) === 0) {
        isAttr = true;
        prop = prop.replace(DICT.ATTR_BIND_PRFX, "");
      }
      let valKeysArr = kv[1].split(",").map((valKey) => {
        return valKey.trim();
      });
      for (let valKey of valKeysArr) {
        let castType;
        if (valKey.startsWith("!!")) {
          castType = "double";
          valKey = valKey.replace("!!", "");
        } else if (valKey.startsWith("!")) {
          castType = "single";
          valKey = valKey.replace("!", "");
        }
        fnCtx.sub(valKey, (val) => {
          if (castType === "double") {
            val = !!val;
          } else if (castType === "single") {
            val = !val;
          }
          if (isAttr) {
            if ((val == null ? void 0 : val.constructor) === Boolean) {
              val ? el.setAttribute(prop, "") : el.removeAttribute(prop);
            } else {
              el.setAttribute(prop, val);
            }
          } else {
            if (!setNestedProp(el, prop, val)) {
              if (!el[DICT.SET_LATER_KEY]) {
                el[DICT.SET_LATER_KEY] = /* @__PURE__ */ Object.create(null);
              }
              el[DICT.SET_LATER_KEY][prop] = val;
            }
          }
        });
      }
    });
    el.removeAttribute(DICT.BIND_ATTR);
  });
}
var OPEN_TOKEN = "{{";
var CLOSE_TOKEN = "}}";
var SKIP_ATTR = "skip-text";
function getTextNodesWithTokens(el) {
  let node;
  let result = [];
  let walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
    acceptNode: (txt) => {
      var _a2;
      return !((_a2 = txt.parentElement) == null ? void 0 : _a2.hasAttribute(SKIP_ATTR)) && txt.textContent.includes(OPEN_TOKEN) && txt.textContent.includes(CLOSE_TOKEN) && 1;
    }
  });
  while (node = walk.nextNode()) {
    result.push(node);
  }
  return result;
}
var txtNodesProcessor = function(fr, fnCtx) {
  let txtNodes = getTextNodesWithTokens(fr);
  txtNodes.forEach((txtNode) => {
    let tokenNodes = [];
    let offset;
    while (txtNode.textContent.includes(CLOSE_TOKEN)) {
      if (txtNode.textContent.startsWith(OPEN_TOKEN)) {
        offset = txtNode.textContent.indexOf(CLOSE_TOKEN) + CLOSE_TOKEN.length;
        txtNode.splitText(offset);
        tokenNodes.push(txtNode);
      } else {
        offset = txtNode.textContent.indexOf(OPEN_TOKEN);
        txtNode.splitText(offset);
      }
      txtNode = txtNode.nextSibling;
    }
    tokenNodes.forEach((tNode) => {
      let prop = tNode.textContent.replace(OPEN_TOKEN, "").replace(CLOSE_TOKEN, "");
      tNode.textContent = "";
      fnCtx.sub(prop, (val) => {
        tNode.textContent = val;
      });
    });
  });
};
var tpl_processors_default = [repeatProcessor, slotProcessor, refProcessor, domSetProcessor, txtNodesProcessor];
var SINGLE_QUOTE = "'";
var DOUBLE_QUOTE = '"';
var ESCAPED_PATTERN = /\\([0-9a-fA-F]{1,6} ?)/g;
function hasLeadingTrailingQuotes(str) {
  return (str[0] === DOUBLE_QUOTE || str[0] === SINGLE_QUOTE) && (str[str.length - 1] === DOUBLE_QUOTE || str[str.length - 1] === SINGLE_QUOTE);
}
function trimQuotes(str) {
  if (str[0] === DOUBLE_QUOTE || str[0] === SINGLE_QUOTE) {
    str = str.slice(1);
  }
  if (str[str.length - 1] === DOUBLE_QUOTE || str[str.length - 1] === SINGLE_QUOTE) {
    str = str.slice(0, -1);
  }
  return str;
}
function escapeQuotes(str) {
  let result = "";
  let prev = "";
  for (var i = 0; i < str.length; i++) {
    const next = str[i + 1];
    if (str[i] === "\\" && next === '"') {
      result += '\\"';
      i++;
    } else if (str[i] === '"' && prev !== "\\") {
      result += '\\"';
    } else {
      result += str[i];
    }
    prev = str[i];
  }
  return result;
}
function parseCssPropertyValue(input) {
  let output = input;
  if (hasLeadingTrailingQuotes(input)) {
    output = trimQuotes(output);
    output = output.replace(ESCAPED_PATTERN, (match, p1) => {
      return String.fromCodePoint(parseInt(p1.trim(), 16));
    });
    output = output.replaceAll("\\\n", "\\n");
    output = escapeQuotes(output);
    output = DOUBLE_QUOTE + output + DOUBLE_QUOTE;
  }
  try {
    return JSON.parse(output);
  } catch (err) {
    throw new Error(`Failed to parse CSS property value: ${output}. Original input: ${input}`);
  }
}
var autoTagsCount = 0;
var styleMutationObserver = null;
var styleMutationObserverCbList = null;
var _BaseComponent = class extends HTMLElement {
  constructor() {
    super();
    __publicField2(this, "updateCssData", () => {
      var _a2;
      this.dropCssDataCache();
      (_a2 = this.__boundCssProps) == null ? void 0 : _a2.forEach((ctxProp) => {
        let val = this.getCssData(this.__extractCssName(ctxProp), true);
        val !== null && this.$[ctxProp] !== val && (this.$[ctxProp] = val);
      });
    });
    this.init$ = /* @__PURE__ */ Object.create(null);
    this.cssInit$ = /* @__PURE__ */ Object.create(null);
    this.tplProcessors = /* @__PURE__ */ new Set();
    this.ref = /* @__PURE__ */ Object.create(null);
    this.allSubs = /* @__PURE__ */ new Set();
    this.pauseRender = false;
    this.renderShadow = false;
    this.readyToDestroy = true;
    this.processInnerHtml = false;
    this.allowCustomTemplate = false;
    this.ctxOwner = false;
  }
  get BaseComponent() {
    return _BaseComponent;
  }
  initCallback() {
  }
  __initCallback() {
    var _a2;
    if (this.__initialized) {
      return;
    }
    this.__initialized = true;
    (_a2 = this.initCallback) == null ? void 0 : _a2.call(this);
  }
  render(template, shadow = this.renderShadow) {
    let fr;
    if ((shadow || this.constructor["__shadowStylesUrl"]) && !this.shadowRoot) {
      this.attachShadow({
        mode: "open"
      });
    }
    if (this.allowCustomTemplate) {
      let customTplSelector = this.getAttribute(DICT.USE_TPL);
      if (customTplSelector) {
        let root = this.getRootNode();
        let customTpl = (root == null ? void 0 : root.querySelector(customTplSelector)) || document.querySelector(customTplSelector);
        if (customTpl) {
          template = customTpl.content.cloneNode(true);
        } else {
          console.warn(`Symbiote template "${customTplSelector}" is not found...`);
        }
      }
    }
    if (this.processInnerHtml) {
      for (let fn of this.tplProcessors) {
        fn(this, this);
      }
    }
    if (template || this.constructor["template"]) {
      if (this.constructor["template"] && !this.constructor["__tpl"]) {
        this.constructor["__tpl"] = document.createElement("template");
        this.constructor["__tpl"].innerHTML = this.constructor["template"];
      }
      if ((template == null ? void 0 : template.constructor) === DocumentFragment) {
        fr = template;
      } else if ((template == null ? void 0 : template.constructor) === String) {
        let tpl = document.createElement("template");
        tpl.innerHTML = template;
        fr = tpl.content.cloneNode(true);
      } else if (this.constructor["__tpl"]) {
        fr = this.constructor["__tpl"].content.cloneNode(true);
      }
      for (let fn of this.tplProcessors) {
        fn(fr, this);
      }
    }
    let addFr = () => {
      fr && (shadow && this.shadowRoot.appendChild(fr) || this.appendChild(fr));
      this.__initCallback();
    };
    if (this.constructor["__shadowStylesUrl"]) {
      shadow = true;
      let styleLink = document.createElement("link");
      styleLink.rel = "stylesheet";
      styleLink.href = this.constructor["__shadowStylesUrl"];
      styleLink.onload = addFr;
      this.shadowRoot.prepend(styleLink);
    } else {
      addFr();
    }
  }
  addTemplateProcessor(processorFn) {
    this.tplProcessors.add(processorFn);
  }
  get autoCtxName() {
    if (!this.__autoCtxName) {
      this.__autoCtxName = UID.generate();
      this.style.setProperty(DICT.CSS_CTX_PROP, `'${this.__autoCtxName}'`);
    }
    return this.__autoCtxName;
  }
  get cssCtxName() {
    return this.getCssData(DICT.CSS_CTX_PROP, true);
  }
  get ctxName() {
    var _a2;
    let ctxName = ((_a2 = this.getAttribute(DICT.CTX_NAME_ATTR)) == null ? void 0 : _a2.trim()) || this.cssCtxName || this.__cachedCtxName || this.autoCtxName;
    this.__cachedCtxName = ctxName;
    return ctxName;
  }
  get localCtx() {
    if (!this.__localCtx) {
      this.__localCtx = Data.registerCtx({}, this);
    }
    return this.__localCtx;
  }
  get nodeCtx() {
    return Data.getCtx(this.ctxName, false) || Data.registerCtx({}, this.ctxName);
  }
  static __parseProp(prop, fnCtx) {
    let ctx;
    let name;
    if (prop.startsWith(DICT.EXT_DATA_CTX_PRFX)) {
      ctx = fnCtx.nodeCtx;
      name = prop.replace(DICT.EXT_DATA_CTX_PRFX, "");
    } else if (prop.includes(DICT.NAMED_DATA_CTX_SPLTR)) {
      let pArr = prop.split(DICT.NAMED_DATA_CTX_SPLTR);
      ctx = Data.getCtx(pArr[0]);
      name = pArr[1];
    } else {
      ctx = fnCtx.localCtx;
      name = prop;
    }
    return {
      ctx,
      name
    };
  }
  sub(prop, handler, init = true) {
    let subCb = (val) => {
      if (!this.isConnected) {
        return;
      }
      handler(val);
    };
    let parsed = _BaseComponent.__parseProp(prop, this);
    if (!parsed.ctx.has(parsed.name)) {
      window.setTimeout(() => {
        this.allSubs.add(parsed.ctx.sub(parsed.name, subCb, init));
      });
    } else {
      this.allSubs.add(parsed.ctx.sub(parsed.name, subCb, init));
    }
  }
  notify(prop) {
    let parsed = _BaseComponent.__parseProp(prop, this);
    parsed.ctx.notify(parsed.name);
  }
  has(prop) {
    let parsed = _BaseComponent.__parseProp(prop, this);
    return parsed.ctx.has(parsed.name);
  }
  add(prop, val, rewrite = false) {
    let parsed = _BaseComponent.__parseProp(prop, this);
    parsed.ctx.add(parsed.name, val, rewrite);
  }
  add$(obj, rewrite = false) {
    for (let prop in obj) {
      this.add(prop, obj[prop], rewrite);
    }
  }
  get $() {
    if (!this.__stateProxy) {
      let o = /* @__PURE__ */ Object.create(null);
      this.__stateProxy = new Proxy(o, {
        set: (obj, prop, val) => {
          let parsed = _BaseComponent.__parseProp(prop, this);
          parsed.ctx.pub(parsed.name, val);
          return true;
        },
        get: (obj, prop) => {
          let parsed = _BaseComponent.__parseProp(prop, this);
          return parsed.ctx.read(parsed.name);
        }
      });
    }
    return this.__stateProxy;
  }
  set$(kvObj, forcePrimitives = false) {
    for (let key in kvObj) {
      let val = kvObj[key];
      let primArr = [String, Number, Boolean];
      if (forcePrimitives || !primArr.includes(val == null ? void 0 : val.constructor)) {
        this.$[key] = val;
      } else {
        this.$[key] !== val && (this.$[key] = val);
      }
    }
  }
  get __ctxOwner() {
    return this.ctxOwner || this.hasAttribute(DICT.CTX_OWNER_ATTR) && this.getAttribute(DICT.CTX_OWNER_ATTR) !== "false";
  }
  __initDataCtx() {
    let attrDesc = this.constructor["__attrDesc"];
    if (attrDesc) {
      for (let prop of Object.values(attrDesc)) {
        if (!Object.keys(this.init$).includes(prop)) {
          this.init$[prop] = "";
        }
      }
    }
    for (let prop in this.init$) {
      if (prop.startsWith(DICT.EXT_DATA_CTX_PRFX)) {
        this.nodeCtx.add(prop.replace(DICT.EXT_DATA_CTX_PRFX, ""), this.init$[prop], this.__ctxOwner);
      } else if (prop.includes(DICT.NAMED_DATA_CTX_SPLTR)) {
        let propArr = prop.split(DICT.NAMED_DATA_CTX_SPLTR);
        let ctxName = propArr[0].trim();
        let propName = propArr[1].trim();
        if (ctxName && propName) {
          let namedCtx = Data.getCtx(ctxName, false);
          if (!namedCtx) {
            namedCtx = Data.registerCtx({}, ctxName);
          }
          namedCtx.add(propName, this.init$[prop]);
        }
      } else {
        this.localCtx.add(prop, this.init$[prop]);
      }
    }
    for (let cssProp in this.cssInit$) {
      this.bindCssData(cssProp, this.cssInit$[cssProp]);
    }
    this.__dataCtxInitialized = true;
  }
  connectedCallback() {
    var _a2;
    if (!this.isConnected) {
      return;
    }
    if (this.__disconnectTimeout) {
      window.clearTimeout(this.__disconnectTimeout);
    }
    if (!this.connectedOnce) {
      let ctxNameAttrVal = (_a2 = this.getAttribute(DICT.CTX_NAME_ATTR)) == null ? void 0 : _a2.trim();
      if (ctxNameAttrVal) {
        this.style.setProperty(DICT.CSS_CTX_PROP, `'${ctxNameAttrVal}'`);
      }
      this.__initDataCtx();
      if (this[DICT.SET_LATER_KEY]) {
        for (let prop in this[DICT.SET_LATER_KEY]) {
          setNestedProp(this, prop, this[DICT.SET_LATER_KEY][prop]);
        }
        delete this[DICT.SET_LATER_KEY];
      }
      this.initChildren = [...this.childNodes];
      for (let proc of tpl_processors_default) {
        this.addTemplateProcessor(proc);
      }
      if (this.pauseRender) {
        this.__initCallback();
      } else {
        if (this.constructor["__rootStylesLink"]) {
          let root = this.getRootNode();
          if (!root) {
            return;
          }
          let hasLink = root == null ? void 0 : root.querySelector(`link[${DICT.ROOT_STYLE_ATTR_NAME}="${this.constructor.is}"]`);
          if (hasLink) {
            this.render();
            return;
          }
          let rootLink = this.constructor["__rootStylesLink"].cloneNode(true);
          rootLink.setAttribute(DICT.ROOT_STYLE_ATTR_NAME, this.constructor["is"]);
          rootLink.onload = () => {
            this.render();
          };
          root.nodeType === Node.DOCUMENT_NODE ? root.head.appendChild(rootLink) : root.prepend(rootLink);
        } else {
          this.render();
        }
      }
    }
    this.connectedOnce = true;
  }
  destroyCallback() {
  }
  disconnectedCallback() {
    if (!this.connectedOnce) {
      return;
    }
    this.dropCssDataCache();
    if (!this.readyToDestroy) {
      return;
    }
    if (this.__disconnectTimeout) {
      window.clearTimeout(this.__disconnectTimeout);
    }
    this.__disconnectTimeout = window.setTimeout(() => {
      this.destroyCallback();
      for (let sub of this.allSubs) {
        sub.remove();
        this.allSubs.delete(sub);
      }
      for (let proc of this.tplProcessors) {
        this.tplProcessors.delete(proc);
      }
      styleMutationObserverCbList == null ? void 0 : styleMutationObserverCbList.delete(this.updateCssData);
      if (!(styleMutationObserverCbList == null ? void 0 : styleMutationObserverCbList.size)) {
        styleMutationObserver == null ? void 0 : styleMutationObserver.disconnect();
        styleMutationObserver = null;
        styleMutationObserverCbList = null;
      }
    }, 100);
  }
  static reg(tagName, isAlias = false) {
    if (!tagName) {
      autoTagsCount++;
      tagName = `${DICT.AUTO_TAG_PRFX}-${autoTagsCount}`;
    }
    this.__tag = tagName;
    let registeredClass = window.customElements.get(tagName);
    if (registeredClass) {
      if (!isAlias && registeredClass !== this) {
        console.warn([
          `Element with tag name "${tagName}" already registered.`,
          `You're trying to override it with another class "${this.name}".`,
          `This is most likely a mistake.`,
          `New element will not be registered.`
        ].join("\n"));
      }
      return;
    }
    window.customElements.define(tagName, isAlias ? class extends this {
    } : this);
  }
  static get is() {
    if (!this.__tag) {
      this.reg();
    }
    return this.__tag;
  }
  static bindAttributes(desc) {
    this.observedAttributes = Object.keys(desc);
    this.__attrDesc = desc;
  }
  attributeChangedCallback(name, oldVal, newVal) {
    var _a2;
    if (oldVal === newVal) {
      return;
    }
    let $prop = (_a2 = this.constructor["__attrDesc"]) == null ? void 0 : _a2[name];
    if ($prop) {
      if (this.__dataCtxInitialized) {
        this.$[$prop] = newVal;
      } else {
        this.init$[$prop] = newVal;
      }
    } else {
      this[name] = newVal;
    }
  }
  getCssData(propName, silentCheck = false) {
    if (!this.__cssDataCache) {
      this.__cssDataCache = /* @__PURE__ */ Object.create(null);
    }
    if (!Object.keys(this.__cssDataCache).includes(propName)) {
      if (!this.__computedStyle) {
        this.__computedStyle = window.getComputedStyle(this);
      }
      let val = this.__computedStyle.getPropertyValue(propName).trim();
      try {
        this.__cssDataCache[propName] = parseCssPropertyValue(val);
      } catch (e) {
        !silentCheck && console.warn(`CSS Data error: ${propName}`);
        this.__cssDataCache[propName] = null;
      }
    }
    return this.__cssDataCache[propName];
  }
  __extractCssName(ctxPropName) {
    return ctxPropName.split("--").map((part, idx) => {
      return idx === 0 ? "" : part;
    }).join("--");
  }
  __initStyleAttrObserver() {
    if (!styleMutationObserverCbList) {
      styleMutationObserverCbList = /* @__PURE__ */ new Set();
    }
    styleMutationObserverCbList.add(this.updateCssData);
    if (!styleMutationObserver) {
      styleMutationObserver = new MutationObserver((records) => {
        records[0].type === "attributes" && styleMutationObserverCbList.forEach((cb) => {
          cb();
        });
      });
      styleMutationObserver.observe(document, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["style"]
      });
    }
  }
  bindCssData(propName, initValue = "") {
    if (!this.__boundCssProps) {
      this.__boundCssProps = /* @__PURE__ */ new Set();
    }
    this.__boundCssProps.add(propName);
    let val = this.getCssData(this.__extractCssName(propName), true);
    val === null && (val = initValue);
    this.add(propName, val);
    this.__initStyleAttrObserver();
  }
  dropCssDataCache() {
    this.__cssDataCache = null;
    this.__computedStyle = null;
  }
  defineAccessor(propName, handler, isAsync) {
    let localPropName = "__" + propName;
    this[localPropName] = this[propName];
    Object.defineProperty(this, propName, {
      set: (val) => {
        this[localPropName] = val;
        if (isAsync) {
          window.setTimeout(() => {
            handler == null ? void 0 : handler(val);
          });
        } else {
          handler == null ? void 0 : handler(val);
        }
      },
      get: () => {
        return this[localPropName];
      }
    });
    this[propName] = this[localPropName];
  }
  static set shadowStyles(cssTxt) {
    let styleBlob = new Blob([cssTxt], {
      type: "text/css"
    });
    this.__shadowStylesUrl = URL.createObjectURL(styleBlob);
  }
  static set rootStyles(cssTxt) {
    if (!this.__rootStylesLink) {
      let styleBlob = new Blob([cssTxt], {
        type: "text/css"
      });
      let url = URL.createObjectURL(styleBlob);
      let link = document.createElement("link");
      link.href = url;
      link.rel = "stylesheet";
      this.__rootStylesLink = link;
    }
  }
};
var BaseComponent = _BaseComponent;
__publicField2(BaseComponent, "template");
var AppRouter = class {
  static _print(msg) {
    console.warn(msg);
  }
  static setDefaultTitle(title) {
    this.defaultTitle = title;
  }
  static setRoutingMap(map) {
    Object.assign(this.appMap, map);
    for (let route in this.appMap) {
      if (!this.defaultRoute && this.appMap[route].default === true) {
        this.defaultRoute = route;
      } else if (!this.errorRoute && this.appMap[route].error === true) {
        this.errorRoute = route;
      }
    }
  }
  static set routingEventName(name) {
    this.__routingEventName = name;
  }
  static get routingEventName() {
    return this.__routingEventName || "sym-on-route";
  }
  static readAddressBar() {
    let result = {
      route: null,
      options: {}
    };
    let paramsArr = window.location.search.split(this.separator);
    paramsArr.forEach((part) => {
      if (part.includes("?")) {
        result.route = part.replace("?", "");
      } else if (part.includes("=")) {
        let pair = part.split("=");
        result.options[pair[0]] = decodeURI(pair[1]);
      } else {
        result.options[part] = true;
      }
    });
    return result;
  }
  static notify() {
    let routeBase = this.readAddressBar();
    let routeScheme = this.appMap[routeBase.route];
    if (routeScheme && routeScheme.title) {
      document.title = routeScheme.title;
    }
    if (routeBase.route === null && this.defaultRoute) {
      this.applyRoute(this.defaultRoute);
      return;
    } else if (!routeScheme && this.errorRoute) {
      this.applyRoute(this.errorRoute);
      return;
    } else if (!routeScheme && this.defaultRoute) {
      this.applyRoute(this.defaultRoute);
      return;
    } else if (!routeScheme) {
      this._print(`Route "${routeBase.route}" not found...`);
      return;
    }
    let event = new CustomEvent(AppRouter.routingEventName, {
      detail: {
        route: routeBase.route,
        options: Object.assign(routeScheme || {}, routeBase.options)
      }
    });
    window.dispatchEvent(event);
  }
  static reflect(route, options = {}) {
    let routeScheme = this.appMap[route];
    if (!routeScheme) {
      this._print("Wrong route: " + route);
      return;
    }
    let routeStr = "?" + route;
    for (let prop in options) {
      if (options[prop] === true) {
        routeStr += this.separator + prop;
      } else {
        routeStr += this.separator + prop + `=${options[prop]}`;
      }
    }
    let title = routeScheme.title || this.defaultTitle || "";
    window.history.pushState(null, title, routeStr);
    document.title = title;
  }
  static applyRoute(route, options = {}) {
    this.reflect(route, options);
    this.notify();
  }
  static setSeparator(char) {
    this._separator = char;
  }
  static get separator() {
    return this._separator || "&";
  }
  static createRouterData(ctxName, routingMap) {
    this.setRoutingMap(routingMap);
    let routeData = Data.registerCtx({
      route: null,
      options: null,
      title: null
    }, ctxName);
    window.addEventListener(this.routingEventName, (e) => {
      var _a2;
      routeData.multiPub({
        route: e.detail.route,
        options: e.detail.options,
        title: ((_a2 = e.detail.options) == null ? void 0 : _a2.title) || this.defaultTitle || ""
      });
    });
    AppRouter.notify();
    this.initPopstateListener();
    return routeData;
  }
  static initPopstateListener() {
    if (this.__onPopstate) {
      return;
    }
    this.__onPopstate = () => {
      this.notify();
    };
    window.addEventListener("popstate", this.__onPopstate);
  }
  static removePopstateListener() {
    window.removeEventListener("popstate", this.__onPopstate);
    this.__onPopstate = null;
  }
};
AppRouter.appMap = /* @__PURE__ */ Object.create(null);
function applyStyles(el, styleMap) {
  for (let prop in styleMap) {
    if (prop.includes("-")) {
      el.style.setProperty(prop, styleMap[prop]);
    } else {
      el.style[prop] = styleMap[prop];
    }
  }
}
function applyAttributes(el, attrMap) {
  for (let attrName in attrMap) {
    if (attrMap[attrName].constructor === Boolean) {
      if (attrMap[attrName]) {
        el.setAttribute(attrName, "");
      } else {
        el.removeAttribute(attrName);
      }
    } else {
      el.setAttribute(attrName, attrMap[attrName]);
    }
  }
}
function create(desc = { tag: "div" }) {
  let el = document.createElement(desc.tag);
  if (desc.attributes) {
    applyAttributes(el, desc.attributes);
  }
  if (desc.styles) {
    applyStyles(el, desc.styles);
  }
  if (desc.properties) {
    for (let prop in desc.properties) {
      el[prop] = desc.properties[prop];
    }
  }
  if (desc.processors) {
    desc.processors.forEach((fn) => {
      fn(el);
    });
  }
  if (desc.children) {
    desc.children.forEach((desc2) => {
      let child = create(desc2);
      el.appendChild(child);
    });
  }
  return el;
}
var READY_EVENT_NAME = "idb-store-ready";
var DEFAULT_DB_NAME = `symbiote-db`;
var UPD_EVENT_PREFIX = `symbiote-idb-update_`;
var DbInstance = class {
  _notifyWhenReady(event = null) {
    window.dispatchEvent(new CustomEvent(READY_EVENT_NAME, {
      detail: {
        dbName: this.name,
        storeName: this.storeName,
        event
      }
    }));
  }
  get _updEventName() {
    return UPD_EVENT_PREFIX + this.name;
  }
  _getUpdateEvent(key) {
    return new CustomEvent(this._updEventName, {
      detail: {
        key: this.name,
        newValue: key
      }
    });
  }
  _notifySubscribers(key) {
    window.localStorage.removeItem(this.name);
    window.localStorage.setItem(this.name, key);
    window.dispatchEvent(this._getUpdateEvent(key));
  }
  constructor(dbName, storeName) {
    this.name = dbName;
    this.storeName = storeName;
    this.version = 1;
    this.request = window.indexedDB.open(this.name, this.version);
    this.request.onupgradeneeded = (e) => {
      this.db = e.target["result"];
      this.objStore = this.db.createObjectStore(storeName, {
        keyPath: "_key"
      });
      this.objStore.transaction.oncomplete = (ev) => {
        this._notifyWhenReady(ev);
      };
    };
    this.request.onsuccess = (e) => {
      this.db = e.target.result;
      this._notifyWhenReady(e);
    };
    this.request.onerror = (e) => {
      console.error(e);
    };
    this._subscriptionsMap = {};
    this._updateHandler = (e) => {
      if (e.key === this.name && this._subscriptionsMap[e.newValue]) {
        let set = this._subscriptionsMap[e.newValue];
        set.forEach(async (callback) => {
          callback(await this.read(e.newValue));
        });
      }
    };
    this._localUpdateHandler = (e) => {
      this._updateHandler(e.detail);
    };
    window.addEventListener("storage", this._updateHandler);
    window.addEventListener(this._updEventName, this._localUpdateHandler);
  }
  read(key) {
    let tx = this.db.transaction(this.storeName, "readwrite");
    let request2 = tx.objectStore(this.storeName).get(key);
    return new Promise((resolve, reject) => {
      request2.onsuccess = (e) => {
        var _a2;
        if ((_a2 = e.target.result) == null ? void 0 : _a2._value) {
          resolve(e.target.result._value);
        } else {
          resolve(null);
          console.warn(`IDB: cannot read "${key}"`);
        }
      };
      request2.onerror = (e) => {
        reject(e);
      };
    });
  }
  write(key, value, silent = false) {
    let data = {
      _key: key,
      _value: value
    };
    let tx = this.db.transaction(this.storeName, "readwrite");
    let request2 = tx.objectStore(this.storeName).put(data);
    return new Promise((resolve, reject) => {
      request2.onsuccess = (e) => {
        if (!silent) {
          this._notifySubscribers(key);
        }
        resolve(e.target.result);
      };
      request2.onerror = (e) => {
        reject(e);
      };
    });
  }
  delete(key, silent = false) {
    let tx = this.db.transaction(this.storeName, "readwrite");
    let request2 = tx.objectStore(this.storeName).delete(key);
    return new Promise((resolve, reject) => {
      request2.onsuccess = (e) => {
        if (!silent) {
          this._notifySubscribers(key);
        }
        resolve(e);
      };
      request2.onerror = (e) => {
        reject(e);
      };
    });
  }
  getAll() {
    let tx = this.db.transaction(this.storeName, "readwrite");
    let request2 = tx.objectStore(this.storeName).getAll();
    return new Promise((resolve, reject) => {
      request2.onsuccess = (e) => {
        let all = e.target.result;
        resolve(all.map((obj) => {
          return obj._value;
        }));
      };
      request2.onerror = (e) => {
        reject(e);
      };
    });
  }
  subscribe(key, callback) {
    if (!this._subscriptionsMap[key]) {
      this._subscriptionsMap[key] = /* @__PURE__ */ new Set();
    }
    let set = this._subscriptionsMap[key];
    set.add(callback);
    return {
      remove: () => {
        set.delete(callback);
        if (!set.size) {
          delete this._subscriptionsMap[key];
        }
      }
    };
  }
  stop() {
    window.removeEventListener("storage", this._updateHandler);
    this._subscriptionsMap = null;
    IDB.clear(this.name);
  }
};
var IDB = class {
  static get readyEventName() {
    return READY_EVENT_NAME;
  }
  static open(dbName = DEFAULT_DB_NAME, storeName = "store") {
    let key = dbName + "/" + storeName;
    if (!this._reg[key]) {
      this._reg[key] = new DbInstance(dbName, storeName);
    }
    return this._reg[key];
  }
  static clear(dbName) {
    window.indexedDB.deleteDatabase(dbName);
    for (let key in this._reg) {
      if (key.split("/")[0] === dbName) {
        delete this._reg[key];
      }
    }
  }
};
__publicField2(IDB, "_reg", /* @__PURE__ */ Object.create(null));

// node_modules/@uploadcare/blocks/utils/template-utils.js
var DEFAULT_TRANSFORMER = (value) => value;
var OPEN_TOKEN2 = "{{";
var CLOSE_TOKEN2 = "}}";
var PLURAL_PREFIX = "plural:";
function applyTemplateData(template, data, options = {}) {
  var _a2;
  let { openToken = OPEN_TOKEN2, closeToken = CLOSE_TOKEN2, transform = DEFAULT_TRANSFORMER } = options;
  for (let key in data) {
    let value = (_a2 = data[key]) == null ? void 0 : _a2.toString();
    template = template.replaceAll(openToken + key + closeToken, typeof value === "string" ? transform(value) : value);
  }
  return template;
}
function getPluralObjects(template) {
  const pluralObjects = [];
  let open = template.indexOf(OPEN_TOKEN2);
  while (open !== -1) {
    const close = template.indexOf(CLOSE_TOKEN2, open);
    const variable = template.substring(open + 2, close);
    if (variable.startsWith(PLURAL_PREFIX)) {
      const keyValue = template.substring(open + 2, close).replace(PLURAL_PREFIX, "");
      const key = keyValue.substring(0, keyValue.indexOf("("));
      const count = keyValue.substring(keyValue.indexOf("(") + 1, keyValue.indexOf(")"));
      pluralObjects.push({ variable, pluralKey: key, countVariable: count });
    }
    open = template.indexOf(OPEN_TOKEN2, close);
  }
  return pluralObjects;
}

// node_modules/@uploadcare/blocks/abstract/l10nProcessor.js
function l10nProcessor(fr, fnCtx) {
  [...fr.querySelectorAll("[l10n]")].forEach((el) => {
    let key = el.getAttribute("l10n");
    let elProp = "textContent";
    if (key.includes(":")) {
      let arr = key.split(":");
      elProp = arr[0];
      key = arr[1];
    }
    let ctxKey = "l10n:" + key;
    fnCtx.__l10nKeys.push(ctxKey);
    fnCtx.add(ctxKey, key);
    fnCtx.sub(ctxKey, (val) => {
      el[elProp] = fnCtx.l10n(val);
    });
    el.removeAttribute("l10n");
  });
}

// node_modules/@uploadcare/blocks/abstract/CTX.js
var blockCtx = () => ({
  /** @type {Set<import('./Block').Block>} */
  "*blocksRegistry": /* @__PURE__ */ new Set()
});
var activityBlockCtx = (fnCtx) => ({
  ...blockCtx(),
  "*currentActivity": "",
  "*currentActivityParams": {},
  "*history": [],
  "*historyBack": null,
  "*closeModal": () => {
    fnCtx.set$({
      "*modalActive": false,
      "*currentActivity": ""
    });
  }
});
var uploaderBlockCtx = (fnCtx) => ({
  ...activityBlockCtx(fnCtx),
  "*commonProgress": 0,
  "*uploadList": [],
  "*outputData": null,
  "*focusedEntry": null,
  "*uploadMetadata": null
});

// node_modules/@uploadcare/blocks/blocks/utils/debounce.js
function debounce(callback, wait) {
  let timer;
  let debounced = (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => callback(...args), wait);
  };
  debounced.cancel = () => {
    clearTimeout(timer);
  };
  return debounced;
}

// node_modules/@uploadcare/blocks/utils/createWindowHeightTracker.js
var WINDOW_HEIGHT_TRACKER_PROPERTY = "--uploadcare-blocks-window-height";
var WINDOW_CACHE_KEY = "__UPLOADCARE_BLOCKS_WINDOW_HEIGHT_TRACKER_ENABLED__";
function getIsWindowHeightTracked() {
  return typeof window[WINDOW_CACHE_KEY] === "undefined" ? false : !!window[WINDOW_CACHE_KEY];
}
function createWindowHeightTracker() {
  if (getIsWindowHeightTracked()) {
    return;
  }
  const callback = () => {
    document.documentElement.style.setProperty(WINDOW_HEIGHT_TRACKER_PROPERTY, `${window.innerHeight}px`);
    window[WINDOW_CACHE_KEY] = true;
  };
  const debouncedCallback = debounce(callback, 100);
  window.addEventListener("resize", debouncedCallback, { passive: true });
  callback();
  return () => {
    window[WINDOW_CACHE_KEY] = false;
    window.removeEventListener("resize", debouncedCallback);
  };
}

// node_modules/@uploadcare/blocks/abstract/Block.js
var TAG_PREFIX = "lr-";
var Block = class extends BaseComponent {
  constructor() {
    super();
    __publicField(this, "allowCustomTemplate", true);
    __publicField(this, "ctxInit", blockCtx());
    __publicField(this, "init$", this.ctxInit);
    __publicField(this, "updateCtxCssData", () => {
      let blocks = this.$["*blocksRegistry"];
      for (let block of blocks) {
        if (block.isConnected) {
          block.updateCssData();
        }
      }
    });
    this.activityType = null;
    this.addTemplateProcessor(l10nProcessor);
    this.__l10nKeys = [];
  }
  /**
   * @param {String} str
   * @param {{ [key: string]: string | number }} variables
   * @returns {String}
   */
  l10n(str, variables = {}) {
    if (!str) {
      return "";
    }
    let template = this.getCssData("--l10n-" + str, true) || str;
    let pluralObjects = getPluralObjects(template);
    for (let pluralObject of pluralObjects) {
      variables[pluralObject.variable] = this.pluralize(
        pluralObject.pluralKey,
        Number(variables[pluralObject.countVariable])
      );
    }
    let result = applyTemplateData(template, variables);
    return result;
  }
  /**
   * @param {string} key
   * @param {number} count
   * @returns {string}
   */
  pluralize(key, count) {
    const locale = this.l10n("locale-name") || "en-US";
    const pluralForm = new Intl.PluralRules(locale).select(count);
    return this.l10n(`${key}__${pluralForm}`);
  }
  /**
   * @param {String} localPropKey
   * @param {String} l10nKey
   */
  applyL10nKey(localPropKey, l10nKey) {
    let prop = "l10n:" + localPropKey;
    this.$[prop] = /** @type {any} */
    l10nKey;
    this.__l10nKeys.push(localPropKey);
  }
  /**
   * @param {(block: Block) => boolean} callback
   * @returns {Boolean}
   */
  findBlockInCtx(callback) {
    let blocksRegistry = this.$["*blocksRegistry"];
    for (let block of blocksRegistry) {
      if (callback(block)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {String} consumerScope
   * @param {String} prop
   * @param {any} newVal
   */
  setForCtxTarget(consumerScope, prop, newVal) {
    if (this.findBlockInCtx((b) => (
      /** @type {typeof Block} */
      b.constructor.StateConsumerScope === consumerScope
    ))) {
      this.$[prop] = newVal;
    }
  }
  /** @param {String} activityType */
  setActivity(activityType) {
    if (this.findBlockInCtx((b) => b.activityType === activityType)) {
      this.$["*currentActivity"] = activityType;
      return;
    }
    console.warn(`Activity type "${activityType}" not found in the context`);
  }
  connectedCallback() {
    if (!getIsWindowHeightTracked()) {
      this._destroyInnerHeightTracker = createWindowHeightTracker();
    }
    if (this.hasAttribute("retpl")) {
      this.constructor["template"] = null;
      this.processInnerHtml = true;
    }
    if (this.isConnected && this["__ctxOwner"]) {
      let data = Data.getCtx(this.ctxName, false);
      if (data) {
        data.store = { ...this.ctxInit };
      }
    }
    super.connectedCallback();
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this._destroyInnerHeightTracker) == null ? void 0 : _a2.call(this);
  }
  initCallback() {
    let blocksRegistry = this.$["*blocksRegistry"];
    blocksRegistry.add(this);
  }
  destroyCallback() {
    let blocksRegistry = this.$["*blocksRegistry"];
    blocksRegistry.delete(this);
  }
  /**
   * @param {Number} bytes
   * @param {Number} [decimals]
   */
  fileSizeFmt(bytes, decimals = 2) {
    let units = ["B", "KB", "MB", "GB", "TB"];
    let getUnit = (str) => {
      return this.getCssData("--l10n-unit-" + str.toLowerCase(), true) || str;
    };
    if (bytes === 0) {
      return `0 ${getUnit(units[0])}`;
    }
    let k = 1024;
    let dm = decimals < 0 ? 0 : decimals;
    let i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / k ** i).toFixed(dm)) + " " + getUnit(units[i]);
  }
  /**
   * @param {String} url
   * @returns {String}
   */
  proxyUrl(url) {
    let previewProxy = this.getCssData("--cfg-secure-delivery-proxy", true);
    if (!previewProxy) {
      return url;
    }
    return applyTemplateData(
      previewProxy,
      { previewUrl: url },
      { transform: (value) => window.encodeURIComponent(value) }
    );
  }
  /** @param {String} [name] */
  static reg(name) {
    if (!name) {
      super.reg();
      return;
    }
    super.reg(name.startsWith(TAG_PREFIX) ? name : TAG_PREFIX + name);
  }
};
__publicField(Block, "StateConsumerScope", null);

// node_modules/@uploadcare/blocks/blocks/Modal/Modal.js
var _Modal = class _Modal extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "_handleBackdropClick", () => {
      this._closeDialog();
    });
    __publicField(this, "_closeDialog", () => {
      this.setForCtxTarget(_Modal.StateConsumerScope, "*modalActive", false);
    });
    __publicField(this, "_handleDialogClose", () => {
      this._closeDialog();
    });
    __publicField(this, "_handleDialogClick", (e) => {
      if (e.target === this.ref.dialog) {
        this._closeDialog();
      }
    });
    __publicField(this, "init$", {
      ...this.ctxInit,
      "*modalActive": false,
      isOpen: false,
      closeClicked: this._handleDialogClose
    });
    __publicField(this, "cssInit$", {
      "--cfg-modal-backdrop-strokes": 0
    });
  }
  show() {
    if (this.ref.dialog.showModal) {
      this.ref.dialog.showModal();
    } else {
      this.ref.dialog.setAttribute("open", "");
    }
  }
  hide() {
    if (this.ref.dialog.close) {
      this.ref.dialog.close();
    } else {
      this.ref.dialog.removeAttribute("open");
    }
  }
  initCallback() {
    super.initCallback();
    if (typeof HTMLDialogElement === "function") {
      this.ref.dialog.addEventListener("close", this._handleDialogClose);
      this.ref.dialog.addEventListener("click", this._handleDialogClick);
    } else {
      this.setAttribute("dialog-fallback", "");
      let backdrop = document.createElement("div");
      backdrop.className = "backdrop";
      this.appendChild(backdrop);
      backdrop.addEventListener("click", this._handleBackdropClick);
    }
    this.sub("*modalActive", (modalActive) => {
      if (this.$.isOpen !== modalActive) {
        this.$.isOpen = modalActive;
      }
      if (modalActive && this.getCssData("--cfg-modal-scroll-lock")) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = null;
      }
    });
    this.sub("--cfg-modal-backdrop-strokes", (val) => {
      if (val) {
        this.setAttribute("strokes", "");
      } else {
        this.removeAttribute("strokes");
      }
    });
    this.sub("isOpen", (isOpen) => {
      if (isOpen) {
        this.show();
      } else {
        this.hide();
      }
    });
  }
  destroyCallback() {
    super.destroyCallback();
    document.body.style.overflow = null;
    this.ref.dialog.removeEventListener("close", this._handleDialogClose);
    this.ref.dialog.removeEventListener("click", this._handleDialogClick);
  }
};
__publicField(_Modal, "StateConsumerScope", "modal");
var Modal = _Modal;
Modal.template = /* HTML */
`
  <dialog ref="dialog">
    <slot></slot>
  </dialog>
`;

// node_modules/@uploadcare/blocks/abstract/ActivityBlock.js
var ACTIVE_ATTR = "active";
var ACTIVE_PROP = "___ACTIVITY_IS_ACTIVE___";
var _ActivityBlock = class _ActivityBlock extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "historyTracked", false);
    __publicField(this, "ctxInit", activityBlockCtx(this));
    __publicField(this, "_debouncedHistoryFlush", debounce(this._historyFlush.bind(this), 10));
  }
  /** @private */
  _deactivate() {
    var _a2;
    let actDesc = _ActivityBlock._activityRegistry[this.activityKey];
    this[ACTIVE_PROP] = false;
    this.removeAttribute(ACTIVE_ATTR);
    (_a2 = actDesc == null ? void 0 : actDesc.deactivateCallback) == null ? void 0 : _a2.call(actDesc);
  }
  /** @private */
  _activate() {
    var _a2;
    let actDesc = _ActivityBlock._activityRegistry[this.activityKey];
    this.$["*historyBack"] = this.historyBack.bind(this);
    this[ACTIVE_PROP] = true;
    this.setAttribute(ACTIVE_ATTR, "");
    (_a2 = actDesc == null ? void 0 : actDesc.activateCallback) == null ? void 0 : _a2.call(actDesc);
    this._debouncedHistoryFlush();
  }
  initCallback() {
    super.initCallback();
    if (this.hasAttribute("current-activity")) {
      this.sub("*currentActivity", (val) => {
        this.setAttribute("current-activity", val);
      });
    }
    if (this.activityType) {
      if (!this.hasAttribute("activity")) {
        this.setAttribute("activity", this.activityType);
      }
      this.sub("*currentActivity", (val) => {
        if (this.activityType !== val && this[ACTIVE_PROP]) {
          this._deactivate();
        } else if (this.activityType === val && !this[ACTIVE_PROP]) {
          this._activate();
        }
        if (!val) {
          this.$["*history"] = [];
        }
      });
    }
  }
  /** @private */
  _historyFlush() {
    let history = this.$["*history"];
    if (history) {
      if (history.length > 10) {
        history = history.slice(history.length - 11, history.length - 1);
      }
      if (this.historyTracked) {
        history.push(this.activityType);
      }
      this.$["*history"] = history;
    }
  }
  /** @private */
  _isActivityRegistered() {
    return this.activityType && !!_ActivityBlock._activityRegistry[this.activityKey];
  }
  get isActivityActive() {
    return this[ACTIVE_PROP];
  }
  /**
   * TODO: remove name argument
   *
   * @param {String} name
   * @param {Object} [options]
   * @param {() => void} [options.onActivate]
   * @param {() => void} [options.onDeactivate]
   */
  registerActivity(name, options = {}) {
    const { onActivate, onDeactivate } = options;
    if (!_ActivityBlock._activityRegistry) {
      _ActivityBlock._activityRegistry = /* @__PURE__ */ Object.create(null);
    }
    _ActivityBlock._activityRegistry[this.activityKey] = {
      activateCallback: onActivate,
      deactivateCallback: onDeactivate
    };
  }
  unregisterActivity() {
    if (this.isActivityActive) {
      this._deactivate();
    }
    _ActivityBlock._activityRegistry[this.activityKey] = void 0;
  }
  destroyCallback() {
    super.destroyCallback();
    this._isActivityRegistered() && this.unregisterActivity();
    if (Object.keys(_ActivityBlock._activityRegistry).length === 0) {
      this.$["*currentActivity"] = null;
    }
  }
  get activityKey() {
    return this.ctxName + this.activityType;
  }
  get activityParams() {
    return this.$["*currentActivityParams"];
  }
  /** @type {String} */
  get initActivity() {
    return this.getCssData("--cfg-init-activity");
  }
  /** @type {String} */
  get doneActivity() {
    return this.getCssData("--cfg-done-activity");
  }
  historyBack() {
    let history = this.$["*history"];
    if (history) {
      let nextActivity = history.pop();
      while (nextActivity === this.activityType) {
        nextActivity = history.pop();
      }
      this.$["*currentActivity"] = nextActivity;
      this.$["*history"] = history;
      if (!nextActivity) {
        this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", false);
      }
    }
  }
};
/**
 * @private
 * @type {{ String: { activateCallback: Function; deactivateCallback: Function } }}
 */
__publicField(_ActivityBlock, "_activityRegistry", /* @__PURE__ */ Object.create(null));
var ActivityBlock = _ActivityBlock;
ActivityBlock.activities = Object.freeze({
  START_FROM: "start-from",
  CAMERA: "camera",
  DRAW: "draw",
  UPLOAD_LIST: "upload-list",
  URL: "url",
  CONFIRMATION: "confirmation",
  CLOUD_IMG_EDIT: "cloud-image-edit",
  EXTERNAL: "external",
  DETAILS: "details"
});

// node_modules/@uploadcare/blocks/utils/stringToArray.js
var stringToArray = (str, delimiter = ",") => {
  return str.trim().split(delimiter).map((part) => part.trim()).filter((part) => part.length > 0);
};

// node_modules/@uploadcare/blocks/utils/fileTypes.js
var IMAGE_ACCEPT_LIST = [
  "image/*",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/avif",
  "image/avif-sequence",
  ".heif",
  ".heifs",
  ".heic",
  ".heics",
  ".avif",
  ".avifs"
];
var mergeFileTypes = (fileTypes) => {
  if (!fileTypes) {
    return [];
  }
  return fileTypes.filter((item) => typeof item === "string").map((str) => stringToArray(str)).flat();
};
var matchFileType = (fileType, allowedFileTypes) => {
  return allowedFileTypes.some((type) => {
    if (type.endsWith("*")) {
      type = type.replace("*", "");
      return fileType.startsWith(type);
    }
    return fileType === type;
  });
};
var fileIsImage = (file) => {
  let type = file == null ? void 0 : file.type;
  if (!type) {
    return false;
  }
  return matchFileType(type, IMAGE_ACCEPT_LIST);
};

// node_modules/@uploadcare/upload-client/dist/esm/index.browser.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
var SEPARATOR = /\W|_/g;
function camelizeString(text) {
  return text.split(SEPARATOR).map((word, index) => word.charAt(0)[index > 0 ? "toUpperCase" : "toLowerCase"]() + word.slice(1)).join("");
}
function camelizeArrayItems(array, { ignoreKeys } = { ignoreKeys: [] }) {
  if (!Array.isArray(array)) {
    return array;
  }
  return array.map((item) => camelizeKeys(item, { ignoreKeys }));
}
function camelizeKeys(source, { ignoreKeys } = { ignoreKeys: [] }) {
  if (Array.isArray(source)) {
    return camelizeArrayItems(source, { ignoreKeys });
  }
  if (!isObject(source)) {
    return source;
  }
  const result = {};
  for (const key of Object.keys(source)) {
    let value = source[key];
    if (ignoreKeys.includes(key)) {
      result[key] = value;
      continue;
    }
    if (isObject(value)) {
      value = camelizeKeys(value, { ignoreKeys });
    } else if (Array.isArray(value)) {
      value = camelizeArrayItems(value, { ignoreKeys });
    }
    result[camelizeString(key)] = value;
  }
  return result;
}
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function getUserAgent$1({ libraryName, libraryVersion, userAgent, publicKey = "", integration = "" }) {
  const languageName = "JavaScript";
  if (typeof userAgent === "string") {
    return userAgent;
  }
  if (typeof userAgent === "function") {
    return userAgent({
      publicKey,
      libraryName,
      libraryVersion,
      languageName,
      integration
    });
  }
  const mainInfo = [libraryName, libraryVersion, publicKey].filter(Boolean).join("/");
  const additionInfo = [languageName, integration].filter(Boolean).join("; ");
  return `${mainInfo} (${additionInfo})`;
}
var defaultOptions = {
  factor: 2,
  time: 100
};
function retrier(fn, options = defaultOptions) {
  let attempts = 0;
  function runAttempt(fn2) {
    const defaultDelayTime = Math.round(options.time * options.factor ** attempts);
    const retry = (ms) => delay(ms ?? defaultDelayTime).then(() => {
      attempts += 1;
      return runAttempt(fn2);
    });
    return fn2({
      attempt: attempts,
      retry
    });
  }
  return runAttempt(fn);
}
var UploadcareNetworkError = class _UploadcareNetworkError extends Error {
  constructor(progressEvent) {
    super();
    __publicField(this, "originalProgressEvent");
    this.name = "UploadcareNetworkError";
    this.message = "Network error";
    Object.setPrototypeOf(this, _UploadcareNetworkError.prototype);
    this.originalProgressEvent = progressEvent;
  }
};
var onCancel = (signal, callback) => {
  if (signal) {
    if (signal.aborted) {
      Promise.resolve().then(callback);
    } else {
      signal.addEventListener("abort", () => callback(), { once: true });
    }
  }
};
var CancelError = class _CancelError extends Error {
  constructor(message = "Request canceled") {
    super(message);
    __publicField(this, "isCancel", true);
    Object.setPrototypeOf(this, _CancelError.prototype);
  }
};
var DEFAULT_INTERVAL = 500;
var poll = ({ check, interval = DEFAULT_INTERVAL, timeout, signal }) => new Promise((resolve, reject) => {
  let tickTimeoutId;
  let timeoutId;
  onCancel(signal, () => {
    tickTimeoutId && clearTimeout(tickTimeoutId);
    reject(new CancelError("Poll cancelled"));
  });
  if (timeout) {
    timeoutId = setTimeout(() => {
      tickTimeoutId && clearTimeout(tickTimeoutId);
      reject(new CancelError("Timed out"));
    }, timeout);
  }
  const tick = () => {
    try {
      Promise.resolve(check(signal)).then((result) => {
        if (result) {
          timeoutId && clearTimeout(timeoutId);
          resolve(result);
        } else {
          tickTimeoutId = setTimeout(tick, interval);
        }
      }).catch((error) => {
        timeoutId && clearTimeout(timeoutId);
        reject(error);
      });
    } catch (error) {
      timeoutId && clearTimeout(timeoutId);
      reject(error);
    }
  };
  tickTimeoutId = setTimeout(tick, 0);
});
var defaultSettings = {
  baseCDN: "https://ucarecdn.com",
  baseURL: "https://upload.uploadcare.com",
  maxContentLength: 50 * 1024 * 1024,
  retryThrottledRequestMaxTimes: 1,
  retryNetworkErrorMaxTimes: 3,
  multipartMinFileSize: 25 * 1024 * 1024,
  multipartChunkSize: 5 * 1024 * 1024,
  multipartMinLastPartSize: 1024 * 1024,
  maxConcurrentRequests: 4,
  pollingTimeoutMilliseconds: 1e4,
  pusherKey: "79ae88bd931ea68464d9"
};
var defaultContentType = "application/octet-stream";
var defaultFilename = "original";
var request = ({ method, url, data, headers = {}, signal, onProgress }) => new Promise((resolve, reject) => {
  const xhr = new XMLHttpRequest();
  const requestMethod = (method == null ? void 0 : method.toUpperCase()) || "GET";
  let aborted = false;
  xhr.open(requestMethod, url, true);
  if (headers) {
    Object.entries(headers).forEach((entry) => {
      const [key, value] = entry;
      typeof value !== "undefined" && !Array.isArray(value) && xhr.setRequestHeader(key, value);
    });
  }
  xhr.responseType = "text";
  onCancel(signal, () => {
    aborted = true;
    xhr.abort();
    reject(new CancelError());
  });
  xhr.onload = () => {
    if (xhr.status != 200) {
      reject(new Error(`Error ${xhr.status}: ${xhr.statusText}`));
    } else {
      const request2 = {
        method: requestMethod,
        url,
        data,
        headers: headers || void 0,
        signal,
        onProgress
      };
      const headersArray = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
      const responseHeaders = {};
      headersArray.forEach(function(line) {
        const parts = line.split(": ");
        const header = parts.shift();
        const value = parts.join(": ");
        if (header && typeof header !== "undefined") {
          responseHeaders[header] = value;
        }
      });
      const responseData = xhr.response;
      const responseStatus = xhr.status;
      resolve({
        request: request2,
        data: responseData,
        headers: responseHeaders,
        status: responseStatus
      });
    }
  };
  xhr.onerror = (progressEvent) => {
    if (aborted)
      return;
    reject(new UploadcareNetworkError(progressEvent));
  };
  if (onProgress && typeof onProgress === "function") {
    xhr.upload.onprogress = (event) => {
      if (event.lengthComputable) {
        onProgress({
          isComputable: true,
          value: event.loaded / event.total
        });
      } else {
        onProgress({ isComputable: false });
      }
    };
  }
  if (data) {
    xhr.send(data);
  } else {
    xhr.send();
  }
});
function identity(obj, ..._args) {
  return obj;
}
var getFileOptions = ({ name }) => name ? [name] : [];
var transformFile = identity;
var getFormData = () => new FormData();
var isBuffer = (data) => false;
var isBlob = (data) => {
  return typeof Blob !== "undefined" && data instanceof Blob;
};
var isFile = (data) => {
  return typeof File !== "undefined" && data instanceof File;
};
var isReactNativeAsset = (data) => {
  return !!data && typeof data === "object" && !Array.isArray(data) && "uri" in data && typeof data.uri === "string";
};
var isFileData = (data) => {
  return isBlob(data) || isFile(data) || isBuffer() || isReactNativeAsset(data);
};
var isSimpleValue = (value) => {
  return typeof value === "string" || typeof value === "number" || typeof value === "undefined";
};
var isObjectValue = (value) => {
  return !!value && typeof value === "object" && !Array.isArray(value);
};
var isFileValue = (value) => !!value && typeof value === "object" && "data" in value && isFileData(value.data);
function collectParams(params, inputKey, inputValue) {
  if (isFileValue(inputValue)) {
    const { name, contentType } = inputValue;
    const file = transformFile(inputValue.data, name, contentType ?? defaultContentType);
    const options = getFileOptions({ name, contentType });
    params.push([inputKey, file, ...options]);
  } else if (isObjectValue(inputValue)) {
    for (const [key, value] of Object.entries(inputValue)) {
      if (typeof value !== "undefined") {
        params.push([`${inputKey}[${key}]`, String(value)]);
      }
    }
  } else if (isSimpleValue(inputValue) && inputValue) {
    params.push([inputKey, inputValue.toString()]);
  }
}
function getFormDataParams(options) {
  const params = [];
  for (const [key, value] of Object.entries(options)) {
    collectParams(params, key, value);
  }
  return params;
}
function buildFormData(options) {
  const formData = getFormData();
  const paramsList = getFormDataParams(options);
  for (const params of paramsList) {
    const [key, value, ...rest] = params;
    formData.append(key, value, ...rest);
  }
  return formData;
}
var UploadClientError = class _UploadClientError extends Error {
  constructor(message, code, request2, response2, headers) {
    super();
    __publicField(this, "isCancel");
    __publicField(this, "code");
    __publicField(this, "request");
    __publicField(this, "response");
    __publicField(this, "headers");
    this.name = "UploadClientError";
    this.message = message;
    this.code = code;
    this.request = request2;
    this.response = response2;
    this.headers = headers;
    Object.setPrototypeOf(this, _UploadClientError.prototype);
  }
};
var buildSearchParams = (query) => {
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.entries(value).filter((entry) => entry[1] ?? false).forEach((entry) => searchParams.set(`${key}[${entry[0]}]`, String(entry[1])));
    } else if (Array.isArray(value)) {
      value.forEach((val) => {
        searchParams.append(`${key}[]`, val);
      });
    } else if (typeof value === "string" && value) {
      searchParams.set(key, value);
    } else if (typeof value === "number") {
      searchParams.set(key, value.toString());
    }
  }
  return searchParams.toString();
};
var getUrl = (base2, path, query) => {
  const url = new URL(base2);
  url.pathname = (url.pathname + path).replace("//", "/");
  if (query) {
    url.search = buildSearchParams(query);
  }
  return url.toString();
};
var version = "6.6.1";
var LIBRARY_NAME = "UploadcareUploadClient";
var LIBRARY_VERSION = version;
function getUserAgent(options) {
  return getUserAgent$1({
    libraryName: LIBRARY_NAME,
    libraryVersion: LIBRARY_VERSION,
    ...options
  });
}
var REQUEST_WAS_THROTTLED_CODE = "RequestThrottledError";
var DEFAULT_RETRY_AFTER_TIMEOUT = 15e3;
var DEFAULT_NETWORK_ERROR_TIMEOUT = 1e3;
function getTimeoutFromThrottledRequest(error) {
  const { headers } = error || {};
  if (!headers || typeof headers["retry-after"] !== "string") {
    return DEFAULT_RETRY_AFTER_TIMEOUT;
  }
  const seconds = parseInt(headers["retry-after"], 10);
  if (!Number.isFinite(seconds)) {
    return DEFAULT_RETRY_AFTER_TIMEOUT;
  }
  return seconds * 1e3;
}
function retryIfFailed(fn, options) {
  const { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes } = options;
  return retrier(({ attempt, retry }) => fn().catch((error) => {
    if ("response" in error && (error == null ? void 0 : error.code) === REQUEST_WAS_THROTTLED_CODE && attempt < retryThrottledRequestMaxTimes) {
      return retry(getTimeoutFromThrottledRequest(error));
    }
    if (error instanceof UploadcareNetworkError && attempt < retryNetworkErrorMaxTimes) {
      return retry((attempt + 1) * DEFAULT_NETWORK_ERROR_TIMEOUT);
    }
    throw error;
  }));
}
var getContentType = (file) => {
  let contentType = "";
  if (isBlob(file) || isFile(file) || isReactNativeAsset(file)) {
    contentType = file.type;
  }
  return contentType || defaultContentType;
};
var getFileName = (file) => {
  let filename = "";
  if (isFile(file) && file.name) {
    filename = file.name;
  } else if (isBlob(file) || isBuffer()) {
    filename = "";
  } else if (isReactNativeAsset(file) && file.name) {
    filename = file.name;
  }
  return filename || defaultFilename;
};
function getStoreValue(store) {
  if (typeof store === "undefined" || store === "auto") {
    return "auto";
  }
  return store ? "1" : "0";
}
function base(file, { publicKey, fileName, contentType, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source = "local", integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {
  return retryIfFailed(() => request({
    method: "POST",
    url: getUrl(baseURL, "/base/", {
      jsonerrors: 1
    }),
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    data: buildFormData({
      file: {
        data: file,
        name: fileName || getFileName(file),
        contentType: contentType || getContentType(file)
      },
      UPLOADCARE_PUB_KEY: publicKey,
      UPLOADCARE_STORE: getStoreValue(store),
      signature: secureSignature,
      expire: secureExpire,
      source,
      metadata
    }),
    signal,
    onProgress
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });
}
var TypeEnum;
(function(TypeEnum2) {
  TypeEnum2["Token"] = "token";
  TypeEnum2["FileInfo"] = "file_info";
})(TypeEnum || (TypeEnum = {}));
function fromUrl(sourceUrl, { publicKey, baseURL = defaultSettings.baseURL, store, fileName, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, source = "url", signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {
  return retryIfFailed(() => request({
    method: "POST",
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    url: getUrl(baseURL, "/from_url/", {
      jsonerrors: 1,
      pub_key: publicKey,
      source_url: sourceUrl,
      store: getStoreValue(store),
      filename: fileName,
      check_URL_duplicates: checkForUrlDuplicates ? 1 : void 0,
      save_URL_duplicates: saveUrlForRecurrentUploads ? 1 : void 0,
      signature: secureSignature,
      expire: secureExpire,
      source,
      metadata
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });
}
var Status;
(function(Status2) {
  Status2["Unknown"] = "unknown";
  Status2["Waiting"] = "waiting";
  Status2["Progress"] = "progress";
  Status2["Error"] = "error";
  Status2["Success"] = "success";
})(Status || (Status = {}));
var isErrorResponse = (response2) => {
  return "status" in response2 && response2.status === Status.Error;
};
function fromUrlStatus(token, { publicKey, baseURL = defaultSettings.baseURL, signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes } = {}) {
  return retryIfFailed(() => request({
    method: "GET",
    headers: publicKey ? {
      "X-UC-User-Agent": getUserAgent({
        publicKey,
        integration,
        userAgent
      })
    } : void 0,
    url: getUrl(baseURL, "/from_url/status/", {
      jsonerrors: 1,
      token
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2 && !isErrorResponse(response2)) {
      throw new UploadClientError(response2.error.content, void 0, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });
}
function group(uuids, { publicKey, baseURL = defaultSettings.baseURL, jsonpCallback, secureSignature, secureExpire, signal, source, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {
  return retryIfFailed(() => request({
    method: "POST",
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    url: getUrl(baseURL, "/group/", {
      jsonerrors: 1,
      pub_key: publicKey,
      files: uuids,
      callback: jsonpCallback,
      signature: secureSignature,
      expire: secureExpire,
      source
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });
}
function info(uuid, { publicKey, baseURL = defaultSettings.baseURL, signal, source, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {
  return retryIfFailed(() => request({
    method: "GET",
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    url: getUrl(baseURL, "/info/", {
      jsonerrors: 1,
      pub_key: publicKey,
      file_id: uuid,
      source
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });
}
function multipartStart(size, { publicKey, contentType, fileName, multipartChunkSize = defaultSettings.multipartChunkSize, baseURL = "", secureSignature, secureExpire, store, signal, source = "local", integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {
  return retryIfFailed(() => request({
    method: "POST",
    url: getUrl(baseURL, "/multipart/start/", { jsonerrors: 1 }),
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    data: buildFormData({
      filename: fileName || defaultFilename,
      size,
      content_type: contentType || defaultContentType,
      part_size: multipartChunkSize,
      UPLOADCARE_STORE: getStoreValue(store),
      UPLOADCARE_PUB_KEY: publicKey,
      signature: secureSignature,
      expire: secureExpire,
      source,
      metadata
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      response2.parts = Object.keys(response2.parts).map((key) => response2.parts[key]);
      return response2;
    }
  }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });
}
function multipartUpload(part, url, { contentType, signal, onProgress, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {
  return retryIfFailed(() => request({
    method: "PUT",
    url,
    data: part,
    // Upload request can't be non-computable because we always know exact size
    onProgress,
    signal,
    headers: {
      "Content-Type": contentType || defaultContentType
    }
  }).then((result) => {
    if (onProgress)
      onProgress({
        isComputable: true,
        value: 1
      });
    return result;
  }).then(({ status }) => ({ code: status })), {
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes
  });
}
function multipartComplete(uuid, { publicKey, baseURL = defaultSettings.baseURL, source = "local", signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {
  return retryIfFailed(() => request({
    method: "POST",
    url: getUrl(baseURL, "/multipart/complete/", { jsonerrors: 1 }),
    headers: {
      "X-UC-User-Agent": getUserAgent({ publicKey, integration, userAgent })
    },
    data: buildFormData({
      uuid,
      UPLOADCARE_PUB_KEY: publicKey,
      source
    }),
    signal
  }).then(({ data, headers, request: request2 }) => {
    const response2 = camelizeKeys(JSON.parse(data));
    if ("error" in response2) {
      throw new UploadClientError(response2.error.content, response2.error.errorCode, request2, response2, headers);
    } else {
      return response2;
    }
  }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });
}
function isReadyPoll({ file, publicKey, baseURL, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, signal, onProgress }) {
  return poll({
    check: (signal2) => info(file, {
      publicKey,
      baseURL,
      signal: signal2,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes
    }).then((response2) => {
      if (response2.isReady) {
        return response2;
      }
      onProgress && onProgress({ isComputable: true, value: 1 });
      return false;
    }),
    signal
  });
}
var UploadcareFile = class {
  constructor(fileInfo, { baseCDN = defaultSettings.baseCDN, fileName } = {}) {
    __publicField(this, "uuid");
    __publicField(this, "name", null);
    __publicField(this, "size", null);
    __publicField(this, "isStored", null);
    __publicField(this, "isImage", null);
    __publicField(this, "mimeType", null);
    __publicField(this, "cdnUrl", null);
    __publicField(this, "s3Url", null);
    __publicField(this, "originalFilename", null);
    __publicField(this, "imageInfo", null);
    __publicField(this, "videoInfo", null);
    __publicField(this, "contentInfo", null);
    __publicField(this, "metadata", null);
    __publicField(this, "s3Bucket", null);
    const { uuid, s3Bucket } = fileInfo;
    const cdnUrl = getUrl(baseCDN, `${uuid}/`);
    const s3Url = s3Bucket ? getUrl(`https://${s3Bucket}.s3.amazonaws.com/`, `${uuid}/${fileInfo.filename}`) : null;
    this.uuid = uuid;
    this.name = fileName || fileInfo.filename;
    this.size = fileInfo.size;
    this.isStored = fileInfo.isStored;
    this.isImage = fileInfo.isImage;
    this.mimeType = fileInfo.mimeType;
    this.cdnUrl = cdnUrl;
    this.originalFilename = fileInfo.originalFilename;
    this.imageInfo = fileInfo.imageInfo;
    this.videoInfo = fileInfo.videoInfo;
    this.contentInfo = fileInfo.contentInfo;
    this.metadata = fileInfo.metadata || null;
    this.s3Bucket = s3Bucket || null;
    this.s3Url = s3Url;
  }
};
var uploadDirect = (file, { publicKey, fileName, baseURL, secureSignature, secureExpire, store, contentType, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN, metadata }) => {
  return base(file, {
    publicKey,
    fileName,
    contentType,
    baseURL,
    secureSignature,
    secureExpire,
    store,
    signal,
    onProgress,
    source,
    integration,
    userAgent,
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes,
    metadata
  }).then(({ file: file2 }) => {
    return isReadyPoll({
      file: file2,
      publicKey,
      baseURL,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes,
      onProgress,
      signal
    });
  }).then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));
};
var uploadFromUploaded = (uuid, { publicKey, fileName, baseURL, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN }) => {
  return info(uuid, {
    publicKey,
    baseURL,
    signal,
    source,
    integration,
    userAgent,
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes
  }).then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN, fileName })).then((result) => {
    if (onProgress)
      onProgress({
        isComputable: true,
        value: 1
      });
    return result;
  });
};
var race = (fns, { signal } = {}) => {
  let lastError = null;
  let winnerIndex = null;
  const controllers = fns.map(() => new AbortController());
  const createStopRaceCallback = (i) => () => {
    winnerIndex = i;
    controllers.forEach((controller, index) => index !== i && controller.abort());
  };
  onCancel(signal, () => {
    controllers.forEach((controller) => controller.abort());
  });
  return Promise.all(fns.map((fn, i) => {
    const stopRace = createStopRaceCallback(i);
    return Promise.resolve().then(() => fn({ stopRace, signal: controllers[i].signal })).then((result) => {
      stopRace();
      return result;
    }).catch((error) => {
      lastError = error;
      return null;
    });
  })).then((results) => {
    if (winnerIndex === null) {
      throw lastError;
    } else {
      return results[winnerIndex];
    }
  });
};
var WebSocket = window.WebSocket;
var Events = class {
  constructor() {
    __publicField(this, "events", /* @__PURE__ */ Object.create({}));
  }
  emit(event, data) {
    var _a2;
    (_a2 = this.events[event]) == null ? void 0 : _a2.forEach((fn) => fn(data));
  }
  on(event, callback) {
    this.events[event] = this.events[event] || [];
    this.events[event].push(callback);
  }
  off(event, callback) {
    if (callback) {
      this.events[event] = this.events[event].filter((fn) => fn !== callback);
    } else {
      this.events[event] = [];
    }
  }
};
var response = (type, data) => {
  if (type === "success") {
    return { status: Status.Success, ...data };
  }
  if (type === "progress") {
    return { status: Status.Progress, ...data };
  }
  return { status: Status.Error, ...data };
};
var Pusher = class {
  constructor(pusherKey, disconnectTime = 3e4) {
    __publicField(this, "key");
    __publicField(this, "disconnectTime");
    __publicField(this, "ws");
    __publicField(this, "queue", []);
    __publicField(this, "isConnected", false);
    __publicField(this, "subscribers", 0);
    __publicField(this, "emmitter", new Events());
    __publicField(this, "disconnectTimeoutId", null);
    this.key = pusherKey;
    this.disconnectTime = disconnectTime;
  }
  connect() {
    this.disconnectTimeoutId && clearTimeout(this.disconnectTimeoutId);
    if (!this.isConnected && !this.ws) {
      const pusherUrl = `wss://ws.pusherapp.com/app/${this.key}?protocol=5&client=js&version=1.12.2`;
      this.ws = new WebSocket(pusherUrl);
      this.ws.addEventListener("error", (error) => {
        this.emmitter.emit("error", new Error(error.message));
      });
      this.emmitter.on("connected", () => {
        this.isConnected = true;
        this.queue.forEach((message) => this.send(message.event, message.data));
        this.queue = [];
      });
      this.ws.addEventListener("message", (e) => {
        const data = JSON.parse(e.data.toString());
        switch (data.event) {
          case "pusher:connection_established": {
            this.emmitter.emit("connected", void 0);
            break;
          }
          case "pusher:ping": {
            this.send("pusher:pong", {});
            break;
          }
          case "progress":
          case "success":
          case "fail": {
            this.emmitter.emit(data.channel, response(data.event, JSON.parse(data.data)));
          }
        }
      });
    }
  }
  disconnect() {
    const actualDisconect = () => {
      var _a2;
      (_a2 = this.ws) == null ? void 0 : _a2.close();
      this.ws = void 0;
      this.isConnected = false;
    };
    if (this.disconnectTime) {
      this.disconnectTimeoutId = setTimeout(() => {
        actualDisconect();
      }, this.disconnectTime);
    } else {
      actualDisconect();
    }
  }
  send(event, data) {
    var _a2;
    const str = JSON.stringify({ event, data });
    (_a2 = this.ws) == null ? void 0 : _a2.send(str);
  }
  subscribe(token, handler) {
    this.subscribers += 1;
    this.connect();
    const channel = `task-status-${token}`;
    const message = {
      event: "pusher:subscribe",
      data: { channel }
    };
    this.emmitter.on(channel, handler);
    if (this.isConnected) {
      this.send(message.event, message.data);
    } else {
      this.queue.push(message);
    }
  }
  unsubscribe(token) {
    this.subscribers -= 1;
    const channel = `task-status-${token}`;
    const message = {
      event: "pusher:unsubscribe",
      data: { channel }
    };
    this.emmitter.off(channel);
    if (this.isConnected) {
      this.send(message.event, message.data);
    } else {
      this.queue = this.queue.filter((msg) => msg.data.channel !== channel);
    }
    if (this.subscribers === 0) {
      this.disconnect();
    }
  }
  onError(callback) {
    this.emmitter.on("error", callback);
    return () => this.emmitter.off("error", callback);
  }
};
var pusher = null;
var getPusher = (key) => {
  if (!pusher) {
    const disconectTimeout = typeof window === "undefined" ? 0 : 3e4;
    pusher = new Pusher(key, disconectTimeout);
  }
  return pusher;
};
var preconnect = (key) => {
  getPusher(key).connect();
};
function pollStrategy({ token, publicKey, baseURL, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, onProgress, signal }) {
  return poll({
    check: (signal2) => fromUrlStatus(token, {
      publicKey,
      baseURL,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes,
      signal: signal2
    }).then((response2) => {
      switch (response2.status) {
        case Status.Error: {
          return new UploadClientError(response2.error, response2.errorCode);
        }
        case Status.Waiting: {
          return false;
        }
        case Status.Unknown: {
          return new UploadClientError(`Token "${token}" was not found.`);
        }
        case Status.Progress: {
          if (onProgress) {
            if (response2.total === "unknown") {
              onProgress({ isComputable: false });
            } else {
              onProgress({
                isComputable: true,
                value: response2.done / response2.total
              });
            }
          }
          return false;
        }
        case Status.Success: {
          if (onProgress)
            onProgress({
              isComputable: true,
              value: response2.done / response2.total
            });
          return response2;
        }
        default: {
          throw new Error("Unknown status");
        }
      }
    }),
    signal
  });
}
var pushStrategy = ({ token, pusherKey, signal, onProgress }) => new Promise((resolve, reject) => {
  const pusher2 = getPusher(pusherKey);
  const unsubErrorHandler = pusher2.onError(reject);
  const destroy = () => {
    unsubErrorHandler();
    pusher2.unsubscribe(token);
  };
  onCancel(signal, () => {
    destroy();
    reject(new CancelError("pusher cancelled"));
  });
  pusher2.subscribe(token, (result) => {
    switch (result.status) {
      case Status.Progress: {
        if (onProgress) {
          if (result.total === "unknown") {
            onProgress({ isComputable: false });
          } else {
            onProgress({
              isComputable: true,
              value: result.done / result.total
            });
          }
        }
        break;
      }
      case Status.Success: {
        destroy();
        if (onProgress)
          onProgress({
            isComputable: true,
            value: result.done / result.total
          });
        resolve(result);
        break;
      }
      case Status.Error: {
        destroy();
        reject(new UploadClientError(result.msg, result.error_code));
      }
    }
  });
});
var uploadFromUrl = (sourceUrl, { publicKey, fileName, baseURL, baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, pusherKey = defaultSettings.pusherKey, metadata }) => Promise.resolve(preconnect(pusherKey)).then(() => fromUrl(sourceUrl, {
  publicKey,
  fileName,
  baseURL,
  checkForUrlDuplicates,
  saveUrlForRecurrentUploads,
  secureSignature,
  secureExpire,
  store,
  signal,
  source,
  integration,
  userAgent,
  retryThrottledRequestMaxTimes,
  metadata
})).catch((error) => {
  const pusher2 = getPusher(pusherKey);
  pusher2 == null ? void 0 : pusher2.disconnect();
  return Promise.reject(error);
}).then((urlResponse) => {
  if (urlResponse.type === TypeEnum.FileInfo) {
    return urlResponse;
  } else {
    return race([
      ({ signal: signal2 }) => pollStrategy({
        token: urlResponse.token,
        publicKey,
        baseURL,
        integration,
        userAgent,
        retryThrottledRequestMaxTimes,
        onProgress,
        signal: signal2
      }),
      ({ signal: signal2 }) => pushStrategy({
        token: urlResponse.token,
        pusherKey,
        signal: signal2,
        onProgress
      })
    ], { signal });
  }
}).then((result) => {
  if (result instanceof UploadClientError)
    throw result;
  return result;
}).then((result) => isReadyPoll({
  file: result.uuid,
  publicKey,
  baseURL,
  integration,
  userAgent,
  retryThrottledRequestMaxTimes,
  onProgress,
  signal
})).then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));
var memo = /* @__PURE__ */ new WeakMap();
var getBlobFromReactNativeAsset = async (asset) => {
  if (memo.has(asset)) {
    return memo.get(asset);
  }
  const blob = await fetch(asset.uri).then((res) => res.blob());
  memo.set(asset, blob);
  return blob;
};
var getFileSize = async (file) => {
  if (isFile(file) || isBlob(file)) {
    return file.size;
  }
  if (isReactNativeAsset(file)) {
    const blob = await getBlobFromReactNativeAsset(file);
    return blob.size;
  }
  throw new Error(`Unknown file type. Cannot determine file size.`);
};
var isMultipart = (fileSize, multipartMinFileSize = defaultSettings.multipartMinFileSize) => {
  return fileSize >= multipartMinFileSize;
};
var isUuid = (data) => {
  const UUID_REGEX = "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}";
  const regExp = new RegExp(UUID_REGEX);
  return !isFileData(data) && regExp.test(data);
};
var isUrl = (data) => {
  const URL_REGEX = "^(?:\\w+:)?\\/\\/([^\\s\\.]+\\.\\S{2}|localhost[\\:?\\d]*)\\S*$";
  const regExp = new RegExp(URL_REGEX);
  return !isFileData(data) && regExp.test(data);
};
var runWithConcurrency = (concurrency, tasks) => {
  return new Promise((resolve, reject) => {
    const results = [];
    let rejected = false;
    let settled = tasks.length;
    const forRun = [...tasks];
    const run = () => {
      const index = tasks.length - forRun.length;
      const next = forRun.shift();
      if (next) {
        next().then((result) => {
          if (rejected)
            return;
          results[index] = result;
          settled -= 1;
          if (settled) {
            run();
          } else {
            resolve(results);
          }
        }).catch((error) => {
          rejected = true;
          reject(error);
        });
      }
    };
    for (let i = 0; i < concurrency; i++) {
      run();
    }
  });
};
var sliceChunk = (file, index, fileSize, chunkSize) => {
  const start = chunkSize * index;
  const end = Math.min(start + chunkSize, fileSize);
  return file.slice(start, end);
};
var prepareChunks = async (file, fileSize, chunkSize) => {
  return (index) => sliceChunk(file, index, fileSize, chunkSize);
};
var uploadPart = (chunk, url, { publicKey, contentType, onProgress, signal, integration, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }) => multipartUpload(chunk, url, {
  publicKey,
  contentType,
  onProgress,
  signal,
  integration,
  retryThrottledRequestMaxTimes,
  retryNetworkErrorMaxTimes
});
var uploadMultipart = async (file, { publicKey, fileName, fileSize, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize = defaultSettings.multipartChunkSize, maxConcurrentRequests = defaultSettings.maxConcurrentRequests, baseCDN, metadata }) => {
  const size = fileSize ?? await getFileSize(file);
  let progressValues;
  const createProgressHandler = (totalChunks, chunkIdx) => {
    if (!onProgress)
      return;
    if (!progressValues) {
      progressValues = Array(totalChunks).fill(0);
    }
    const sum = (values) => values.reduce((sum2, next) => sum2 + next, 0);
    return (info2) => {
      if (!info2.isComputable) {
        return;
      }
      progressValues[chunkIdx] = info2.value;
      onProgress({
        isComputable: true,
        value: sum(progressValues) / totalChunks
      });
    };
  };
  contentType || (contentType = getContentType(file));
  return multipartStart(size, {
    publicKey,
    contentType,
    fileName: fileName || getFileName(file),
    baseURL,
    secureSignature,
    secureExpire,
    store,
    signal,
    source,
    integration,
    userAgent,
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes,
    metadata
  }).then(async ({ uuid, parts }) => {
    const getChunk = await prepareChunks(file, size, multipartChunkSize);
    return Promise.all([
      uuid,
      runWithConcurrency(maxConcurrentRequests, parts.map((url, index) => () => uploadPart(getChunk(index), url, {
        publicKey,
        contentType,
        onProgress: createProgressHandler(parts.length, index),
        signal,
        integration,
        retryThrottledRequestMaxTimes,
        retryNetworkErrorMaxTimes
      })))
    ]);
  }).then(([uuid]) => multipartComplete(uuid, {
    publicKey,
    baseURL,
    source,
    integration,
    userAgent,
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes
  })).then((fileInfo) => {
    if (fileInfo.isReady) {
      return fileInfo;
    } else {
      return isReadyPoll({
        file: fileInfo.uuid,
        publicKey,
        baseURL,
        source,
        integration,
        userAgent,
        retryThrottledRequestMaxTimes,
        retryNetworkErrorMaxTimes,
        onProgress,
        signal
      });
    }
  }).then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));
};
async function uploadFile(data, { publicKey, fileName, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartMinFileSize, multipartChunkSize, maxConcurrentRequests, baseCDN = defaultSettings.baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, pusherKey, metadata }) {
  if (isFileData(data)) {
    const fileSize = await getFileSize(data);
    if (isMultipart(fileSize, multipartMinFileSize)) {
      return uploadMultipart(data, {
        publicKey,
        contentType,
        multipartChunkSize,
        fileSize,
        fileName,
        baseURL,
        secureSignature,
        secureExpire,
        store,
        signal,
        onProgress,
        source,
        integration,
        userAgent,
        maxConcurrentRequests,
        retryThrottledRequestMaxTimes,
        retryNetworkErrorMaxTimes,
        baseCDN,
        metadata
      });
    }
    return uploadDirect(data, {
      publicKey,
      fileName,
      contentType,
      baseURL,
      secureSignature,
      secureExpire,
      store,
      signal,
      onProgress,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes,
      baseCDN,
      metadata
    });
  }
  if (isUrl(data)) {
    return uploadFromUrl(data, {
      publicKey,
      fileName,
      baseURL,
      baseCDN,
      checkForUrlDuplicates,
      saveUrlForRecurrentUploads,
      secureSignature,
      secureExpire,
      store,
      signal,
      onProgress,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes,
      pusherKey,
      metadata
    });
  }
  if (isUuid(data)) {
    return uploadFromUploaded(data, {
      publicKey,
      fileName,
      baseURL,
      signal,
      onProgress,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes,
      baseCDN
    });
  }
  throw new TypeError(`File uploading from "${data}" is not supported`);
}
var UploadcareGroup = class {
  constructor(groupInfo, files) {
    __publicField(this, "uuid");
    __publicField(this, "filesCount");
    __publicField(this, "totalSize");
    __publicField(this, "isStored");
    __publicField(this, "isImage");
    __publicField(this, "cdnUrl");
    __publicField(this, "files");
    __publicField(this, "createdAt");
    __publicField(this, "storedAt", null);
    this.uuid = groupInfo.id;
    this.filesCount = groupInfo.filesCount;
    this.totalSize = Object.values(groupInfo.files).reduce((acc, file) => acc + file.size, 0);
    this.isStored = !!groupInfo.datetimeStored;
    this.isImage = !!Object.values(groupInfo.files).filter((file) => file.isImage).length;
    this.cdnUrl = groupInfo.cdnUrl;
    this.files = files;
    this.createdAt = groupInfo.datetimeCreated;
    this.storedAt = groupInfo.datetimeStored;
  }
};
var isFileDataArray = (data) => {
  for (const item of data) {
    if (!isFileData(item)) {
      return false;
    }
  }
  return true;
};
var isUuidArray = (data) => {
  for (const item of data) {
    if (!isUuid(item)) {
      return false;
    }
  }
  return true;
};
var isUrlArray = (data) => {
  for (const item of data) {
    if (!isUrl(item)) {
      return false;
    }
  }
  return true;
};
function uploadFileGroup(data, { publicKey, fileName, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize = defaultSettings.multipartChunkSize, baseCDN = defaultSettings.baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, jsonpCallback }) {
  if (!isFileDataArray(data) && !isUrlArray(data) && !isUuidArray(data)) {
    throw new TypeError(`Group uploading from "${data}" is not supported`);
  }
  let progressValues;
  let isStillComputable = true;
  const filesCount = data.length;
  const createProgressHandler = (size, index) => {
    if (!onProgress)
      return;
    if (!progressValues) {
      progressValues = Array(size).fill(0);
    }
    const normalize2 = (values) => values.reduce((sum, next) => sum + next) / size;
    return (info2) => {
      if (!info2.isComputable || !isStillComputable) {
        isStillComputable = false;
        onProgress({ isComputable: false });
        return;
      }
      progressValues[index] = info2.value;
      onProgress({ isComputable: true, value: normalize2(progressValues) });
    };
  };
  return Promise.all(data.map((file, index) => uploadFile(file, {
    publicKey,
    fileName,
    baseURL,
    secureSignature,
    secureExpire,
    store,
    signal,
    onProgress: createProgressHandler(filesCount, index),
    source,
    integration,
    userAgent,
    retryThrottledRequestMaxTimes,
    retryNetworkErrorMaxTimes,
    contentType,
    multipartChunkSize,
    baseCDN,
    checkForUrlDuplicates,
    saveUrlForRecurrentUploads
  }))).then((files) => {
    const uuids = files.map((file) => file.uuid);
    return group(uuids, {
      publicKey,
      baseURL,
      jsonpCallback,
      secureSignature,
      secureExpire,
      signal,
      source,
      integration,
      userAgent,
      retryThrottledRequestMaxTimes,
      retryNetworkErrorMaxTimes
    }).then((groupInfo) => new UploadcareGroup(groupInfo, files)).then((group2) => {
      onProgress && onProgress({ isComputable: true, value: 1 });
      return group2;
    });
  });
}

// node_modules/@uploadcare/blocks/abstract/uploadEntrySchema.js
var uploadEntrySchema = Object.freeze({
  file: {
    type: File,
    value: null
  },
  externalUrl: {
    type: String,
    value: null
  },
  fileName: {
    type: String,
    value: null,
    nullable: true
  },
  fileSize: {
    type: Number,
    value: null
  },
  lastModified: {
    type: Number,
    value: Date.now()
  },
  uploadProgress: {
    type: Number,
    value: 0
  },
  uuid: {
    type: String,
    value: null
  },
  isImage: {
    type: Boolean,
    value: false
  },
  mimeType: {
    type: String,
    value: null
  },
  uploadError: {
    // TODO: there could be Error or UploadcareClientError
    type: Error,
    value: null,
    nullable: true
  },
  validationErrorMsg: {
    type: String,
    value: null,
    nullable: true
  },
  ctxName: {
    type: String,
    value: null
  },
  cdnUrl: {
    type: String,
    value: null
  },
  cdnUrlModifiers: {
    type: String,
    value: null
  },
  fileInfo: {
    type: UploadcareFile,
    value: null
  },
  isUploading: {
    type: Boolean,
    value: false
  },
  abortController: {
    type: AbortController,
    value: null,
    nullable: true
  },
  thumbUrl: {
    type: String,
    value: null,
    nullable: true
  }
});

// node_modules/@uploadcare/blocks/blocks/utils/userAgent.js
function customUserAgent(options) {
  return getUserAgent$1({
    ...options,
    libraryName: PACKAGE_NAME,
    libraryVersion: PACKAGE_VERSION
  });
}

// node_modules/@uploadcare/blocks/abstract/TypedData.js
var MSG_NAME = "[Typed State] Wrong property name: ";
var MSG_TYPE = "[Typed State] Wrong property type: ";
var TypedData = class {
  /**
   * @param {Object<string, { type: any; value: any; nullable?: Boolean }>} typedSchema
   * @param {String} [ctxName]
   */
  constructor(typedSchema, ctxName) {
    this.__typedSchema = typedSchema;
    this.__ctxId = ctxName || UID.generate();
    this.__schema = Object.keys(typedSchema).reduce((acc, key) => {
      acc[key] = typedSchema[key].value;
      return acc;
    }, {});
    this.__data = Data.registerCtx(this.__schema, this.__ctxId);
  }
  /** @returns {String} */
  get uid() {
    return this.__ctxId;
  }
  /**
   * @param {String} prop
   * @param {any} value
   */
  setValue(prop, value) {
    if (!this.__typedSchema.hasOwnProperty(prop)) {
      console.warn(MSG_NAME + prop);
      return;
    }
    let pDesc = this.__typedSchema[prop];
    if ((value == null ? void 0 : value.constructor) === pDesc.type || value instanceof pDesc.type || pDesc.nullable && value === null) {
      this.__data.pub(prop, value);
      return;
    }
    console.warn(MSG_TYPE + prop);
  }
  /** @param {Object<string, any>} updObj */
  setMultipleValues(updObj) {
    for (let prop in updObj) {
      this.setValue(prop, updObj[prop]);
    }
  }
  /** @param {String} prop */
  getValue(prop) {
    if (!this.__typedSchema.hasOwnProperty(prop)) {
      console.warn(MSG_NAME + prop);
      return void 0;
    }
    return this.__data.read(prop);
  }
  /**
   * @param {String} prop
   * @param {(newVal: any) => void} handler
   */
  subscribe(prop, handler) {
    return this.__data.sub(prop, handler);
  }
  remove() {
    Data.deleteCtx(this.__ctxId);
  }
};

// node_modules/@uploadcare/blocks/abstract/TypedCollection.js
var TypedCollection = class {
  /**
   * @param {Object} options
   * @param {Object<string, { type: any; value: any }>} options.typedSchema
   * @param {String[]} [options.watchList]
   * @param {(list: string[], added: Set<any>, removed: Set<any>) => void} [options.handler]
   * @param {String} [options.ctxName]
   */
  constructor(options) {
    this.__typedSchema = options.typedSchema;
    this.__ctxId = options.ctxName || UID.generate();
    this.__data = Data.registerCtx({}, this.__ctxId);
    this.__watchList = options.watchList || [];
    this.__handler = options.handler || null;
    this.__subsMap = /* @__PURE__ */ Object.create(null);
    this.__observers = /* @__PURE__ */ new Set();
    this.__items = /* @__PURE__ */ new Set();
    this.__removed = /* @__PURE__ */ new Set();
    this.__added = /* @__PURE__ */ new Set();
    let changeMap = /* @__PURE__ */ Object.create(null);
    this.__notifyObservers = (propName, ctxId) => {
      if (this.__observeTimeout) {
        window.clearTimeout(this.__observeTimeout);
      }
      if (!changeMap[propName]) {
        changeMap[propName] = /* @__PURE__ */ new Set();
      }
      changeMap[propName].add(ctxId);
      this.__observeTimeout = window.setTimeout(() => {
        this.__observers.forEach((handler) => {
          handler({ ...changeMap });
        });
        changeMap = /* @__PURE__ */ Object.create(null);
      });
    };
  }
  notify() {
    if (this.__notifyTimeout) {
      window.clearTimeout(this.__notifyTimeout);
    }
    this.__notifyTimeout = window.setTimeout(() => {
      var _a2;
      let added = this.__added;
      let removed = this.__removed;
      this.__added.clear();
      this.__removed.clear();
      (_a2 = this.__handler) == null ? void 0 : _a2.call(this, [...this.__items], added, removed);
    });
  }
  /**
   * @param {Object<string, any>} init
   * @returns {any}
   */
  add(init) {
    let item = new TypedData(this.__typedSchema);
    for (let prop in init) {
      item.setValue(prop, init[prop]);
    }
    this.__data.add(item.uid, item);
    this.__added.add(item);
    this.__watchList.forEach((propName) => {
      if (!this.__subsMap[item.uid]) {
        this.__subsMap[item.uid] = [];
      }
      this.__subsMap[item.uid].push(
        item.subscribe(propName, () => {
          this.__notifyObservers(propName, item.uid);
        })
      );
    });
    this.__items.add(item.uid);
    this.notify();
    return item;
  }
  /**
   * @param {String} id
   * @returns {TypedData}
   */
  read(id) {
    return this.__data.read(id);
  }
  /**
   * @param {String} id
   * @param {String} propName
   * @returns {any}
   */
  readProp(id, propName) {
    let item = this.read(id);
    return item.getValue(propName);
  }
  /**
   * @template T
   * @param {String} id
   * @param {String} propName
   * @param {T} value
   */
  publishProp(id, propName, value) {
    let item = this.read(id);
    item.setValue(propName, value);
  }
  /** @param {String} id */
  remove(id) {
    this.__removed.add(this.__data.read(id));
    this.__items.delete(id);
    this.notify();
    this.__data.pub(id, null);
    delete this.__subsMap[id];
  }
  clearAll() {
    this.__items.forEach((id) => {
      this.remove(id);
    });
  }
  /** @param {Function} handler */
  observe(handler) {
    this.__observers.add(handler);
  }
  /** @param {Function} handler */
  unobserve(handler) {
    this.__observers.delete(handler);
  }
  /**
   * @param {(item: TypedData) => Boolean} checkFn
   * @returns {String[]}
   */
  findItems(checkFn) {
    let result = [];
    this.__items.forEach((id) => {
      let item = this.read(id);
      if (checkFn(item)) {
        result.push(id);
      }
    });
    return result;
  }
  items() {
    return [...this.__items];
  }
  get size() {
    return this.__items.size;
  }
  destroy() {
    Data.deleteCtx(this.__data);
    this.__observers = null;
    for (let id in this.__subsMap) {
      this.__subsMap[id].forEach((sub) => {
        sub.remove();
      });
      delete this.__subsMap[id];
    }
  }
};

// node_modules/@uploadcare/blocks/abstract/EventManager.js
var EVENT_TYPES = {
  UPLOAD_START: "UPLOAD_START",
  REMOVE: "REMOVE",
  UPLOAD_PROGRESS: "UPLOAD_PROGRESS",
  UPLOAD_FINISH: "UPLOAD_FINISH",
  UPLOAD_ERROR: "UPLOAD_ERROR",
  VALIDATION_ERROR: "VALIDATION_ERROR",
  CDN_MODIFICATION: "CLOUD_MODIFICATION",
  DATA_OUTPUT: "DATA_OUTPUT",
  DONE_FLOW: "DONE_FLOW",
  INIT_FLOW: "INIT_FLOW"
};
var EventData = class {
  /**
   * @param {Object} src
   * @param {EVENT_TYPES} src.type
   * @param {String} src.ctx
   * @param {any} [src.data]
   */
  constructor(src) {
    this.ctx = src.ctx;
    this.type = src.type;
    this.data = src.data;
  }
};
var EventManager = class {
  /** @param {EVENT_TYPES} type */
  static eName(type) {
    return "LR_" + type;
  }
  /**
   * @param {EventData} eData
   * @param {import('./UploaderBlock.js').UploaderBlock | Window} [el]
   * @param {Boolean} [debounce]
   */
  static emit(eData, el = window, debounce3 = true) {
    let dispatch = () => {
      el.dispatchEvent(
        new CustomEvent(this.eName(eData.type), {
          detail: eData
        })
      );
    };
    if (!debounce3) {
      dispatch();
      return;
    }
    let timeoutKey = eData.type + eData.ctx;
    if (this._timeoutStore[timeoutKey]) {
      window.clearTimeout(this._timeoutStore[timeoutKey]);
    }
    this._timeoutStore[timeoutKey] = window.setTimeout(() => {
      dispatch();
      delete this._timeoutStore[timeoutKey];
    }, 20);
  }
};
/** @private */
__publicField(EventManager, "_timeoutStore", /* @__PURE__ */ Object.create(null));

// node_modules/@uploadcare/blocks/abstract/UploaderBlock.js
var UploaderBlock = class _UploaderBlock extends ActivityBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "ctxInit", uploaderBlockCtx(this));
    /** @private */
    __publicField(this, "__initialUploadMetadata", null);
    /** @private */
    __publicField(this, "_handleCollectionUpdate", (changeMap) => {
      let uploadCollection = this.uploadCollection;
      if (changeMap.uploadProgress) {
        let commonProgress = 0;
        let items = uploadCollection.findItems((entry) => {
          return !entry.getValue("uploadError");
        });
        items.forEach((id) => {
          commonProgress += uploadCollection.readProp(id, "uploadProgress");
        });
        let progress = Math.round(commonProgress / items.length);
        this.$["*commonProgress"] = progress;
        EventManager.emit(
          new EventData({
            type: EVENT_TYPES.UPLOAD_PROGRESS,
            ctx: this.ctxName,
            data: progress
          }),
          void 0,
          progress === 100
        );
      }
      if (changeMap.uuid) {
        let loadedItems = uploadCollection.findItems((entry) => {
          return !!entry.getValue("uuid");
        });
        let errorItems = uploadCollection.findItems((entry) => {
          return !!entry.getValue("uploadError") || !!entry.getValue("validationErrorMsg");
        });
        if (uploadCollection.size - errorItems.length === loadedItems.length) {
          let data = this.getOutputData((dataItem) => {
            return !!dataItem.getValue("uuid");
          });
          EventManager.emit(
            new EventData({
              type: EVENT_TYPES.UPLOAD_FINISH,
              ctx: this.ctxName,
              data
            })
          );
        }
      }
      if (changeMap.uploadError) {
        let items = uploadCollection.findItems((entry) => {
          return !!entry.getValue("uploadError");
        });
        items.forEach((id) => {
          EventManager.emit(
            new EventData({
              type: EVENT_TYPES.UPLOAD_ERROR,
              ctx: this.ctxName,
              data: uploadCollection.readProp(id, "uploadError")
            }),
            void 0,
            false
          );
        });
      }
      if (changeMap.validationErrorMsg) {
        let items = uploadCollection.findItems((entry) => {
          return !!entry.getValue("validationErrorMsg");
        });
        items.forEach((id) => {
          EventManager.emit(
            new EventData({
              type: EVENT_TYPES.VALIDATION_ERROR,
              ctx: this.ctxName,
              data: uploadCollection.readProp(id, "validationErrorMsg")
            }),
            void 0,
            false
          );
        });
      }
      if (changeMap.cdnUrlModifiers) {
        let items = uploadCollection.findItems((entry) => {
          return !!entry.getValue("cdnUrlModifiers");
        });
        items.forEach((id) => {
          EventManager.emit(
            new EventData({
              type: EVENT_TYPES.CDN_MODIFICATION,
              ctx: this.ctxName,
              data: Data.getCtx(id).store
            }),
            void 0,
            false
          );
        });
      }
    });
  }
  /**
   * This is Public JS API method. Could be called before block initialization, so we need to delay state interactions
   * until block init.
   *
   * TODO: If we add more public methods, it is better to use the single queue instead of tons of private fields per
   * each method. See https://github.com/uploadcare/blocks/pull/162/
   *
   * @param {import('@uploadcare/upload-client').Metadata} metadata
   * @public
   */
  setUploadMetadata(metadata) {
    if (!this.connectedOnce) {
      this.__initialUploadMetadata = metadata;
    } else {
      this.$["*uploadMetadata"] = metadata;
    }
  }
  initCallback() {
    super.initCallback();
    if (this.__initialUploadMetadata) {
      this.$["*uploadMetadata"] = this.__initialUploadMetadata;
    }
  }
  destroyCallback() {
    super.destroyCallback();
    let blocksRegistry = this.$["*blocksRegistry"];
    if (blocksRegistry.has(this)) {
      this.uploadCollection.unobserve(this._handleCollectionUpdate);
      blocksRegistry.delete(this);
    }
  }
  /** @param {File[]} files */
  addFiles(files) {
    files.forEach((file) => {
      this.uploadCollection.add({
        file,
        isImage: fileIsImage(file),
        mimeType: file.type,
        fileName: file.name,
        fileSize: file.size
      });
    });
  }
  /** @param {{ captureCamera?: boolean }} options */
  openSystemDialog(options = {}) {
    let accept = mergeFileTypes([
      this.getCssData("--cfg-accept"),
      ...this.getCssData("--cfg-img-only") ? IMAGE_ACCEPT_LIST : []
    ]).join(",");
    if (this.getCssData("--cfg-accept") && !!this.getCssData("--cfg-img-only")) {
      console.warn(
        "There could be a mistake.\nBoth `--cfg-accept` and `--cfg-img-only` parameters are set.\nThe value of `--cfg-accept` will be concatenated with the internal image mime types list."
      );
    }
    this.fileInput = document.createElement("input");
    this.fileInput.type = "file";
    this.fileInput.multiple = !!this.getCssData("--cfg-multiple");
    if (options.captureCamera) {
      this.fileInput.capture = "";
      this.fileInput.accept = IMAGE_ACCEPT_LIST.join(",");
    } else {
      this.fileInput.accept = accept;
    }
    this.fileInput.dispatchEvent(new MouseEvent("click"));
    this.fileInput.onchange = () => {
      this.addFiles([...this.fileInput["files"]]);
      this.$["*currentActivity"] = ActivityBlock.activities.UPLOAD_LIST;
      this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", true);
      this.fileInput["value"] = "";
      this.fileInput = null;
    };
  }
  /** @type {String[]} */
  get sourceList() {
    let list = null;
    if (this.getCssData("--cfg-source-list")) {
      list = stringToArray(this.getCssData("--cfg-source-list"));
    }
    return list;
  }
  /** @param {Boolean} [force] */
  initFlow(force = false) {
    var _a2, _b;
    if (((_a2 = this.$["*uploadList"]) == null ? void 0 : _a2.length) && !force) {
      this.set$({
        "*currentActivity": ActivityBlock.activities.UPLOAD_LIST
      });
      this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", true);
    } else {
      if (((_b = this.sourceList) == null ? void 0 : _b.length) === 1) {
        let srcKey = this.sourceList[0];
        if (srcKey === "local") {
          this.$["*currentActivity"] = ActivityBlock.activities.UPLOAD_LIST;
          this == null ? void 0 : this["openSystemDialog"]();
        } else {
          if (Object.values(_UploaderBlock.extSrcList).includes(
            /** @type {any} */
            srcKey
          )) {
            this.set$({
              "*currentActivityParams": {
                externalSourceType: srcKey
              },
              "*currentActivity": ActivityBlock.activities.EXTERNAL
            });
          } else {
            this.$["*currentActivity"] = srcKey;
          }
          this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", true);
        }
      } else {
        this.set$({
          "*currentActivity": ActivityBlock.activities.START_FROM
        });
        this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", true);
      }
    }
    EventManager.emit(
      new EventData({
        type: EVENT_TYPES.INIT_FLOW,
        ctx: this.ctxName
      }),
      void 0,
      false
    );
  }
  doneFlow() {
    this.set$({
      "*currentActivity": this.doneActivity,
      "*history": this.doneActivity ? [this.doneActivity] : []
    });
    if (!this.$["*currentActivity"]) {
      this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", false);
    }
    EventManager.emit(
      new EventData({
        type: EVENT_TYPES.DONE_FLOW,
        ctx: this.ctxName
      }),
      void 0,
      false
    );
  }
  /** @returns {TypedCollection} */
  get uploadCollection() {
    if (!this.has("*uploadCollection")) {
      let uploadCollection = new TypedCollection({
        typedSchema: uploadEntrySchema,
        watchList: ["uploadProgress", "uuid", "uploadError", "validationErrorMsg", "cdnUrlModifiers"],
        handler: (entries, added, removed) => {
          var _a2;
          for (let entry of removed) {
            (_a2 = entry == null ? void 0 : entry.getValue("abortController")) == null ? void 0 : _a2.abort();
            entry == null ? void 0 : entry.setValue("abortController", null);
            URL.revokeObjectURL(entry == null ? void 0 : entry.getValue("thumbUrl"));
          }
          this.$["*uploadList"] = entries.map((uid) => {
            return { uid };
          });
        }
      });
      uploadCollection.observe(this._handleCollectionUpdate);
      this.add("*uploadCollection", uploadCollection);
    }
    return this.$["*uploadCollection"];
  }
  /** @returns {import('@uploadcare/upload-client').FileFromOptions} */
  getUploadClientOptions() {
    let store = this.getCssData("--cfg-store", true);
    let options = {
      // undefined 'store' means 'auto'
      store: store === null ? void 0 : !!store,
      publicKey: this.getCssData("--cfg-pubkey"),
      baseCDN: this.getCssData("--cfg-cdn-cname"),
      baseURL: this.getCssData("--cfg-base-url"),
      userAgent: customUserAgent,
      integration: this.getCssData("--cfg-user-agent-integration"),
      secureSignature: this.getCssData("--cfg-secure-signature"),
      secureExpire: this.getCssData("--cfg-secure-expire"),
      retryThrottledRequestMaxTimes: this.getCssData("--cfg-retry-throttled-request-max-times"),
      multipartMinFileSize: this.getCssData("--cfg-multipart-min-file-size"),
      multipartChunkSize: this.getCssData("--cfg-multipart-chunk-size"),
      maxConcurrentRequests: this.getCssData("--cfg-max-concurrent-requests"),
      multipartMaxAttempts: this.getCssData("--cfg-multipart-max-attempts"),
      checkForUrlDuplicates: !!this.getCssData("--cfg-check-for-url-duplicates"),
      saveUrlForRecurrentUploads: !!this.getCssData("--cfg-save-url-for-recurrent-uploads"),
      metadata: this.$["*uploadMetadata"]
    };
    console.log("Upload client options:", options);
    return options;
  }
  /** @param {(item: import('./TypedData.js').TypedData) => Boolean} checkFn */
  getOutputData(checkFn) {
    let data = [];
    let items = this.uploadCollection.findItems(checkFn);
    items.forEach((itemId) => {
      let uploadEntryData = Data.getCtx(itemId).store;
      let fileInfo = uploadEntryData.fileInfo || {
        name: uploadEntryData.fileName,
        fileSize: uploadEntryData.fileSize,
        isImage: uploadEntryData.isImage,
        mimeType: uploadEntryData.mimeType
      };
      let outputItem = {
        ...fileInfo,
        cdnUrlModifiers: uploadEntryData.cdnUrlModifiers,
        cdnUrl: uploadEntryData.cdnUrl || fileInfo.cdnUrl
      };
      data.push(outputItem);
    });
    return data;
  }
};
UploaderBlock.extSrcList = Object.freeze({
  FACEBOOK: "facebook",
  DROPBOX: "dropbox",
  GDRIVE: "gdrive",
  GPHOTOS: "gphotos",
  INSTAGRAM: "instagram",
  FLICKR: "flickr",
  VK: "vk",
  EVERNOTE: "evernote",
  BOX: "box",
  ONEDRIVE: "onedrive",
  HUDDLE: "huddle"
});
UploaderBlock.sourceTypes = Object.freeze({
  LOCAL: "local",
  URL: "url",
  CAMERA: "camera",
  DRAW: "draw",
  ...UploaderBlock.extSrcList
});
Object.values(EVENT_TYPES).forEach((eType) => {
  let eName = EventManager.eName(eType);
  window.addEventListener(eName, (e) => {
    let outputTypes = [EVENT_TYPES.UPLOAD_FINISH, EVENT_TYPES.REMOVE, EVENT_TYPES.CDN_MODIFICATION];
    if (outputTypes.includes(e.detail.type)) {
      let dataCtx = Data.getCtx(e.detail.ctx);
      let uploadCollection = dataCtx.read("uploadCollection");
      let data = [];
      uploadCollection.items().forEach((id) => {
        let uploadEntryData = Data.getCtx(id).store;
        let fileInfo = uploadEntryData.fileInfo;
        if (fileInfo) {
          let outputItem = {
            ...fileInfo,
            cdnUrlModifiers: uploadEntryData.cdnUrlModifiers,
            cdnUrl: uploadEntryData.cdnUrl || fileInfo.cdnUrl
          };
          data.push(outputItem);
        }
      });
      EventManager.emit(
        new EventData({
          type: EVENT_TYPES.DATA_OUTPUT,
          ctx: e.detail.ctx,
          data
        })
      );
      dataCtx.pub("outputData", data);
    }
  });
});

// node_modules/@uploadcare/blocks/blocks/Icon/Icon.js
var Icon = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      name: "",
      path: "",
      size: "24",
      viewBox: ""
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("name", (val) => {
      if (!val) {
        return;
      }
      let path = this.getCssData(`--icon-${val}`);
      if (path) {
        this.$.path = path;
      }
    });
    this.sub("path", (path) => {
      if (!path) {
        return;
      }
      let isRaw = path.trimStart().startsWith("<");
      if (isRaw) {
        this.setAttribute("raw", "");
        this.ref.svg.innerHTML = path;
      } else {
        this.removeAttribute("raw");
        this.ref.svg.innerHTML = `<path fill-rule="evenodd" d="${path}"></path>`;
      }
    });
    this.sub("size", (size) => {
      this.$.viewBox = `0 0 ${size} ${size}`;
    });
  }
};
Icon.template = /* HTML */
`
  <svg ref="svg" xmlns="http://www.w3.org/2000/svg" set="@viewBox: viewBox; @height: size; @width: size"></svg>
`;
Icon.bindAttributes({
  name: "name",
  size: "size"
});

// node_modules/@uploadcare/blocks/utils/cdn-utils.js
var normalizeCdnOperation = (operation) => {
  if (typeof operation !== "string" || !operation) {
    return "";
  }
  let str = operation.trim();
  if (str.startsWith("-/")) {
    str = str.slice(2);
  } else if (str.startsWith("/")) {
    str = str.slice(1);
  }
  if (str.endsWith("/")) {
    str = str.slice(0, str.length - 1);
  }
  return str;
};
var joinCdnOperations = (...operations) => {
  return operations.filter((op) => typeof op === "string" && op).map((op) => normalizeCdnOperation(
    /** @type {String} */
    op
  )).join("/-/");
};
var createCdnUrlModifiers = (...cdnOperations) => {
  let joined = joinCdnOperations(...cdnOperations);
  return joined ? `-/${joined}/` : "";
};
function extractFilename(cdnUrl) {
  let url = new URL(cdnUrl);
  let noOrigin = url.pathname + url.search + url.hash;
  let urlFilenameIdx = noOrigin.lastIndexOf("http");
  let plainFilenameIdx = noOrigin.lastIndexOf("/");
  let filename = "";
  if (urlFilenameIdx >= 0) {
    filename = noOrigin.slice(urlFilenameIdx);
  } else if (plainFilenameIdx >= 0) {
    filename = noOrigin.slice(plainFilenameIdx + 1);
  }
  return filename;
}
function extractUuid(cdnUrl) {
  let url = new URL(cdnUrl);
  let { pathname } = url;
  const slashIndex = pathname.indexOf("/");
  const secondSlashIndex = pathname.indexOf("/", slashIndex + 1);
  return pathname.substring(slashIndex + 1, secondSlashIndex);
}
function extractOperations(cdnUrl) {
  let withoutFilename = trimFilename(cdnUrl);
  let url = new URL(withoutFilename);
  let operationsMarker = url.pathname.indexOf("/-/");
  if (operationsMarker === -1) {
    return [];
  }
  let operationsStr = url.pathname.substring(operationsMarker);
  return operationsStr.split("/-/").filter(Boolean).map((operation) => normalizeCdnOperation(operation));
}
function trimFilename(cdnUrl) {
  let url = new URL(cdnUrl);
  let filename = extractFilename(cdnUrl);
  let filenamePathPart = isFileUrl(filename) ? splitFileUrl(filename).pathname : filename;
  url.pathname = url.pathname.replace(filenamePathPart, "");
  url.search = "";
  url.hash = "";
  return url.toString();
}
function isFileUrl(filename) {
  return filename.startsWith("http");
}
function splitFileUrl(fileUrl) {
  let url = new URL(fileUrl);
  return {
    pathname: url.origin + url.pathname || "",
    search: url.search || "",
    hash: url.hash || ""
  };
}
var createCdnUrl = (baseCdnUrl, cdnModifiers, filename) => {
  let url = new URL(trimFilename(baseCdnUrl));
  filename = filename || extractFilename(baseCdnUrl);
  if (url.pathname.startsWith("//")) {
    url.pathname = url.pathname.replace("//", "/");
  }
  if (isFileUrl(filename)) {
    let splitted = splitFileUrl(filename);
    url.pathname = url.pathname + (cdnModifiers || "") + (splitted.pathname || "");
    url.search = splitted.search;
    url.hash = splitted.hash;
  } else {
    url.pathname = url.pathname + (cdnModifiers || "") + (filename || "");
  }
  return url.toString();
};
var createOriginalUrl = (cdnUrl, uuid) => {
  let url = new URL(cdnUrl);
  url.pathname = uuid + "/";
  return url.toString();
};

// node_modules/@uploadcare/blocks/blocks/Img/props-map.js
var DEFAULT_CDN_BASE = "https://ucarecdn.com";
var PROPS_MAP = Object.freeze({
  "dev-mode": {},
  pubkey: {},
  uuid: {},
  src: {},
  // alt: {},
  // 'placeholder-src': {}, // available via CSS
  lazy: {
    default: 1
  },
  intersection: {},
  breakpoints: {
    // '200, 300, 400'
  },
  "cdn-cname": {
    default: DEFAULT_CDN_BASE
  },
  "proxy-cname": {},
  "secure-delivery-proxy": {},
  "hi-res-support": {
    default: 1
  },
  "ultra-res-support": {},
  // ?
  format: {
    default: "auto"
  },
  "cdn-operations": {},
  progressive: {},
  quality: {
    default: "smart"
  },
  "is-background-for": {}
});

// node_modules/@uploadcare/blocks/utils/uniqueArray.js
var uniqueArray = (arr) => {
  return [...new Set(arr)];
};

// node_modules/@uploadcare/blocks/blocks/Img/ImgBase.js
var CSS_PREF = "--lr-img-";
var UNRESOLVED_ATTR = "unresolved";
var HI_RES_K = 2;
var ULTRA_RES_K = 3;
var DEV_MODE = !window.location.host.trim() || window.location.host.includes(":") || window.location.hostname.includes("localhost");
var CSS_PROPS = /* @__PURE__ */ Object.create(null);
var _a;
for (let prop in PROPS_MAP) {
  CSS_PROPS[CSS_PREF + prop] = ((_a = PROPS_MAP[prop]) == null ? void 0 : _a.default) || "";
}
var ImgBase = class extends BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "cssInit$", CSS_PROPS);
  }
  /**
   * @param {String} key
   * @returns {any}
   */
  $$(key) {
    return this.$[CSS_PREF + key];
  }
  /** @param {Object<String, String | Number>} kvObj */
  set$$(kvObj) {
    for (let key in kvObj) {
      this.$[CSS_PREF + key] = kvObj[key];
    }
  }
  /**
   * @param {String} key
   * @param {(val: any) => void} kbFn
   */
  sub$$(key, kbFn) {
    this.sub(CSS_PREF + key, (val) => {
      if (val === null || val === "") {
        return;
      }
      kbFn(val);
    });
  }
  /**
   * @private
   * @param {String} src
   */
  _fmtAbs(src) {
    let isRel = !src.includes("//");
    if (isRel && !DEV_MODE) {
      src = new URL(src, document.baseURI).href;
    }
    return src;
  }
  /**
   * Image operations
   *
   * @param {String} [size]
   */
  _getCdnModifiers(size = "") {
    return createCdnUrlModifiers(
      //
      size && `resize/${size}`,
      this.$$("cdn-operations") || "",
      `format/${this.$$("format") || PROPS_MAP.format.default}`,
      `quality/${this.$$("quality") || PROPS_MAP.quality.default}`
    );
  }
  /**
   * @private
   * @param {String} size
   * @returns {any}
   */
  _getUrlBase(size = "") {
    if (this.$$("src").startsWith("data:") || this.$$("src").startsWith("blob:")) {
      return this.$$("src");
    }
    if (DEV_MODE && this.$$("src") && !this.$$("src").includes("//")) {
      return this._proxyUrl(this.$$("src"));
    }
    let cdnModifiers = this._getCdnModifiers(size);
    if (this.$$("src").startsWith(this.$$("cdn-cname"))) {
      return createCdnUrl(this.$$("src"), cdnModifiers);
    }
    if (this.$$("cdn-cname") && this.$$("uuid")) {
      return this._proxyUrl(
        createCdnUrl(
          //
          createOriginalUrl(this.$$("cdn-cname"), this.$$("uuid")),
          cdnModifiers
        )
      );
    }
    if (this.$$("uuid")) {
      return this._proxyUrl(
        createCdnUrl(
          //
          createOriginalUrl(this.$$("cdn-cname"), this.$$("uuid")),
          cdnModifiers
        )
      );
    }
    if (this.$$("proxy-cname")) {
      return this._proxyUrl(
        createCdnUrl(
          //
          this.$$("proxy-cname"),
          cdnModifiers,
          this._fmtAbs(this.$$("src"))
        )
      );
    }
    if (this.$$("pubkey")) {
      return this._proxyUrl(
        createCdnUrl(
          //
          `https://${this.$$("pubkey")}.ucr.io/`,
          cdnModifiers,
          this._fmtAbs(this.$$("src"))
        )
      );
    }
  }
  /**
   * @private
   * @param {String} url
   * @returns {String}
   */
  _proxyUrl(url) {
    let previewProxy = this.$$("secure-delivery-proxy");
    if (!previewProxy) {
      return url;
    }
    return applyTemplateData(
      this.$$("secure-delivery-proxy"),
      { previewUrl: url },
      { transform: (value) => window.encodeURIComponent(value) }
    );
  }
  /**
   * @param {HTMLElement} el
   * @param {Number} [k]
   * @param {Boolean} [wOnly]
   */
  _getElSize(el, k = 1, wOnly = true) {
    let rect = el.getBoundingClientRect();
    let w = k * Math.round(rect.width);
    let h = wOnly ? "" : k * Math.round(rect.height);
    if (w || h) {
      return `${w ? w : ""}x${h ? h : ""}`;
    } else {
      return null;
    }
  }
  /** @param {HTMLImageElement} img */
  _setupEventProxy(img) {
    let proxifyEvent = (e) => {
      e.stopPropagation();
      let event = new Event(e.type, e);
      this.dispatchEvent(event);
    };
    let EVENTS = ["load", "error"];
    for (let event of EVENTS) {
      img.addEventListener(event, proxifyEvent);
    }
  }
  /** @type {HTMLImageElement} */
  get img() {
    if (!this._img) {
      this._img = new Image();
      this._setupEventProxy(this.img);
      this._img.setAttribute(UNRESOLVED_ATTR, "");
      this.img.onload = () => {
        this.img.removeAttribute(UNRESOLVED_ATTR);
      };
      this.initAttributes();
      this.appendChild(this._img);
    }
    return this._img;
  }
  get bgSelector() {
    return this.$$("is-background-for");
  }
  initAttributes() {
    [...this.attributes].forEach((attr) => {
      if (!PROPS_MAP[attr.name]) {
        this.img.setAttribute(attr.name, attr.value);
      }
    });
  }
  get breakpoints() {
    if (this.$$("breakpoints")) {
      return uniqueArray(stringToArray(this.$$("breakpoints")).map((str) => Number(str)));
    } else {
      return null;
    }
  }
  /** @param {HTMLElement} el */
  renderBg(el) {
    let imgSet = /* @__PURE__ */ new Set();
    if (this.breakpoints) {
      this.breakpoints.forEach((bp) => {
        imgSet.add(`url("${this._getUrlBase(bp + "x")}") ${bp}w`);
        if (this.$$("hi-res-support")) {
          imgSet.add(`url("${this._getUrlBase(bp * HI_RES_K + "x")}") ${bp * HI_RES_K}w`);
        }
        if (this.$$("ultra-res-support")) {
          imgSet.add(`url("${this._getUrlBase(bp * ULTRA_RES_K + "x")}") ${bp * ULTRA_RES_K}w`);
        }
      });
    } else {
      imgSet.add(`url("${this._getUrlBase(this._getElSize(el))}") 1x`);
      if (this.$$("hi-res-support")) {
        imgSet.add(`url("${this._getUrlBase(this._getElSize(el, HI_RES_K))}") ${HI_RES_K}x`);
      }
      if (this.$$("ultra-res-support")) {
        imgSet.add(`url("${this._getUrlBase(this._getElSize(el, ULTRA_RES_K))}") ${ULTRA_RES_K}x`);
      }
    }
    let iSet = `image-set(${[...imgSet].join(", ")})`;
    el.style.setProperty("background-image", iSet);
    el.style.setProperty("background-image", "-webkit-" + iSet);
  }
  getSrcset() {
    let srcset = /* @__PURE__ */ new Set();
    if (this.breakpoints) {
      this.breakpoints.forEach((bp) => {
        srcset.add(this._getUrlBase(bp + "x") + ` ${bp}w`);
        if (this.$$("hi-res-support")) {
          srcset.add(this._getUrlBase(bp * HI_RES_K + "x") + ` ${bp * HI_RES_K}w`);
        }
        if (this.$$("ultra-res-support")) {
          srcset.add(this._getUrlBase(bp * ULTRA_RES_K + "x") + ` ${bp * ULTRA_RES_K}w`);
        }
      });
    } else {
      srcset.add(this._getUrlBase(this._getElSize(this.img)) + " 1x");
      if (this.$$("hi-res-support")) {
        srcset.add(this._getUrlBase(this._getElSize(this.img, 2)) + " 2x");
      }
      if (this.$$("ultra-res-support")) {
        srcset.add(this._getUrlBase(this._getElSize(this.img, 3)) + " 3x");
      }
    }
    return [...srcset].join();
  }
  getSrc() {
    return this._getUrlBase();
  }
  init() {
    if (this.bgSelector) {
      [...document.querySelectorAll(this.bgSelector)].forEach((el) => {
        if (this.$$("intersection")) {
          this.initIntersection(el, () => {
            this.renderBg(el);
          });
        } else {
          this.renderBg(el);
        }
      });
    } else if (this.$$("intersection")) {
      this.initIntersection(this.img, () => {
        this.img.srcset = this.getSrcset();
        this.img.src = this.getSrc();
      });
    } else {
      this.img.srcset = this.getSrcset();
      this.img.src = this.getSrc();
    }
  }
  /**
   * @param {HTMLElement} el
   * @param {() => void} cbkFn
   */
  initIntersection(el, cbkFn) {
    let opts = {
      root: null,
      rootMargin: "0px"
    };
    this._isnObserver = new IntersectionObserver((entries) => {
      entries.forEach((ent) => {
        if (ent.isIntersecting) {
          cbkFn();
          this._isnObserver.unobserve(el);
        }
      });
    }, opts);
    this._isnObserver.observe(el);
    if (!this._observed) {
      this._observed = /* @__PURE__ */ new Set();
    }
    this._observed.add(el);
  }
  destroyCallback() {
    super.destroyCallback();
    if (this._isnObserver) {
      this._observed.forEach((el) => {
        this._isnObserver.unobserve(el);
      });
      this._isnObserver = null;
    }
  }
  static get observedAttributes() {
    return Object.keys(PROPS_MAP);
  }
  attributeChangedCallback(name, oldVal, newVal) {
    window.setTimeout(() => {
      this.$[CSS_PREF + name] = newVal;
    });
  }
};

// node_modules/@uploadcare/blocks/blocks/Img/Img.js
var Img = class extends ImgBase {
  initCallback() {
    super.initCallback();
    this.sub$$("src", () => {
      this.init();
    });
    this.sub$$("uuid", () => {
      this.init();
    });
    this.sub$$("lazy", (val) => {
      if (!this.$$("is-background-for")) {
        this.img.loading = val ? "lazy" : "eager";
      }
    });
  }
};

// node_modules/@uploadcare/blocks/blocks/SimpleBtn/SimpleBtn.js
var SimpleBtn = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      "*simpleButtonText": "",
      onClick: () => {
        this.initFlow();
      }
    });
  }
  initCallback() {
    super.initCallback();
    this.bindCssData("--cfg-multiple");
    this.sub("--cfg-multiple", (val) => {
      this.$["*simpleButtonText"] = val ? this.l10n("upload-files") : this.l10n("upload-file");
    });
  }
};
SimpleBtn.template = /* HTML */
`
  <lr-drop-area>
    <button type="button" set="onclick: onClick">
      <lr-icon name="upload"></lr-icon>
      <span>{{*simpleButtonText}}</span>
      <slot></slot>
      <div class="visual-drop-area"></div>
    </button>
  </lr-drop-area>
`;

// node_modules/@uploadcare/blocks/blocks/StartFrom/StartFrom.js
var StartFrom = class extends ActivityBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "historyTracked", true);
    __publicField(this, "activityType", "start-from");
  }
  initCallback() {
    super.initCallback();
    this.registerActivity(this.activityType);
  }
};

// node_modules/@uploadcare/blocks/blocks/DropArea/getDropItems.js
function checkIsDirectory(file) {
  return new Promise((resolve) => {
    if (typeof window.FileReader !== "function") {
      resolve(false);
    }
    try {
      let reader = new FileReader();
      reader.onerror = () => {
        resolve(true);
      };
      let onLoad = (e) => {
        if (e.type !== "loadend") {
          reader.abort();
        }
        resolve(false);
      };
      reader.onloadend = onLoad;
      reader.onprogress = onLoad;
      reader.readAsDataURL(file);
    } catch (err) {
      resolve(false);
    }
  });
}
function readEntryContentAsync(webkitEntry) {
  return new Promise((resolve) => {
    let reading = 0;
    let contents = [];
    let readEntry = (entry) => {
      if (!entry) {
        console.warn("Unexpectedly received empty content entry", { scope: "drag-and-drop" });
        resolve(null);
      }
      if (entry.isFile) {
        reading++;
        entry.file((file) => {
          reading--;
          contents.push(file);
          if (reading === 0) {
            resolve(contents);
          }
        });
      } else if (entry.isDirectory) {
        readReaderContent(entry.createReader());
      }
    };
    let readReaderContent = (reader) => {
      reading++;
      reader.readEntries((entries) => {
        reading--;
        for (let entry of entries) {
          readEntry(entry);
        }
        if (reading === 0) {
          resolve(contents);
        }
      });
    };
    readEntry(webkitEntry);
  });
}
function getDropItems(dataTransfer) {
  let files = [];
  let promises = [];
  for (let i = 0; i < dataTransfer.items.length; i++) {
    let item = dataTransfer.items[i];
    if (!item) {
      continue;
    }
    if (item.kind === "file") {
      if (typeof item.webkitGetAsEntry === "function" || typeof /** @type {any} */
      item.getAsEntry === "function") {
        let entry = typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : (
          /** @type {any} */
          item.getAsEntry()
        );
        promises.push(
          readEntryContentAsync(entry).then((entryContent) => {
            files.push(...entryContent);
          })
        );
        continue;
      }
      let file = item.getAsFile();
      promises.push(
        checkIsDirectory(file).then((isDirectory) => {
          if (isDirectory) {
          } else {
            files.push(file);
          }
        })
      );
    } else if (item.kind === "string" && item.type.match("^text/uri-list")) {
      promises.push(
        new Promise((resolve) => {
          item.getAsString((value) => {
            files.push(value);
            resolve();
          });
        })
      );
    }
  }
  return Promise.all(promises).then(() => files);
}

// node_modules/@uploadcare/blocks/blocks/DropArea/addDropzone.js
var DropzoneState = {
  ACTIVE: 0,
  INACTIVE: 1,
  NEAR: 2,
  OVER: 3
};
var RESET_EVENTS = ["focus"];
var NEAR_OFFSET = 100;
var nearnessRegistry = /* @__PURE__ */ new Map();
function distance(p, r) {
  let cx = Math.max(Math.min(p[0], r.x + r.width), r.x);
  let cy = Math.max(Math.min(p[1], r.y + r.height), r.y);
  return Math.sqrt((p[0] - cx) * (p[0] - cx) + (p[1] - cy) * (p[1] - cy));
}
function addDropzone(desc) {
  let eventCounter = 0;
  let body = document.body;
  let switchHandlers = /* @__PURE__ */ new Set();
  let handleSwitch = (fn) => switchHandlers.add(fn);
  let state = DropzoneState.INACTIVE;
  let setState = (newState) => {
    if (desc.shouldIgnore() && newState !== DropzoneState.INACTIVE) {
      return;
    }
    if (state !== newState) {
      switchHandlers.forEach((fn) => fn(newState));
    }
    state = newState;
  };
  handleSwitch((newState) => desc.onChange(newState));
  let onResetEvent = () => {
    eventCounter = 0;
    setState(DropzoneState.INACTIVE);
  };
  let onDragEnter = () => {
    eventCounter += 1;
    if (state === DropzoneState.INACTIVE) {
      setState(DropzoneState.ACTIVE);
    }
  };
  let onDragLeave = () => {
    eventCounter -= 1;
    let draggingInPage = eventCounter > 0;
    if (!draggingInPage) {
      setState(DropzoneState.INACTIVE);
    }
  };
  let onDrop = (e) => {
    e.preventDefault();
    eventCounter = 0;
    setState(DropzoneState.INACTIVE);
  };
  let onDragOver = (e) => {
    e.preventDefault();
    let dragPoint = [e.x, e.y];
    let targetRect = desc.element.getBoundingClientRect();
    let nearness = Math.floor(distance(dragPoint, targetRect));
    let isNear = nearness < NEAR_OFFSET;
    let isOver = e.composedPath().includes(desc.element);
    nearnessRegistry.set(desc.element, nearness);
    let isNearest = Math.min(...nearnessRegistry.values()) === nearness;
    if (isOver && isNearest) {
      setState(DropzoneState.OVER);
    } else if (isNear && isNearest) {
      setState(DropzoneState.NEAR);
    } else {
      setState(DropzoneState.ACTIVE);
    }
  };
  let onElementDrop = async (e) => {
    if (desc.shouldIgnore()) {
      return;
    }
    e.preventDefault();
    let items = await getDropItems(e.dataTransfer);
    desc.onItems(items);
    setState(DropzoneState.INACTIVE);
  };
  body.addEventListener("drop", onDrop);
  body.addEventListener("dragleave", onDragLeave);
  body.addEventListener("dragenter", onDragEnter);
  body.addEventListener("dragover", onDragOver);
  desc.element.addEventListener("drop", onElementDrop);
  RESET_EVENTS.forEach((eventName) => {
    window.addEventListener(eventName, onResetEvent);
  });
  return () => {
    nearnessRegistry.delete(desc.element);
    body.removeEventListener("drop", onDrop);
    body.removeEventListener("dragleave", onDragLeave);
    body.removeEventListener("dragenter", onDragEnter);
    body.removeEventListener("dragover", onDragOver);
    desc.element.removeEventListener("drop", onElementDrop);
    RESET_EVENTS.forEach((eventName) => {
      window.removeEventListener(eventName, onResetEvent);
    });
  };
}

// node_modules/@uploadcare/blocks/blocks/DropArea/DropArea.js
var DropArea = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      state: DropzoneState.INACTIVE,
      withIcon: false,
      isClickable: false,
      isFullscreen: false,
      isDisabled: false,
      isHidden: false,
      text: this.l10n("drop-files-here"),
      "lr-drop-area/targets": null
    });
    __publicField(this, "cssInit$", {
      "--cfg-source-list": ""
    });
  }
  isActive() {
    if (!this.$.isDisabled) {
      return false;
    }
    const bounds = this.getBoundingClientRect();
    const hasSize = bounds.width > 0 && bounds.height > 0;
    const isInViewport = bounds.top >= 0 && bounds.left >= 0 && bounds.bottom <= (window.innerHeight || document.documentElement.clientHeight) && bounds.right <= (window.innerWidth || document.documentElement.clientWidth);
    const style = window.getComputedStyle(this);
    const visible = style.visibility !== "hidden" && style.display !== "none";
    return hasSize && visible && isInViewport;
  }
  initCallback() {
    super.initCallback();
    if (!this.$["lr-drop-area/targets"]) {
      this.$["lr-drop-area/targets"] = /* @__PURE__ */ new Set();
    }
    this.$["lr-drop-area/targets"].add(this);
    this.defineAccessor("disabled", (value) => {
      this.set$({ isDisabled: typeof value === "string" });
    });
    this.defineAccessor("clickable", (value) => {
      this.set$({ isClickable: typeof value === "string" });
    });
    this.defineAccessor("with-icon", (value) => {
      this.set$({ withIcon: typeof value === "string" });
    });
    this.defineAccessor("fullscreen", (value) => {
      this.set$({ isFullscreen: typeof value === "string" });
    });
    this.defineAccessor("text", (value) => {
      if (value) {
        this.set$({ text: this.l10n(value) || value });
      } else {
        this.set$({ text: this.l10n("drop-files-here") });
      }
    });
    this._destroyDropzone = addDropzone({
      element: this,
      shouldIgnore: () => this._shouldIgnore(),
      onChange: (state) => {
        this.$.state = state;
      },
      /** @param {(File | String)[]} items */
      onItems: (items) => {
        debugger;
        if (!items.length) {
          return;
        }
        let isMultiple = this.getCssData("--cfg-multiple");
        let multipleMax = this.getCssData("--cfg-multiple-max");
        let currentFilesCount = this.uploadCollection.size;
        if (isMultiple && multipleMax) {
          items = items.slice(0, multipleMax - currentFilesCount - 1);
        } else if (!isMultiple) {
          items = items.slice(0, currentFilesCount > 0 ? 0 : 1);
        }
        items.forEach((item) => {
          if (typeof item === "string") {
            this.uploadCollection.add({
              externalUrl: item
            });
            return;
          }
          let isImage = fileIsImage(item);
          this.uploadCollection.add({
            file: item,
            isImage,
            mimeType: item.type,
            fileName: item.name,
            fileSize: item.size
          });
        });
        if (this.uploadCollection.size) {
          this.set$({
            "*currentActivity": ActivityBlock.activities.UPLOAD_LIST
          });
          this.setForCtxTarget(Modal.StateConsumerScope, "*modalActive", true);
        }
      }
    });
    let contentWrapperEl = this.ref["content-wrapper"];
    if (contentWrapperEl) {
      this._destroyContentWrapperDropzone = addDropzone({
        element: contentWrapperEl,
        onChange: (state) => {
          var _a2;
          const stateText = (_a2 = Object.entries(DropzoneState).find(([, value]) => value === state)) == null ? void 0 : _a2[0].toLowerCase();
          stateText && contentWrapperEl.setAttribute("drag-state", stateText);
        },
        onItems: () => {
        },
        shouldIgnore: () => this._shouldIgnore()
      });
    }
    this.sub("state", (state) => {
      var _a2;
      const stateText = (_a2 = Object.entries(DropzoneState).find(([, value]) => value === state)) == null ? void 0 : _a2[0].toLowerCase();
      if (stateText) {
        this.setAttribute("drag-state", stateText);
      }
    });
    this.sub("--cfg-source-list", (value) => {
      const list = stringToArray(value);
      this.$.isDisabled = !list.includes(UploaderBlock.sourceTypes.LOCAL);
      this.$.isHidden = this.$.isDisabled && !!this.querySelector("[data-default-slot]");
    });
    this.sub("isHidden", (value) => {
      this.toggleAttribute("hidden", value);
    });
    if (this.$.isClickable) {
      this._onAreaClicked = () => {
        this.openSystemDialog();
      };
      this.addEventListener("click", this._onAreaClicked);
    }
  }
  /**
   * Ignore drop events if there are other visible drop areas on the page
   *
   * @private
   * @returns {Boolean}
   */
  _shouldIgnore() {
    if (this.$.isDisabled) {
      return true;
    }
    if (!this._couldHandleFiles()) {
      return true;
    }
    if (!this.$.isFullscreen) {
      return false;
    }
    const otherTargets = [...this.$["lr-drop-area/targets"]].filter((el) => el !== this);
    const activeTargets = otherTargets.filter((el) => {
      return el.isActive();
    });
    return activeTargets.length > 0;
  }
  /** @private */
  _couldHandleFiles() {
    let isMultiple = this.getCssData("--cfg-multiple");
    let multipleMax = this.getCssData("--cfg-multiple-max");
    let currentFilesCount = this.uploadCollection.size;
    if (isMultiple && multipleMax && currentFilesCount >= multipleMax) {
      return false;
    }
    if (!isMultiple && currentFilesCount > 0) {
      return false;
    }
    return true;
  }
  destroyCallback() {
    var _a2, _b, _c, _d;
    super.destroyCallback();
    (_b = (_a2 = this.$["lr-drop-area/targets"]) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, this);
    (_c = this._destroyDropzone) == null ? void 0 : _c.call(this);
    (_d = this._destroyContentWrapperDropzone) == null ? void 0 : _d.call(this);
    if (this._onAreaClicked) {
      this.removeEventListener("click", this._onAreaClicked);
    }
  }
};
DropArea.template = /* HTML */
`
  <slot>
    <div data-default-slot hidden></div>
    <div ref="content-wrapper" class="content-wrapper" set="@hidden: isHidden">
      <div class="icon-container" set="@hidden: !withIcon">
        <lr-icon name="default"></lr-icon>
        <lr-icon name="arrow-down"></lr-icon>
      </div>
      <span class="text">{{text}}</span>
    </div>
  </slot>
`;
DropArea.bindAttributes({
  "with-icon": null,
  clickable: null,
  text: null,
  fullscreen: null,
  disabled: null
});

// node_modules/@uploadcare/blocks/blocks/SourceBtn/SourceBtn.js
var L10N_PREFIX = "src-type-";
var SourceBtn = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    /** @private */
    __publicField(this, "_registeredTypes", {});
    __publicField(this, "init$", {
      ...this.ctxInit,
      iconName: "default"
    });
  }
  initTypes() {
    this.registerType({
      type: UploaderBlock.sourceTypes.LOCAL,
      onClick: () => {
        this.openSystemDialog();
      }
    });
    this.registerType({
      type: UploaderBlock.sourceTypes.URL,
      activity: ActivityBlock.activities.URL,
      textKey: "from-url"
    });
    this.registerType({
      type: UploaderBlock.sourceTypes.CAMERA,
      activity: ActivityBlock.activities.CAMERA,
      onClick: () => {
        let el = document.createElement("input");
        var supportsCapture = el.capture !== void 0;
        if (supportsCapture) {
          this.openSystemDialog({ captureCamera: true });
        }
        return !supportsCapture;
      }
    });
    this.registerType({
      type: "draw",
      activity: ActivityBlock.activities.DRAW,
      icon: "edit-draw"
    });
    for (let externalSourceType of Object.values(UploaderBlock.extSrcList)) {
      this.registerType({
        type: externalSourceType,
        activity: ActivityBlock.activities.EXTERNAL,
        activityParams: {
          externalSourceType
        }
      });
    }
  }
  initCallback() {
    super.initCallback();
    this.initTypes();
    this.setAttribute("role", "button");
    this.defineAccessor("type", (val) => {
      if (!val) {
        return;
      }
      this.applyType(val);
    });
  }
  registerType(typeConfig) {
    this._registeredTypes[typeConfig.type] = typeConfig;
  }
  getType(type) {
    return this._registeredTypes[type];
  }
  applyType(type) {
    const configType = this._registeredTypes[type];
    if (!configType) {
      console.warn("Unsupported source type: " + type);
      return;
    }
    const { textKey = type, icon = type, activity, onClick, activityParams = {} } = configType;
    this.applyL10nKey("src-type", `${L10N_PREFIX}${textKey}`);
    this.$.iconName = icon;
    this.onclick = (e) => {
      const showActivity = onClick ? onClick(e) : !!activity;
      showActivity && this.set$({
        "*currentActivityParams": activityParams,
        "*currentActivity": activity
      });
    };
  }
};
SourceBtn.template = /* HTML */
`
  <lr-icon set="@name: iconName"></lr-icon>
  <div class="txt" l10n="src-type"></div>
`;
SourceBtn.bindAttributes({
  type: null
});

// node_modules/@uploadcare/blocks/blocks/SourceList/SourceList.js
var SourceList = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "cssInit$", {
      "--cfg-source-list": ""
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("--cfg-source-list", (val) => {
      let list = stringToArray(val);
      let html = "";
      list.forEach((srcName) => {
        html += /* HTML */
        `<lr-source-btn type="${srcName}"></lr-source-btn>`;
      });
      if (this.getCssData("--cfg-source-list-wrap")) {
        this.innerHTML = html;
      } else {
        this.outerHTML = html;
      }
    });
  }
};

// node_modules/@uploadcare/blocks/blocks/utils/resizeImage.js
function generateThumb(imgFile, size = 40) {
  if (imgFile.type === "image/svg+xml") {
    return URL.createObjectURL(imgFile);
  }
  let canvas = document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  let img = new Image();
  let promise = new Promise((resolve, reject) => {
    img.onload = () => {
      let ratio = img.height / img.width;
      if (ratio > 1) {
        canvas.width = size;
        canvas.height = size * ratio;
      } else {
        canvas.height = size;
        canvas.width = size / ratio;
      }
      ctx.fillStyle = "rgb(240, 240, 240)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      canvas.toBlob((blob) => {
        if (!blob) {
          reject();
          return;
        }
        let url = URL.createObjectURL(blob);
        resolve(url);
      });
    };
    img.onerror = (err) => {
      reject(err);
    };
  });
  img.src = URL.createObjectURL(imgFile);
  return promise;
}

// node_modules/@uploadcare/blocks/blocks/MessageBox/MessageBox.js
var UiMessage = class {
  constructor() {
    __publicField(this, "caption", "");
    __publicField(this, "text", "");
    __publicField(this, "iconName", "");
    __publicField(this, "isError", false);
  }
};
var MessageBox = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      iconName: "info",
      captionTxt: "Message caption",
      msgTxt: "Message...",
      "*message": null,
      onClose: () => {
        this.$["*message"] = null;
      }
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("*message", (msg) => {
      if (msg) {
        this.setAttribute("active", "");
        this.set$({
          captionTxt: msg.caption || "",
          msgTxt: msg.text || "",
          iconName: msg.isError ? "error" : "info"
        });
        if (msg.isError) {
          this.setAttribute("error", "");
        } else {
          this.removeAttribute("error");
        }
      } else {
        this.removeAttribute("active");
      }
    });
  }
};
MessageBox.template = /* HTML */
`
  <div class="heading">
    <lr-icon set="@name: iconName"></lr-icon>
    <div class="caption">{{captionTxt}}</div>
    <button type="button" set="onclick: onClose">
      <lr-icon name="close"></lr-icon>
    </button>
  </div>
  <div class="msg">{{msgTxt}}</div>
`;

// node_modules/@uploadcare/blocks/blocks/svg-backgrounds/svg-backgrounds.js
function createSvgBlobUrl(svg) {
  let blob = new Blob([svg], {
    type: "image/svg+xml"
  });
  return URL.createObjectURL(blob);
}
function checkerboardCssBg(color1 = "#fff", color2 = "rgba(0, 0, 0, .1)") {
  return createSvgBlobUrl(
    /*svg*/
    `<svg height="20" width="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
    <rect x="0" y="0" width="20" height="20" fill="${color1}" />
    <rect x="0" y="0" width="10" height="10" fill="${color2}" />
    <rect x="10" y="10" width="10" height="10" fill="${color2}" />
  </svg>`
  );
}
function fileCssBg(color = "hsl(209, 21%, 65%)", width = 32, height = 32) {
  return createSvgBlobUrl(
    /*svg*/
    `
  <svg width="${width}" height="${height}" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" fill="${color}" d="M9.68848 8.70068C9.68848 8.42454 9.91233 8.20068 10.1885 8.20068H15.0885C15.2211 8.20068 15.3483 8.25336 15.442 8.34713L20.342 13.2471C20.4358 13.3409 20.4885 13.4681 20.4885 13.6007V21.3007C20.4885 21.5768 20.2646 21.8007 19.9885 21.8007H10.1885C9.91233 21.8007 9.68848 21.5768 9.68848 21.3007V8.70068ZM10.6885 9.20068V20.8007H19.4885V14.1007L15.0885 14.1007C14.8123 14.1007 14.5885 13.8768 14.5885 13.6007L14.5885 9.20068H10.6885ZM15.5885 9.90779L18.7814 13.1007L15.5885 13.1007L15.5885 9.90779Z"/>
  </svg>
  `
  );
}

// node_modules/@uploadcare/blocks/blocks/FileItem/FileItem.js
var FileItemState = Object.freeze({
  FINISHED: Symbol(0),
  FAILED: Symbol(1),
  UPLOADING: Symbol(2),
  IDLE: Symbol(3)
});
var FileItem = class _FileItem extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "pauseRender", true);
    /** @private */
    __publicField(this, "_entrySubs", /* @__PURE__ */ new Set());
    /** @private */
    __publicField(this, "_entry", null);
    /** @private */
    __publicField(this, "_isIntersecting", false);
    /** @private */
    __publicField(this, "_debouncedGenerateThumb", debounce(this._generateThumbnail.bind(this), 100));
    /** @private */
    __publicField(this, "_debouncedCalculateState", debounce(this._calculateState.bind(this), 100));
    // TODO: better throttle
    /** @private */
    __publicField(this, "_renderedOnce", false);
    __publicField(this, "cssInit$", {
      "--cfg-use-cloud-image-editor": 0
    });
    __publicField(this, "init$", {
      ...this.ctxInit,
      uid: "",
      itemName: "",
      errorText: "",
      thumbUrl: "",
      progressValue: 0,
      progressVisible: false,
      progressUnknown: false,
      badgeIcon: "",
      isFinished: false,
      isFailed: false,
      isUploading: false,
      isFocused: false,
      isEditable: false,
      state: FileItemState.IDLE,
      "*uploadTrigger": null,
      onEdit: () => {
        this.set$({
          "*focusedEntry": this._entry
        });
        if (this.findBlockInCtx((b) => b.activityType === ActivityBlock.activities.DETAILS)) {
          this.$["*currentActivity"] = ActivityBlock.activities.DETAILS;
        } else {
          this.$["*currentActivity"] = ActivityBlock.activities.CLOUD_IMG_EDIT;
        }
      },
      onRemove: () => {
        let entryUuid = this._entry.getValue("uuid");
        if (entryUuid) {
          let data = this.getOutputData((dataItem) => {
            return dataItem.getValue("uuid") === entryUuid;
          });
          EventManager.emit(
            new EventData({
              type: EVENT_TYPES.REMOVE,
              ctx: this.ctxName,
              data
            })
          );
        }
        this.uploadCollection.remove(this.$.uid);
      },
      onUpload: () => {
        this.upload();
      }
    });
  }
  _reset() {
    for (let sub of this._entrySubs) {
      sub.remove();
    }
    this._debouncedGenerateThumb.cancel();
    this._entrySubs = /* @__PURE__ */ new Set();
    this._entry = null;
    this._isIntersecting = false;
  }
  /** @private */
  _observerCallback(entries) {
    let [entry] = entries;
    this._isIntersecting = entry.isIntersecting;
    if (entry.isIntersecting && !this._renderedOnce) {
      this.render();
      this._renderedOnce = true;
    }
    if (entry.intersectionRatio === 0) {
      this._debouncedGenerateThumb.cancel();
    } else {
      this._debouncedGenerateThumb();
    }
  }
  /** @private */
  _calculateState() {
    if (!this._entry) {
      return;
    }
    let entry = this._entry;
    let state = FileItemState.IDLE;
    if (entry.getValue("uploadError") || entry.getValue("validationErrorMsg")) {
      state = FileItemState.FAILED;
    } else if (entry.getValue("isUploading")) {
      state = FileItemState.UPLOADING;
    } else if (entry.getValue("uuid")) {
      state = FileItemState.FINISHED;
    }
    if (this.$.state !== state) {
      this.$.state = state;
    }
  }
  /** @private */
  async _generateThumbnail() {
    var _a2;
    if (!this._entry) {
      return;
    }
    let entry = this._entry;
    if (entry.getValue("uuid") && entry.getValue("isImage")) {
      let size = this.getCssData("--cfg-thumb-size") || 76;
      let thumbUrl = this.proxyUrl(
        createCdnUrl(
          createOriginalUrl(this.getCssData("--cfg-cdn-cname"), this._entry.getValue("uuid")),
          createCdnUrlModifiers(entry.getValue("cdnUrlModifiers"), `scale_crop/${size}x${size}/center`)
        )
      );
      let currentThumbUrl = entry.getValue("thumbUrl");
      if (currentThumbUrl !== thumbUrl) {
        entry.setValue("thumbUrl", thumbUrl);
        currentThumbUrl.startsWith("blob:") && URL.revokeObjectURL(currentThumbUrl);
      }
      return;
    }
    if (entry.getValue("thumbUrl")) {
      return;
    }
    if ((_a2 = entry.getValue("file")) == null ? void 0 : _a2.type.includes("image")) {
      try {
        let thumbUrl = await generateThumb(entry.getValue("file"), this.getCssData("--cfg-thumb-size") || 76);
        entry.setValue("thumbUrl", thumbUrl);
      } catch (err) {
        let color = window.getComputedStyle(this).getPropertyValue("--clr-generic-file-icon");
        entry.setValue("thumbUrl", fileCssBg(color));
      }
    } else {
      let color = window.getComputedStyle(this).getPropertyValue("--clr-generic-file-icon");
      entry.setValue("thumbUrl", fileCssBg(color));
    }
  }
  /**
   * @private
   * @param {'success' | 'error'} type
   * @param {String} caption
   * @param {String} text
   */
  _showMessage(type, caption, text) {
    let msg = new UiMessage();
    msg.caption = caption;
    msg.text = text;
    msg.isError = type === "error";
    this.set$({
      badgeIcon: `badge-${type}`,
      "*message": msg
    });
  }
  /**
   * @private
   * @param {string} prop
   * @param {(value: any) => void} handler
   */
  _subEntry(prop, handler) {
    let sub = this._entry.subscribe(prop, (value) => {
      if (this.isConnected) {
        handler(value);
      }
    });
    this._entrySubs.add(sub);
  }
  /**
   * @private
   * @param {String} id
   */
  _handleEntryId(id) {
    var _a2;
    this._reset();
    let entry = (_a2 = this.uploadCollection) == null ? void 0 : _a2.read(id);
    this._entry = entry;
    if (!entry) {
      return;
    }
    this._subEntry("validationErrorMsg", (validationErrorMsg) => {
      this._debouncedCalculateState();
      this.$.errorText = validationErrorMsg;
    });
    this._subEntry("uploadError", (uploadError) => {
      this._debouncedCalculateState();
      this.$.errorText = uploadError == null ? void 0 : uploadError.message;
    });
    this._subEntry("isUploading", () => {
      this._debouncedCalculateState();
    });
    this._subEntry("uploadProgress", (uploadProgress) => {
      this.$.progressValue = uploadProgress;
    });
    this._subEntry("fileName", (name) => {
      this.$.itemName = name || entry.getValue("externalUrl") || this.l10n("file-no-name");
    });
    this._subEntry("fileSize", (fileSize) => {
      let maxFileSize = this.getCssData("--cfg-max-local-file-size-bytes");
      if (maxFileSize && fileSize && fileSize > maxFileSize) {
        entry.setValue("validationErrorMsg", this.l10n("files-max-size-limit-error", { maxFileSize }));
      }
    });
    this._subEntry("mimeType", (mimeType) => {
      if (!mimeType) {
        return;
      }
      let imagesOnly = this.getCssData("--cfg-img-only");
      let accept = this.getCssData("--cfg-accept");
      let allowedFileTypes = mergeFileTypes([...imagesOnly ? IMAGE_ACCEPT_LIST : [], accept]);
      if (allowedFileTypes.length > 0 && !matchFileType(mimeType, allowedFileTypes)) {
        entry.setValue("validationErrorMsg", this.l10n("file-type-not-allowed"));
      }
    });
    this._subEntry("isImage", (isImage) => {
      let imagesOnly = this.getCssData("--cfg-img-only");
      if (entry.getValue("externalUrl") && !entry.getValue("uuid") && imagesOnly && !isImage) {
        return;
      }
      if (imagesOnly && !isImage) {
        entry.setValue("validationErrorMsg", this.l10n("images-only-accepted"));
      }
    });
    this._subEntry("externalUrl", (externalUrl) => {
      this.$.itemName = entry.getValue("fileName") || externalUrl || this.l10n("file-no-name");
    });
    this._subEntry("uuid", (uuid) => {
      this._debouncedCalculateState();
      if (uuid && this._isIntersecting) {
        this._debouncedGenerateThumb();
      }
    });
    this._subEntry("cdnUrlModifiers", () => {
      if (this._isIntersecting) {
        this._debouncedGenerateThumb();
      }
    });
    this._subEntry("thumbUrl", (thumbUrl) => {
      this.$.thumbUrl = thumbUrl ? `url(${thumbUrl})` : "";
    });
    if (!this.getCssData("--cfg-confirm-upload")) {
      this.upload();
    }
    if (this._isIntersecting) {
      this._debouncedGenerateThumb();
    }
  }
  initCallback() {
    super.initCallback();
    this.sub("uid", (uid) => {
      this._handleEntryId(uid);
    });
    this.sub("state", (state) => {
      this._handleState(state);
    });
    this.sub("--cfg-use-cloud-image-editor", () => {
      this._handleState(this.$.state);
    });
    this.onclick = () => {
      _FileItem.activeInstances.forEach((inst) => {
        if (inst === this) {
          inst.setAttribute("focused", "");
        } else {
          inst.removeAttribute("focused");
        }
      });
    };
    this.$["*uploadTrigger"] = null;
    this.sub("*uploadTrigger", (val) => {
      if (!val || !this.isConnected) {
        return;
      }
      this.upload();
    });
    _FileItem.activeInstances.add(this);
  }
  /** @param {(typeof FileItemState)[keyof typeof FileItemState]} state */
  _handleState(state) {
    var _a2;
    this.set$({
      isFailed: state === FileItemState.FAILED,
      isUploading: state === FileItemState.UPLOADING,
      isFinished: state === FileItemState.FINISHED,
      progressVisible: state === FileItemState.UPLOADING,
      isEditable: this.$["--cfg-use-cloud-image-editor"] && state === FileItemState.FINISHED && ((_a2 = this._entry) == null ? void 0 : _a2.getValue("isImage"))
    });
    if (state === FileItemState.FAILED) {
      this.$.badgeIcon = "badge-error";
    } else if (state === FileItemState.FINISHED) {
      this.$.badgeIcon = "badge-success";
    }
    if (state === FileItemState.UPLOADING) {
      this.$.isFocused = false;
    } else {
      this.$.progressValue = 0;
    }
  }
  destroyCallback() {
    super.destroyCallback();
    _FileItem.activeInstances.delete(this);
    this._reset();
  }
  connectedCallback() {
    super.connectedCallback();
    this._observer = new window.IntersectionObserver(this._observerCallback.bind(this), {
      root: this.parentElement,
      rootMargin: "50% 0px 50% 0px",
      threshold: [0, 1]
    });
    this._observer.observe(this);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    this._debouncedGenerateThumb.cancel();
    (_a2 = this._observer) == null ? void 0 : _a2.disconnect();
  }
  async upload() {
    let entry = this._entry;
    if (entry.getValue("uuid") || entry.getValue("isUploading") || entry.getValue("validationErrorMsg")) {
      return;
    }
    let data = this.getOutputData((dataItem) => {
      return !dataItem.getValue("uuid");
    });
    EventManager.emit(
      new EventData({
        type: EVENT_TYPES.UPLOAD_START,
        ctx: this.ctxName,
        data
      })
    );
    this._debouncedCalculateState();
    entry.setValue("isUploading", true);
    entry.setValue("uploadError", null);
    entry.setValue("validationErrorMsg", null);
    if (!entry.getValue("file") && entry.getValue("externalUrl")) {
      this.$.progressUnknown = true;
    }
    try {
      let abortController = new AbortController();
      entry.setValue("abortController", abortController);
      let fileInfo = await uploadFile(entry.getValue("file") || entry.getValue("externalUrl"), {
        ...this.getUploadClientOptions(),
        fileName: entry.getValue("fileName"),
        onProgress: (progress) => {
          if (progress.isComputable) {
            let percentage = progress.value * 100;
            entry.setValue("uploadProgress", percentage);
          }
          this.$.progressUnknown = !progress.isComputable;
        },
        signal: abortController.signal
      });
      entry.setMultipleValues({
        fileInfo,
        isUploading: false,
        fileName: fileInfo.name,
        fileSize: fileInfo.size,
        isImage: fileInfo.isImage,
        mimeType: fileInfo.mimeType,
        uuid: fileInfo.uuid,
        cdnUrl: fileInfo.cdnUrl
      });
      if (entry === this._entry) {
        this._debouncedCalculateState();
      }
    } catch (error) {
      entry.setMultipleValues({
        abortController: null,
        isUploading: false,
        uploadProgress: 0
      });
      if (entry === this._entry) {
        this._debouncedCalculateState();
      }
      if (!(error == null ? void 0 : error.isCancel)) {
        entry.setValue("uploadError", error);
      }
    }
  }
};
FileItem.template = /* HTML */
`
  <div class="inner" set="@finished: isFinished; @uploading: isUploading; @failed: isFailed; @focused: isFocused">
    <div class="thumb" set="style.backgroundImage: thumbUrl">
      <div class="badge">
        <lr-icon set="@name: badgeIcon"></lr-icon>
      </div>
    </div>
    <div class="file-name-wrapper">
      <span class="file-name" set="@title: itemName">{{itemName}}</span>
      <span class="file-error" set="@hidden: !errorText">{{errorText}}</span>
    </div>
    <div class="file-actions">
      <button type="button" class="edit-btn mini-btn" set="onclick: onEdit; @hidden: !isEditable">
        <lr-icon name="edit-file"></lr-icon>
      </button>
      <button type="button" class="remove-btn mini-btn" set="onclick: onRemove;">
        <lr-icon name="remove-file"></lr-icon>
      </button>
      <button type="button" class="upload-btn mini-btn" set="onclick: onUpload;">
        <lr-icon name="upload"></lr-icon>
      </button>
    </div>
    <lr-progress-bar
      class="progress-bar"
      set="value: progressValue; visible: progressVisible; unknown: progressUnknown"
    >
    </lr-progress-bar>
  </div>
`;
FileItem.activeInstances = /* @__PURE__ */ new Set();

// node_modules/@uploadcare/blocks/blocks/UploadList/UploadList.js
var UploadList = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "historyTracked", true);
    __publicField(this, "activityType", ActivityBlock.activities.UPLOAD_LIST);
    __publicField(this, "init$", {
      ...this.ctxInit,
      doneBtnVisible: false,
      doneBtnEnabled: false,
      uploadBtnVisible: false,
      addMoreBtnVisible: false,
      addMoreBtnEnabled: false,
      headerText: "",
      hasFiles: false,
      onAdd: () => {
        this.initFlow(true);
      },
      onUpload: () => {
        this.$["*uploadTrigger"] = {};
        this._updateUploadsState();
      },
      onDone: () => {
        this.doneFlow();
      },
      onCancel: () => {
        let data = this.getOutputData((dataItem) => {
          return !!dataItem.getValue("uuid");
        });
        EventManager.emit(
          new EventData({
            type: EVENT_TYPES.REMOVE,
            ctx: this.ctxName,
            data
          })
        );
        this.uploadCollection.clearAll();
      }
    });
    __publicField(this, "cssInit$", {
      "--cfg-multiple": 1,
      "--cfg-multiple-min": 0,
      "--cfg-multiple-max": 0
    });
    __publicField(this, "_debouncedHandleCollectionUpdate", debounce(() => {
      if (!this.isConnected) {
        return;
      }
      this._updateUploadsState();
      this._updateCountLimitMessage();
    }, 0));
  }
  /**
   * @private
   * @returns {{ passed: Boolean; tooFew: Boolean; tooMany: Boolean; exact: Boolean; min: Number; max: Number }}
   */
  _validateFilesCount() {
    let multiple = !!this.getCssData("--cfg-multiple");
    let min = multiple ? this.getCssData("--cfg-multiple-min") ?? 0 : 1;
    let max = multiple ? this.getCssData("--cfg-multiple-max") ?? 0 : 1;
    let count = this.uploadCollection.size;
    let tooFew = min ? count < min : false;
    let tooMany = max ? count > max : false;
    let passed = !tooFew && !tooMany;
    let exact = max === count;
    return {
      passed,
      tooFew,
      tooMany,
      min,
      max,
      exact
    };
  }
  /** @private */
  _updateCountLimitMessage() {
    let filesCount = this.uploadCollection.size;
    let countValidationResult = this._validateFilesCount();
    if (filesCount && !countValidationResult.passed) {
      let msg = new UiMessage();
      let textKey = countValidationResult.tooFew ? "files-count-limit-error-too-few" : "files-count-limit-error-too-many";
      msg.caption = this.l10n("files-count-limit-error-title");
      msg.text = this.l10n(textKey, {
        min: countValidationResult.min,
        max: countValidationResult.max,
        total: filesCount
      });
      msg.isError = true;
      this.set$({
        "*message": msg
      });
    }
  }
  /** @private */
  _updateUploadsState() {
    let itemIds = this.uploadCollection.items();
    let filesCount = itemIds.length;
    let summary = {
      total: filesCount,
      succeed: 0,
      uploading: 0,
      failed: 0
    };
    for (let id of itemIds) {
      let item = this.uploadCollection.read(id);
      if (item.getValue("uuid") && !item.getValue("validationErrorMsg")) {
        summary.succeed += 1;
      }
      if (item.getValue("isUploading")) {
        summary.uploading += 1;
      }
      if (item.getValue("validationErrorMsg") || item.getValue("uploadError")) {
        summary.failed += 1;
      }
    }
    let allDone = summary.total === summary.succeed + summary.failed;
    let { passed: fitCountRestrictions, tooMany, exact } = this._validateFilesCount();
    let fitValidation = summary.failed === 0;
    let doneBtnEnabled = summary.total > 0 && fitCountRestrictions && fitValidation;
    let uploadBtnVisible = !allDone && summary.total - summary.succeed - summary.uploading - summary.failed > 0 && fitCountRestrictions;
    this.set$({
      doneBtnVisible: allDone,
      doneBtnEnabled,
      uploadBtnVisible,
      addMoreBtnEnabled: summary.total === 0 || !tooMany && !exact,
      addMoreBtnVisible: !exact || this.getCssData("--cfg-multiple"),
      headerText: this._getHeaderText(summary)
    });
  }
  /** @private */
  _getHeaderText(summary) {
    const localizedText = (status) => {
      const count = summary[status];
      return this.l10n(`header-${status}`, {
        count
      });
    };
    if (summary.uploading > 0) {
      return localizedText("uploading");
    }
    if (summary.failed > 0) {
      return localizedText("failed");
    }
    if (summary.succeed > 0) {
      return localizedText("succeed");
    }
    return localizedText("total");
  }
  initCallback() {
    super.initCallback();
    this.registerActivity(this.activityType);
    this.sub("--cfg-multiple", this._debouncedHandleCollectionUpdate);
    this.sub("--cfg-multiple-min", this._debouncedHandleCollectionUpdate);
    this.sub("--cfg-multiple-max", this._debouncedHandleCollectionUpdate);
    this.sub("*currentActivity", (currentActivity) => {
      var _a2;
      if (((_a2 = this.uploadCollection) == null ? void 0 : _a2.size) === 0 && !this.getCssData("--cfg-show-empty-list") && currentActivity === this.activityType) {
        this.$["*currentActivity"] = this.initActivity;
      }
    });
    this.uploadCollection.observe(this._debouncedHandleCollectionUpdate);
    this.sub("*uploadList", (list) => {
      this._debouncedHandleCollectionUpdate();
      this.set$({
        hasFiles: list.length > 0
      });
      if ((list == null ? void 0 : list.length) === 0 && !this.getCssData("--cfg-show-empty-list")) {
        this.historyBack();
      }
    });
  }
  destroyCallback() {
    super.destroyCallback();
    this.uploadCollection.unobserve(this._debouncedHandleCollectionUpdate);
  }
};
UploadList.template = /* HTML */
`
  <lr-activity-header>
    <span class="header-text">{{headerText}}</span>
    <button type="button" class="mini-btn close-btn" set="onclick: *closeModal">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>

  <div class="no-files" set="@hidden: hasFiles">
    <slot name="empty"><span l10n="no-files"></span></slot>
  </div>

  <div class="files" repeat="*uploadList" repeat-item-tag="lr-file-item"></div>

  <div class="toolbar">
    <button type="button" class="cancel-btn secondary-btn" set="onclick: onCancel;" l10n="clear"></button>
    <div class="toolbar-spacer"></div>
    <button
      type="button"
      class="add-more-btn secondary-btn"
      set="onclick: onAdd; @disabled: !addMoreBtnEnabled; @hidden: !addMoreBtnVisible"
    >
      <lr-icon name="add"></lr-icon><span l10n="add-more"></span>
    </button>
    <button
      type="button"
      class="upload-btn primary-btn"
      set="@hidden: !uploadBtnVisible; onclick: onUpload;"
      l10n="upload"
    ></button>
    <button
      type="button"
      class="done-btn primary-btn"
      set="@hidden: !doneBtnVisible; onclick: onDone;  @disabled: !doneBtnEnabled"
      l10n="done"
    ></button>
  </div>

  <lr-drop-area ghost></lr-drop-area>
`;

// node_modules/@uploadcare/blocks/blocks/UrlSource/UrlSource.js
var UrlSource = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.URL);
    __publicField(this, "init$", {
      ...this.ctxInit,
      importDisabled: true,
      onUpload: () => {
        let url = this.ref.input["value"];
        this.uploadCollection.add({
          externalUrl: url
        });
        this.$["*currentActivity"] = ActivityBlock.activities.UPLOAD_LIST;
      },
      onCancel: () => {
        this.historyBack();
      },
      onInput: (e) => {
        let value = (
          /** @type {HTMLInputElement} */
          e.target.value
        );
        this.set$({ importDisabled: !value });
      }
    });
  }
  initCallback() {
    super.initCallback();
    this.registerActivity(this.activityType);
  }
};
UrlSource.template = /* HTML */
`
  <lr-activity-header>
    <button type="button" class="mini-btn" set="onclick: *historyBack">
      <lr-icon name="back"></lr-icon>
    </button>
    <div>
      <lr-icon name="url"></lr-icon>
      <span l10n="caption-from-url"></span>
    </div>
    <button type="button" class="mini-btn close-btn" set="onclick: *closeModal">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>
  <div class="content">
    <input placeholder="https://" class="url-input" type="text" ref="input" set="oninput: onInput" />
    <button
      type="button"
      class="url-upload-btn primary-btn"
      set="onclick: onUpload; @disabled: importDisabled"
    ></button>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/utils/abilities.js
var canUsePermissionsApi = () => {
  return typeof navigator.permissions !== "undefined";
};

// node_modules/@uploadcare/blocks/blocks/CameraSource/CameraSource.js
var CameraSource = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.CAMERA);
    /** @private */
    __publicField(this, "_unsubPermissions", null);
    __publicField(this, "init$", {
      ...this.ctxInit,
      video: null,
      videoTransformCss: null,
      shotBtnDisabled: true,
      videoHidden: true,
      messageHidden: true,
      requestBtnHidden: canUsePermissionsApi(),
      l10nMessage: null,
      originalErrorMessage: null,
      cameraSelectOptions: null,
      cameraSelectHidden: true,
      onCameraSelectChange: (e) => {
        this._selectedCameraId = e.target.value;
        this._capture();
      },
      onCancel: () => {
        this.historyBack();
      },
      onShot: () => {
        this._shot();
      },
      onRequestPermissions: () => {
        this._capture();
      }
    });
    __publicField(this, "cssInit$", {
      "--cfg-camera-mirror": 1
    });
    /** @private */
    __publicField(this, "_onActivate", () => {
      if (canUsePermissionsApi()) {
        this._subscribePermissions();
      }
      this._capture();
    });
    /** @private */
    __publicField(this, "_onDeactivate", () => {
      if (this._unsubPermissions) {
        this._unsubPermissions();
      }
      this._stopCapture();
    });
    /** @private */
    __publicField(this, "_handlePermissionsChange", () => {
      this._capture();
    });
    /**
     * @private
     * @param {'granted' | 'denied' | 'prompt'} state
     */
    __publicField(this, "_setPermissionsState", debounce((state) => {
      this.$.originalErrorMessage = null;
      this.classList.toggle("initialized", state === "granted");
      if (state === "granted") {
        this.set$({
          videoHidden: false,
          shotBtnDisabled: false,
          messageHidden: true
        });
      } else if (state === "prompt") {
        this.$.l10nMessage = this.l10n("camera-permissions-prompt");
        this.set$({
          videoHidden: true,
          shotBtnDisabled: true,
          messageHidden: false
        });
        this._stopCapture();
      } else {
        this.$.l10nMessage = this.l10n("camera-permissions-denied");
        this.set$({
          videoHidden: true,
          shotBtnDisabled: true,
          messageHidden: false
        });
        this._stopCapture();
      }
    }, 300));
  }
  /** @private */
  async _subscribePermissions() {
    try {
      let permissionsResponse = await navigator.permissions.query({ name: "camera" });
      permissionsResponse.addEventListener("change", this._handlePermissionsChange);
    } catch (err) {
      console.log("Failed to use permissions API. Fallback to manual request mode.", err);
      this._capture();
    }
  }
  /** @private */
  async _capture() {
    let constr = {
      video: {
        width: {
          ideal: 1920
        },
        height: {
          ideal: 1080
        },
        frameRate: {
          ideal: 30
        }
      },
      audio: false
    };
    if (this._selectedCameraId) {
      constr.video.deviceId = {
        exact: this._selectedCameraId
      };
    }
    this._canvas = document.createElement("canvas");
    this._ctx = this._canvas.getContext("2d");
    try {
      this._setPermissionsState("prompt");
      let stream = await navigator.mediaDevices.getUserMedia(constr);
      stream.addEventListener("inactive", () => {
        this._setPermissionsState("denied");
      });
      this.$.video = stream;
      this._capturing = true;
      this._setPermissionsState("granted");
    } catch (err) {
      this._setPermissionsState("denied");
      this.$.originalErrorMessage = err.message;
    }
  }
  /** @private */
  _stopCapture() {
    var _a2;
    if (this._capturing) {
      (_a2 = this.$.video) == null ? void 0 : _a2.getTracks()[0].stop();
      this.$.video = null;
      this._capturing = false;
    }
  }
  /** @private */
  _shot() {
    this._canvas.height = this.ref.video["videoHeight"];
    this._canvas.width = this.ref.video["videoWidth"];
    this._ctx.drawImage(this.ref.video, 0, 0);
    let date = Date.now();
    let name = `camera-${date}.png`;
    this._canvas.toBlob((blob) => {
      let file = new File([blob], name, {
        lastModified: date,
        type: "image/png"
      });
      this.uploadCollection.add({
        file,
        fileName: name,
        fileSize: file.size,
        isImage: true,
        mimeType: file.type
      });
      this.set$({
        "*currentActivity": ActivityBlock.activities.UPLOAD_LIST
      });
    });
  }
  async initCallback() {
    super.initCallback();
    this.registerActivity(this.activityType, {
      onActivate: this._onActivate,
      onDeactivate: this._onDeactivate
    });
    this.sub("--cfg-camera-mirror", (val) => {
      this.$.videoTransformCss = val ? "scaleX(-1)" : null;
    });
    try {
      let deviceList = await navigator.mediaDevices.enumerateDevices();
      let cameraSelectOptions = deviceList.filter((info2) => {
        return info2.kind === "videoinput";
      }).map((info2, idx) => {
        return {
          text: info2.label.trim() || `${this.l10n("caption-camera")} ${idx + 1}`,
          value: info2.deviceId
        };
      });
      if (cameraSelectOptions.length > 1) {
        this.$.cameraSelectOptions = cameraSelectOptions;
        this.$.cameraSelectHidden = false;
      }
    } catch (err) {
    }
  }
};
CameraSource.template = /* HTML */
`
  <lr-activity-header>
    <button type="button" class="mini-btn" set="onclick: *historyBack">
      <lr-icon name="back"></lr-icon>
    </button>
    <div set="@hidden: !cameraSelectHidden">
      <lr-icon name="camera"></lr-icon>
      <span l10n="caption-camera"></span>
    </div>
    <lr-select
      class="camera-select"
      set="$.options: cameraSelectOptions; @hidden: cameraSelectHidden; onchange: onCameraSelectChange"
    >
    </lr-select>
    <button type="button" class="mini-btn close-btn" set="onclick: *closeModal">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>
  <div class="content">
    <video
      autoplay
      playsinline
      set="srcObject: video; style.transform: videoTransformCss; @hidden: videoHidden"
      ref="video"
    ></video>
    <div class="message-box" set="@hidden: messageHidden">
      <span>{{l10nMessage}}</span>
      <span>{{originalErrorMessage}}</span>
      <button
        type="button"
        set="onclick: onRequestPermissions; @hidden: requestBtnHidden"
        l10n="camera-permissions-request"
      ></button>
    </div>
    <button type="button" class="shot-btn" set="onclick: onShot; @disabled: shotBtnDisabled">
      <lr-icon name="camera"></lr-icon>
    </button>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/UploadCtxProvider/UploadCtxProvider.js
var UploadCtxProvider = class extends UploaderBlock {
};

// node_modules/@uploadcare/blocks/blocks/UploadDetails/UploadDetails.js
var UploadDetails = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.DETAILS);
    __publicField(this, "pauseRender", true);
    __publicField(this, "init$", {
      ...this.ctxInit,
      checkerboard: false,
      fileSize: null,
      fileName: "",
      cdnUrl: "",
      errorTxt: "",
      cloudEditBtnHidden: true,
      onNameInput: null,
      onBack: () => {
        this.historyBack();
      },
      onRemove: () => {
        this.uploadCollection.remove(this.entry.uid);
        this.historyBack();
      },
      onCloudEdit: () => {
        if (this.entry.getValue("uuid")) {
          this.$["*currentActivity"] = ActivityBlock.activities.CLOUD_IMG_EDIT;
        }
      }
    });
    __publicField(this, "cssInit$", {
      "--cfg-use-cloud-image-editor": 0,
      "--cfg-use-local-image-editor": 0
    });
  }
  showNonImageThumb() {
    let color = window.getComputedStyle(this).getPropertyValue("--clr-generic-file-icon");
    let url = fileCssBg(color, 108, 108);
    this.ref.filePreview.setImageUrl(url);
    this.set$({
      checkerboard: false
    });
  }
  initCallback() {
    super.initCallback();
    this.render();
    this.$.fileSize = this.l10n("file-size-unknown");
    this.registerActivity(this.activityType, {
      onDeactivate: () => {
        this.ref.filePreview.clear();
      }
    });
    this.sub("*focusedEntry", (entry) => {
      if (!entry) {
        return;
      }
      if (this._entrySubs) {
        this._entrySubs.forEach((sub) => {
          this._entrySubs.delete(sub);
          sub.remove();
        });
      } else {
        this._entrySubs = /* @__PURE__ */ new Set();
      }
      this.entry = entry;
      let file = entry.getValue("file");
      if (file) {
        this._file = file;
        let isImage = fileIsImage(this._file);
        if (isImage && !entry.getValue("cdnUrl")) {
          this.ref.filePreview.setImageFile(this._file);
          this.set$({
            checkerboard: true
          });
        }
        if (!isImage) {
          this.showNonImageThumb();
        }
      }
      let tmpSub = (prop, callback) => {
        this._entrySubs.add(this.entry.subscribe(prop, callback));
      };
      tmpSub("fileName", (name) => {
        this.$.fileName = name;
        this.$.onNameInput = () => {
          let value = this.ref.file_name_input["value"];
          Object.defineProperty(this._file, "name", {
            writable: true,
            value
          });
          this.entry.setValue("fileName", value);
        };
      });
      tmpSub("fileSize", (size) => {
        this.$.fileSize = Number.isFinite(size) ? this.fileSizeFmt(size) : this.l10n("file-size-unknown");
      });
      tmpSub("uploadError", (error) => {
        this.$.errorTxt = error == null ? void 0 : error.message;
      });
      tmpSub("externalUrl", (url) => {
        if (!url) {
          return;
        }
        if (!this.entry.getValue("uuid")) {
          this.showNonImageThumb();
        }
      });
      tmpSub("cdnUrl", (cdnUrl) => {
        const canUseCloudEditor = this.$["--cfg-use-cloud-image-editor"] && cdnUrl && this.entry.getValue("isImage");
        cdnUrl && this.ref.filePreview.clear();
        this.set$({
          cdnUrl,
          cloudEditBtnHidden: !canUseCloudEditor
        });
        if (cdnUrl && this.entry.getValue("isImage")) {
          let imageUrl = createCdnUrl(cdnUrl, createCdnUrlModifiers("format/auto", "preview"));
          this.ref.filePreview.setImageUrl(this.proxyUrl(imageUrl));
        }
      });
    });
  }
};
UploadDetails.template = /* HTML */
`
  <lr-activity-header>
    <button type="button" class="mini-btn" set="onclick: *historyBack">
      <lr-icon name="back"></lr-icon>
    </button>
    <span l10n="caption-edit-file"></span>
    <button type="button" class="mini-btn close-btn" set="onclick: *closeModal">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>
  <div class="content">
    <lr-tabs tab-list="tab-view, tab-details">
      <div tab-ctx="tab-details" class="details">
        <div class="info-block">
          <div class="info-block_name" l10n="file-name"></div>
          <input
            name="name-input"
            ref="file_name_input"
            set="value: fileName; oninput: onNameInput; @disabled: !!cdnUrl"
            type="text"
          />
        </div>

        <div class="info-block">
          <div class="info-block_name" l10n="file-size"></div>
          <div>{{fileSize}}</div>
        </div>

        <div class="info-block">
          <div class="info-block_name" l10n="cdn-url"></div>
          <a class="cdn-link" target="_blank" set="@href: cdnUrl; @disabled: !cdnUrl">{{cdnUrl}}</a>
        </div>

        <div>{{errorTxt}}</div>
      </div>

      <lr-file-preview tab-ctx="tab-view" set="@checkerboard: checkerboard;" ref="filePreview"> </lr-file-preview>
    </lr-tabs>

    <div class="toolbar" set="@edit-disabled: cloudEditBtnHidden">
      <button type="button" class="edit-btn secondary-btn" set="onclick: onCloudEdit; @hidden: cloudEditBtnHidden;">
        <lr-icon name="edit"></lr-icon>
        <span l10n="edit-image"></span>
      </button>
      <button type="button" class="remove-btn secondary-btn" set="onclick: onRemove">
        <lr-icon name="remove"></lr-icon>
        <span l10n="remove-from-list"></span>
      </button>
      <div></div>
      <button type="button" class="back-btn primary-btn" set="onclick: onBack">
        <span l10n="ok"></span>
      </button>
    </div>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/ConfirmationDialog/ConfirmationDialog.js
var UiConfirmation = class {
  constructor() {
    __publicField(this, "captionL10nStr", "confirm-your-action");
    __publicField(this, "messageL10Str", "are-you-sure");
    __publicField(this, "confirmL10nStr", "yes");
    __publicField(this, "denyL10nStr", "no");
  }
  confirmAction() {
    console.log("Confirmed");
  }
  denyAction() {
    this["historyBack"]();
  }
};
var ConfirmationDialog = class extends ActivityBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.CONFIRMATION);
    /** @private */
    __publicField(this, "_defaults", new UiConfirmation());
    __publicField(this, "init$", {
      ...this.ctxInit,
      activityCaption: "",
      messageTxt: "",
      confirmBtnTxt: "",
      denyBtnTxt: "",
      "*confirmation": null,
      onConfirm: this._defaults.confirmAction,
      onDeny: this._defaults.denyAction.bind(this)
    });
  }
  initCallback() {
    super.initCallback();
    this.set$({
      messageTxt: this.l10n(this._defaults.messageL10Str),
      confirmBtnTxt: this.l10n(this._defaults.confirmL10nStr),
      denyBtnTxt: this.l10n(this._defaults.denyL10nStr)
    });
    this.sub("*confirmation", (cfn) => {
      if (!cfn) {
        return;
      }
      this.set$({
        "*currentActivity": ActivityBlock.activities.CONFIRMATION,
        activityCaption: this.l10n(cfn.captionL10nStr),
        messageTxt: this.l10n(cfn.messageL10Str),
        confirmBtnTxt: this.l10n(cfn.confirmL10nStr),
        denyBtnTxt: this.l10n(cfn.denyL10nStr),
        onDeny: () => {
          cfn.denyAction();
        },
        onConfirm: () => {
          cfn.confirmAction();
        }
      });
    });
  }
};
ConfirmationDialog.template = /* HTML */
`
  <lr-activity-header>
    <button type="button" class="mini-btn" set="onclick: *historyBack">
      <lr-icon name="back"></lr-icon>
    </button>
    <span>{{activityCaption}}</span>
    <button type="button" class="mini-btn close-btn" set="onclick: *closeModal">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>

  <div class="message">{{messageTxt}}</div>
  <div class="toolbar">
    <button type="button" class="deny-btn secondary-btn" set="onclick: onDeny">{{denyBtnTxt}}</button>
    <button type="button" class="confirm-btn primary-btn" set="onclick: onConfirm">{{confirmBtnTxt}}</button>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/ProgressBarCommon/ProgressBarCommon.js
var ProgressBarCommon = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      visible: false,
      unknown: false,
      value: 0,
      "*commonProgress": 0
    });
  }
  initCallback() {
    super.initCallback();
    this.uploadCollection.observe(() => {
      let anyUploading = this.uploadCollection.items().some((id) => {
        let item = this.uploadCollection.read(id);
        return item.getValue("isUploading");
      });
      this.$.visible = anyUploading;
    });
    this.sub("visible", (visible) => {
      if (visible) {
        this.setAttribute("active", "");
      } else {
        this.removeAttribute("active");
      }
    });
    this.sub("*commonProgress", (progress) => {
      this.$.value = progress;
    });
  }
};
ProgressBarCommon.template = /* HTML */
`
  <lr-progress-bar set="visible: visible; unknown: unknown; value: value"></lr-progress-bar>
`;

// node_modules/@uploadcare/blocks/blocks/ProgressBar/ProgressBar.js
var ProgressBar = class extends Block {
  constructor() {
    super(...arguments);
    /** @type {Number} */
    __publicField(this, "_value", 0);
    /** @type {Boolean} */
    __publicField(this, "_unknownMode", false);
    __publicField(this, "init$", {
      ...this.ctxInit,
      width: 0,
      opacity: 0
    });
  }
  initCallback() {
    super.initCallback();
    this.defineAccessor("value", (value) => {
      if (value === void 0) {
        return;
      }
      this._value = value;
      if (!this._unknownMode) {
        this.style.setProperty("--l-width", this._value.toString());
      }
    });
    this.defineAccessor("visible", (visible) => {
      this.ref.line.classList.toggle("progress--hidden", !visible);
    });
    this.defineAccessor("unknown", (unknown) => {
      this._unknownMode = unknown;
      this.ref.line.classList.toggle("progress--unknown", unknown);
    });
  }
};
ProgressBar.template = /* HTML */
` <div ref="line" class="progress"></div> `;

// node_modules/@uploadcare/blocks/utils/transparentPixelSrc.js
var TRANSPARENT_PIXEL_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

// node_modules/@uploadcare/blocks/blocks/FilePreview/FilePreview.js
var FilePreview = class extends Block {
  constructor() {
    super();
    __publicField(this, "init$", {
      ...this.ctxInit,
      checkerboard: false,
      src: TRANSPARENT_PIXEL_SRC
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("checkerboard", () => {
      this.style.backgroundImage = this.hasAttribute("checkerboard") ? `url(${checkerboardCssBg()})` : "unset";
    });
  }
  destroyCallback() {
    super.destroyCallback();
    URL.revokeObjectURL(this._lastObjectUrl);
  }
  /** @param {HTMLImageElement} img */
  setImage(img) {
    this.$.src = img.src;
  }
  /** @param {File} imgFile */
  setImageFile(imgFile) {
    let url = URL.createObjectURL(imgFile);
    this.$.src = url;
    this._lastObjectUrl = url;
  }
  /** @param {String} url */
  setImageUrl(url) {
    this.$.src = url;
  }
  clear() {
    URL.revokeObjectURL(this._lastObjectUrl);
    this.$.src = TRANSPARENT_PIXEL_SRC;
  }
};
FilePreview.template = /* HTML */
` <lr-img class="img-view" ref="img" set="@src: src; style.aa: src;" /> `;
FilePreview.bindAttributes({
  checkerboard: "checkerboard"
});

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/classNames.js
function normalize(...args) {
  return args.reduce((result, arg) => {
    if (typeof arg === "string") {
      result[arg] = true;
      return result;
    }
    for (let token of Object.keys(arg)) {
      result[token] = arg[token];
    }
    return result;
  }, {});
}
function classNames(...args) {
  let mapping = normalize(...args);
  return Object.keys(mapping).reduce((result, token) => {
    if (mapping[token]) {
      result.push(token);
    }
    return result;
  }, []).join(" ");
}
function applyClassNames(element, ...args) {
  let mapping = normalize(...args);
  for (let token of Object.keys(mapping)) {
    element.classList.toggle(token, mapping[token]);
  }
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/debounce.js
function debounce2(callback, wait) {
  let timer;
  let debounced = (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => callback(...args), wait);
  };
  debounced.cancel = () => {
    clearTimeout(timer);
  };
  return debounced;
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/transformationUtils.js
var OPERATIONS_ZEROS = {
  brightness: 0,
  exposure: 0,
  gamma: 100,
  contrast: 0,
  saturation: 0,
  vibrance: 0,
  warmth: 0,
  enhance: 0,
  filter: 0,
  rotate: 0
};
function transformationToStr(operation, options) {
  if (typeof options === "number") {
    return OPERATIONS_ZEROS[operation] !== options ? `${operation}/${options}` : "";
  }
  if (typeof options === "boolean") {
    return options && OPERATIONS_ZEROS[operation] !== options ? `${operation}` : "";
  }
  if (operation === "filter") {
    if (!options || OPERATIONS_ZEROS[operation] === options.amount) {
      return "";
    }
    let { name, amount } = options;
    return `${operation}/${name}/${amount}`;
  }
  if (operation === "crop") {
    if (!options) {
      return "";
    }
    let { dimensions, coords } = options;
    return `${operation}/${dimensions.join("x")}/${coords.join(",")}`;
  }
  return "";
}
var SUPPORTED_OPERATIONS_ORDERED = [
  "enhance",
  "brightness",
  "exposure",
  "gamma",
  "contrast",
  "saturation",
  "vibrance",
  "warmth",
  "filter",
  "mirror",
  "flip",
  "rotate",
  "crop"
];
function transformationsToOperations(transformations) {
  return joinCdnOperations(
    ...SUPPORTED_OPERATIONS_ORDERED.filter(
      (operation) => typeof transformations[operation] !== "undefined" && transformations[operation] !== null
    ).map((operation) => {
      let options = transformations[operation];
      return transformationToStr(operation, options);
    }).filter((str) => !!str)
  );
}
var COMMON_OPERATIONS = joinCdnOperations("format/auto", "progressive/yes");
var asNumber = ([value]) => typeof value !== "undefined" ? Number(value) : void 0;
var asBoolean = () => true;
var asFilter = ([name, amount]) => ({
  name,
  amount: typeof amount !== "undefined" ? Number(amount) : 100
});
var asCrop = ([dimensions, coords]) => {
  return { dimensions: stringToArray(dimensions, "x").map(Number), coords: stringToArray(coords).map(Number) };
};
var OPERATION_PROCESSORS = {
  enhance: asNumber,
  brightness: asNumber,
  exposure: asNumber,
  gamma: asNumber,
  contrast: asNumber,
  saturation: asNumber,
  vibrance: asNumber,
  warmth: asNumber,
  filter: asFilter,
  mirror: asBoolean,
  flip: asBoolean,
  rotate: asNumber,
  crop: asCrop
};
function operationsToTransformations(operations) {
  let transformations = {};
  for (let operation of operations) {
    let [name, ...args] = operation.split("/");
    if (!SUPPORTED_OPERATIONS_ORDERED.includes(name)) {
      continue;
    }
    const processor = OPERATION_PROCESSORS[name];
    const value = processor(args);
    transformations[name] = value;
  }
  return transformations;
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/state.js
function initState(fnCtx) {
  return {
    "*originalUrl": null,
    "*faderEl": null,
    "*cropperEl": null,
    "*imgEl": null,
    "*imgContainerEl": null,
    "*networkProblems": false,
    "*imageSize": null,
    /** @type {import('./types.js').Transformations} */
    "*editorTransformations": {},
    entry: null,
    extension: null,
    editorMode: false,
    modalCaption: "",
    isImage: false,
    msg: "",
    src: TRANSPARENT_PIXEL_SRC,
    fileType: "",
    showLoader: false,
    uuid: null,
    cdnUrl: null,
    "presence.networkProblems": false,
    "presence.modalCaption": true,
    "presence.editorToolbar": false,
    "presence.viewerToolbar": true,
    // TODO: beware of wrong ctx in case of element re-creation:
    "*on.retryNetwork": () => {
      let images = fnCtx.querySelectorAll("img");
      for (let img of images) {
        let originalSrc = img.src;
        img.src = TRANSPARENT_PIXEL_SRC;
        img.src = originalSrc;
      }
      fnCtx.$["*networkProblems"] = false;
    },
    "*on.apply": (transformations) => {
      if (!transformations) {
        return;
      }
      let originalUrl = fnCtx.$["*originalUrl"];
      let cdnUrlModifiers = createCdnUrlModifiers(transformationsToOperations(transformations));
      let cdnUrl = createCdnUrl(originalUrl, createCdnUrlModifiers(cdnUrlModifiers, "preview"));
      let eventData = {
        originalUrl,
        cdnUrlModifiers,
        cdnUrl,
        transformations
      };
      fnCtx.dispatchEvent(
        new CustomEvent("apply", {
          detail: eventData,
          bubbles: true,
          composed: true
        })
      );
      fnCtx.remove();
    },
    "*on.cancel": () => {
      fnCtx.remove();
      fnCtx.dispatchEvent(
        new CustomEvent("cancel", {
          bubbles: true,
          composed: true
        })
      );
    }
  };
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/template.js
var TEMPLATE = (
  /* HTML */
  `
  <div class="wrapper wrapper_desktop">
    <lr-presence-toggle class="network_problems_splash" set="visible: presence.networkProblems;">
      <div class="network_problems_content">
        <div class="network_problems_icon">
          <lr-icon size="20" name="sad"></lr-icon>
        </div>
        <div class="network_problems_text">Network error</div>
      </div>
      <div class="network_problems_footer">
        <lr-btn-ui theme="primary" text="Retry" set="onclick: *on.retryNetwork"></lr-btn-ui>
      </div>
    </lr-presence-toggle>
    <div class="viewport">
      <div class="file_type_outer">
        <div class="file_type">{{fileType}}</div>
      </div>
      <div class="image_container" ref="img-container-el">
        <img src="${TRANSPARENT_PIXEL_SRC}" class="image image_visible_from_editor" ref="img-el" />
        <lr-editor-image-cropper ref="cropper-el"></lr-editor-image-cropper>
        <lr-editor-image-fader ref="fader-el"></lr-editor-image-fader>
      </div>
      <div class="info_pan">{{msg}}</div>
    </div>
    <div class="toolbar">
      <lr-line-loader-ui set="active: showLoader"></lr-line-loader-ui>
      <div class="toolbar_content toolbar_content__editor">
        <lr-editor-toolbar></lr-editor-toolbar>
      </div>
    </div>
  </div>
`
);

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/toolbar-constants.js
var TabId = {
  CROP: "crop",
  SLIDERS: "sliders",
  FILTERS: "filters"
};
var TABS = [TabId.CROP, TabId.SLIDERS, TabId.FILTERS];
var ALL_COLOR_OPERATIONS = [
  "brightness",
  "exposure",
  "gamma",
  "contrast",
  "saturation",
  "vibrance",
  "warmth",
  "enhance"
];
var ALL_FILTERS = [
  "adaris",
  "briaril",
  "calarel",
  "carris",
  "cynarel",
  "cyren",
  "elmet",
  "elonni",
  "enzana",
  "erydark",
  "fenralan",
  "ferand",
  "galen",
  "gavin",
  "gethriel",
  "iorill",
  "iothari",
  "iselva",
  "jadis",
  "lavra",
  "misiara",
  "namala",
  "nerion",
  "nethari",
  "pamaya",
  "sarnar",
  "sedis",
  "sewen",
  "sorahel",
  "sorlen",
  "tarian",
  "thellassan",
  "varriel",
  "varven",
  "vevera",
  "virkas",
  "yedis",
  "yllara",
  "zatvel",
  "zevcen"
];
var ALL_CROP_OPERATIONS = ["rotate", "mirror", "flip"];
var COLOR_OPERATIONS_CONFIG = {
  brightness: {
    zero: OPERATIONS_ZEROS.brightness,
    range: [-100, 100],
    keypointsNumber: 2
  },
  exposure: {
    zero: OPERATIONS_ZEROS.exposure,
    range: [-500, 500],
    keypointsNumber: 2
  },
  gamma: {
    zero: OPERATIONS_ZEROS.gamma,
    range: [0, 1e3],
    keypointsNumber: 2
  },
  contrast: {
    zero: OPERATIONS_ZEROS.contrast,
    range: [-100, 500],
    keypointsNumber: 2
  },
  saturation: {
    zero: OPERATIONS_ZEROS.saturation,
    range: [-100, 500],
    keypointsNumber: 1
  },
  vibrance: {
    zero: OPERATIONS_ZEROS.vibrance,
    range: [-100, 500],
    keypointsNumber: 1
  },
  warmth: {
    zero: OPERATIONS_ZEROS.warmth,
    range: [-100, 100],
    keypointsNumber: 1
  },
  enhance: {
    zero: OPERATIONS_ZEROS.enhance,
    range: [0, 100],
    keypointsNumber: 1
  },
  filter: {
    zero: OPERATIONS_ZEROS.filter,
    range: [0, 100],
    keypointsNumber: 1
  }
};

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/CloudEditor.js
var CloudEditor = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "pauseRender", true);
    __publicField(this, "init$", {
      ...this.ctxInit,
      ...initState(this)
    });
    /** @private */
    __publicField(this, "_debouncedShowLoader", debounce2(this._showLoader.bind(this), 300));
    __publicField(this, "cssInit$", {
      "--cfg-cdn-cname": "https://ucarecdn.com"
    });
  }
  get ctxName() {
    return this.autoCtxName;
  }
  _showLoader(show) {
    this.$.showLoader = show;
  }
  /**
   * To proper work, we need non-zero size the element. So, we'll wait for it.
   *
   * @private
   * @returns {Promise<void>}
   */
  _waitForSize() {
    const TIMEOUT = 3e3;
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("[cloud-image-editor] timout waiting for non-zero container size"));
      }, TIMEOUT);
      const resizeObserver = new ResizeObserver(([element]) => {
        if (element.contentRect.width > 0 && element.contentRect.height > 0) {
          resolve();
          clearTimeout(timeoutId);
          resizeObserver.disconnect();
        }
      });
      resizeObserver.observe(this);
    });
  }
  async connectedCallback() {
    super.connectedCallback();
    try {
      await this._waitForSize();
    } catch (err) {
      if (this.isConnected) {
        console.error(err.message);
      }
      return;
    }
    this.render();
    this.$["*faderEl"] = this.ref["fader-el"];
    this.$["*cropperEl"] = this.ref["cropper-el"];
    this.$["*imgContainerEl"] = this.ref["img-container-el"];
    this.ref["img-el"].addEventListener("load", (e) => {
      this._imgLoading = false;
      this._debouncedShowLoader(false);
      if (this.$.src !== TRANSPARENT_PIXEL_SRC) {
        this.$["*networkProblems"] = false;
      }
    });
    this.ref["img-el"].addEventListener("error", (e) => {
      this._imgLoading = false;
      this._debouncedShowLoader(false);
      this.$["*networkProblems"] = true;
    });
    this.sub("src", (src) => {
      let el = this.ref["img-el"];
      if (el.src !== src) {
        this._imgLoading = true;
        el.src = src || TRANSPARENT_PIXEL_SRC;
      }
    });
    this.sub("*tabId", (tabId) => {
      this.ref["img-el"].className = classNames("image", {
        image_hidden_to_cropper: tabId === TabId.CROP,
        image_hidden_effects: tabId !== TabId.CROP
      });
    });
  }
  initCallback() {
    super.initCallback();
    if (this.$.cdnUrl) {
      let uuid = extractUuid(this.$.cdnUrl);
      this.$["*originalUrl"] = createOriginalUrl(this.$.cdnUrl, uuid);
      let operations = extractOperations(this.$.cdnUrl);
      let transformations = operationsToTransformations(operations);
      this.$["*editorTransformations"] = transformations;
    } else if (this.$.uuid) {
      this.$["*originalUrl"] = createOriginalUrl(this.localCtx.read("--cfg-cdn-cname"), this.$.uuid);
    } else {
      throw new Error("No UUID nor CDN URL provided");
    }
    this.classList.add("editor_ON");
    this.sub("*networkProblems", (networkProblems) => {
      this.$["presence.networkProblems"] = networkProblems;
      this.$["presence.modalCaption"] = !networkProblems;
    });
    this.sub(
      "*editorTransformations",
      (transformations) => {
        let originalUrl = this.$["*originalUrl"];
        let cdnUrlModifiers = createCdnUrlModifiers(transformationsToOperations(transformations));
        let cdnUrl = createCdnUrl(originalUrl, createCdnUrlModifiers(cdnUrlModifiers, "preview"));
        let eventData = {
          originalUrl,
          cdnUrlModifiers,
          cdnUrl,
          transformations
        };
        this.dispatchEvent(
          new CustomEvent("change", {
            detail: eventData,
            bubbles: true,
            composed: true
          })
        );
      },
      false
    );
    try {
      fetch(createCdnUrl(this.$["*originalUrl"], createCdnUrlModifiers("json"))).then((response2) => response2.json()).then(({ width, height }) => {
        this.$["*imageSize"] = { width, height };
      });
    } catch (err) {
      if (err) {
        console.error("Failed to load image info", err);
      }
    }
  }
};
CloudEditor.template = TEMPLATE;
CloudEditor.bindAttributes({
  uuid: "uuid",
  "cdn-url": "cdnUrl"
});

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/cropper-constants.js
var CROP_PADDING = 20;
var THUMB_CORNER_SIZE = 24;
var THUMB_SIDE_SIZE = 34;
var THUMB_STROKE_WIDTH = 3;
var THUMB_OFFSET = THUMB_STROKE_WIDTH / 2;
var GUIDE_STROKE_WIDTH = 1;
var GUIDE_THIRD = 100 / 3;
var MIN_CROP_SIZE = THUMB_CORNER_SIZE * 2 + THUMB_SIDE_SIZE;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/crop-utils.js
function setSvgNodeAttrs(node, attrs) {
  for (let p in attrs)
    node.setAttributeNS(null, p, attrs[p].toString());
}
function createSvgNode(name, attrs = {}) {
  let node = document.createElementNS("http://www.w3.org/2000/svg", name);
  setSvgNodeAttrs(node, attrs);
  return node;
}
function cornerPath(rect, direction) {
  let { x, y, width, height } = rect;
  let wMul = direction.includes("w") ? 0 : 1;
  let hMul = direction.includes("n") ? 0 : 1;
  let xSide = [-1, 1][wMul];
  let ySide = [-1, 1][hMul];
  let p1 = [
    x + wMul * width + THUMB_OFFSET * xSide,
    y + hMul * height + THUMB_OFFSET * ySide - THUMB_CORNER_SIZE * ySide
  ];
  let p2 = [x + wMul * width + THUMB_OFFSET * xSide, y + hMul * height + THUMB_OFFSET * ySide];
  let p3 = [
    x + wMul * width - THUMB_CORNER_SIZE * xSide + THUMB_OFFSET * xSide,
    y + hMul * height + THUMB_OFFSET * ySide
  ];
  let path = `M ${p1[0]} ${p1[1]} L ${p2[0]} ${p2[1]} L ${p3[0]} ${p3[1]}`;
  let center = p2;
  return {
    d: path,
    center
  };
}
function sidePath(rect, direction) {
  let { x, y, width, height } = rect;
  let wMul = ["n", "s"].includes(direction) ? 0.5 : { w: 0, e: 1 }[direction];
  let hMul = ["w", "e"].includes(direction) ? 0.5 : { n: 0, s: 1 }[direction];
  let xSide = [-1, 1][wMul];
  let ySide = [-1, 1][hMul];
  let p1, p2;
  if (["n", "s"].includes(direction)) {
    p1 = [x + wMul * width - THUMB_SIDE_SIZE / 2, y + hMul * height + THUMB_OFFSET * ySide];
    p2 = [x + wMul * width + THUMB_SIDE_SIZE / 2, y + hMul * height + THUMB_OFFSET * ySide];
  } else {
    p1 = [x + wMul * width + THUMB_OFFSET * xSide, y + hMul * height - THUMB_SIDE_SIZE / 2];
    p2 = [x + wMul * width + THUMB_OFFSET * xSide, y + hMul * height + THUMB_SIDE_SIZE / 2];
  }
  let path = `M ${p1[0]} ${p1[1]} L ${p2[0]} ${p2[1]}`;
  let center = [p2[0] - (p2[0] - p1[0]) / 2, p2[1] - (p2[1] - p1[1]) / 2];
  return { d: path, center };
}
function thumbCursor(direction) {
  if (direction === "") {
    return "move";
  }
  if (["e", "w"].includes(direction)) {
    return "ew-resize";
  }
  if (["n", "s"].includes(direction)) {
    return "ns-resize";
  }
  if (["nw", "se"].includes(direction)) {
    return "nwse-resize";
  }
  return "nesw-resize";
}
function moveRect(rect, [dx, dy]) {
  return {
    ...rect,
    x: rect.x + dx,
    y: rect.y + dy
  };
}
function constraintRect(rect1, rect2) {
  let { x } = rect1;
  let { y } = rect1;
  if (rect1.x < rect2.x) {
    x = rect2.x;
  } else if (rect1.x + rect1.width > rect2.x + rect2.width) {
    x = rect2.x + rect2.width - rect1.width;
  }
  if (rect1.y < rect2.y) {
    y = rect2.y;
  } else if (rect1.y + rect1.height > rect2.y + rect2.height) {
    y = rect2.y + rect2.height - rect1.height;
  }
  return {
    ...rect1,
    x,
    y
  };
}
function expandRect(rect, [dx, dy], direction) {
  let { x, y, width, height } = rect;
  if (direction.includes("n")) {
    y += dy;
    height -= dy;
  }
  if (direction.includes("s")) {
    height += dy;
  }
  if (direction.includes("w")) {
    x += dx;
    width -= dx;
  }
  if (direction.includes("e")) {
    width += dx;
  }
  return {
    x,
    y,
    width,
    height
  };
}
function intersectionRect(rect1, rect2) {
  let leftX = Math.max(rect1.x, rect2.x);
  let rightX = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
  let topY = Math.max(rect1.y, rect2.y);
  let bottomY = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
  return { x: leftX, y: topY, width: rightX - leftX, height: bottomY - topY };
}
function minRectSize(rect, [minWidth, minHeight], direction) {
  let { x, y, width, height } = rect;
  if (direction.includes("n")) {
    let prevHeight = height;
    height = Math.max(minHeight, height);
    y = y + prevHeight - height;
  }
  if (direction.includes("s")) {
    height = Math.max(minHeight, height);
  }
  if (direction.includes("w")) {
    let prevWidth = width;
    width = Math.max(minWidth, width);
    x = x + prevWidth - width;
  }
  if (direction.includes("e")) {
    width = Math.max(minWidth, width);
  }
  return { x, y, width, height };
}
function rectContainsPoint(rect, [x, y]) {
  return rect.x <= x && x <= rect.x + rect.width && rect.y <= y && y <= rect.y + rect.height;
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/CropFrame.js
var CropFrame = class extends Block {
  constructor() {
    super();
    __publicField(this, "init$", {
      ...this.ctxInit,
      dragging: false
    });
    this._handlePointerUp = this._handlePointerUp_.bind(this);
    this._handlePointerMove = this._handlePointerMove_.bind(this);
    this._handleSvgPointerMove = this._handleSvgPointerMove_.bind(this);
  }
  _shouldThumbBeDisabled(direction) {
    let imageBox = this.$["*imageBox"];
    if (!imageBox) {
      return;
    }
    if (direction === "" && imageBox.height <= MIN_CROP_SIZE && imageBox.width <= MIN_CROP_SIZE) {
      return true;
    }
    let tooHigh = imageBox.height <= MIN_CROP_SIZE && (direction.includes("n") || direction.includes("s"));
    let tooWide = imageBox.width <= MIN_CROP_SIZE && (direction.includes("e") || direction.includes("w"));
    return tooHigh || tooWide;
  }
  _createBackdrop() {
    let cropBox = this.$["*cropBox"];
    if (!cropBox) {
      return;
    }
    let { x, y, width, height } = cropBox;
    let svg = this.ref["svg-el"];
    let mask = createSvgNode("mask", { id: "backdrop-mask" });
    let maskRectOuter = createSvgNode("rect", {
      x: 0,
      y: 0,
      width: "100%",
      height: "100%",
      fill: "white"
    });
    let maskRectInner = createSvgNode("rect", {
      x,
      y,
      width,
      height,
      fill: "black"
    });
    mask.appendChild(maskRectOuter);
    mask.appendChild(maskRectInner);
    let backdropRect = createSvgNode("rect", {
      x: 0,
      y: 0,
      width: "100%",
      height: "100%",
      fill: "var(--color-image-background)",
      "fill-opacity": 0.85,
      mask: "url(#backdrop-mask)"
    });
    svg.appendChild(backdropRect);
    svg.appendChild(mask);
    this._backdropMask = mask;
    this._backdropMaskInner = maskRectInner;
  }
  /** Super tricky workaround for the chromium bug See https://bugs.chromium.org/p/chromium/issues/detail?id=330815 */
  _resizeBackdrop() {
    if (!this._backdropMask) {
      return;
    }
    this._backdropMask.style.display = "none";
    window.requestAnimationFrame(() => {
      this._backdropMask.style.display = "block";
    });
  }
  _updateBackdrop() {
    let cropBox = this.$["*cropBox"];
    if (!cropBox) {
      return;
    }
    let { x, y, width, height } = cropBox;
    setSvgNodeAttrs(this._backdropMaskInner, { x, y, width, height });
  }
  _updateFrame() {
    let cropBox = this.$["*cropBox"];
    if (!cropBox) {
      return;
    }
    for (let thumb of Object.values(this._frameThumbs)) {
      let { direction, pathNode, interactionNode, groupNode } = thumb;
      let isCenter = direction === "";
      let isCorner = direction.length === 2;
      if (isCenter) {
        let { x, y, width, height } = cropBox;
        let center = [x + width / 2, y + height / 2];
        setSvgNodeAttrs(interactionNode, {
          r: Math.min(width, height) / 3,
          cx: center[0],
          cy: center[1]
        });
      } else {
        let { d, center } = isCorner ? cornerPath(cropBox, direction) : sidePath(cropBox, direction);
        setSvgNodeAttrs(interactionNode, { cx: center[0], cy: center[1] });
        setSvgNodeAttrs(pathNode, { d });
      }
      let disableThumb = this._shouldThumbBeDisabled(direction);
      groupNode.setAttribute(
        "class",
        classNames("thumb", {
          "thumb--hidden": disableThumb,
          "thumb--visible": !disableThumb
        })
      );
    }
    let frameGuides = this._frameGuides;
    setSvgNodeAttrs(frameGuides, {
      x: cropBox.x - GUIDE_STROKE_WIDTH * 0.5,
      y: cropBox.y - GUIDE_STROKE_WIDTH * 0.5,
      width: cropBox.width + GUIDE_STROKE_WIDTH,
      height: cropBox.height + GUIDE_STROKE_WIDTH
    });
  }
  _createThumbs() {
    let frameThumbs = {};
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        let direction = `${["n", "", "s"][i]}${["w", "", "e"][j]}`;
        let groupNode = createSvgNode("g");
        groupNode.classList.add("thumb");
        groupNode.setAttribute("with-effects", "");
        let interactionNode = createSvgNode("circle", {
          r: THUMB_CORNER_SIZE + THUMB_OFFSET,
          fill: "transparent"
        });
        let pathNode = createSvgNode("path", {
          stroke: "currentColor",
          fill: "none",
          "stroke-width": THUMB_STROKE_WIDTH
        });
        groupNode.appendChild(pathNode);
        groupNode.appendChild(interactionNode);
        frameThumbs[direction] = {
          direction,
          pathNode,
          interactionNode,
          groupNode
        };
        interactionNode.addEventListener("pointerdown", this._handlePointerDown.bind(this, direction));
      }
    }
    return frameThumbs;
  }
  _createGuides() {
    let svg = createSvgNode("svg");
    let rect = createSvgNode("rect", {
      x: 0,
      y: 0,
      width: "100%",
      height: "100%",
      fill: "none",
      stroke: "#000000",
      "stroke-width": GUIDE_STROKE_WIDTH,
      "stroke-opacity": 0.5
    });
    svg.appendChild(rect);
    for (let i = 1; i <= 2; i++) {
      let line = createSvgNode("line", {
        x1: `${GUIDE_THIRD * i}%`,
        y1: `0%`,
        x2: `${GUIDE_THIRD * i}%`,
        y2: `100%`,
        stroke: "#000000",
        "stroke-width": GUIDE_STROKE_WIDTH,
        "stroke-opacity": 0.3
      });
      svg.appendChild(line);
    }
    for (let i = 1; i <= 2; i++) {
      let line = createSvgNode("line", {
        x1: `0%`,
        y1: `${GUIDE_THIRD * i}%`,
        x2: `100%`,
        y2: `${GUIDE_THIRD * i}%`,
        stroke: "#000000",
        "stroke-width": GUIDE_STROKE_WIDTH,
        "stroke-opacity": 0.3
      });
      svg.appendChild(line);
    }
    svg.classList.add("guides", "guides--semi-hidden");
    return svg;
  }
  _createFrame() {
    let svg = this.ref["svg-el"];
    let fr = document.createDocumentFragment();
    let frameGuides = this._createGuides();
    fr.appendChild(frameGuides);
    let frameThumbs = this._createThumbs();
    for (let { groupNode } of Object.values(frameThumbs)) {
      fr.appendChild(groupNode);
    }
    svg.appendChild(fr);
    this._frameThumbs = frameThumbs;
    this._frameGuides = frameGuides;
  }
  _handlePointerDown(direction, e) {
    let thumb = this._frameThumbs[direction];
    if (this._shouldThumbBeDisabled(direction)) {
      return;
    }
    let cropBox = this.$["*cropBox"];
    let { x: svgX, y: svgY } = this.ref["svg-el"].getBoundingClientRect();
    let x = e.x - svgX;
    let y = e.y - svgY;
    this.$.dragging = true;
    this._draggingThumb = thumb;
    this._dragStartPoint = [x, y];
    this._dragStartCrop = { ...cropBox };
  }
  _handlePointerUp_(e) {
    this._updateCursor();
    if (!this.$.dragging) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    this.$.dragging = false;
  }
  _handlePointerMove_(e) {
    if (!this.$.dragging) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    let svg = this.ref["svg-el"];
    let { x: svgX, y: svgY } = svg.getBoundingClientRect();
    let x = e.x - svgX;
    let y = e.y - svgY;
    let dx = x - this._dragStartPoint[0];
    let dy = y - this._dragStartPoint[1];
    let { direction } = this._draggingThumb;
    let imageBox = this.$["*imageBox"];
    let rect = this._dragStartCrop;
    if (direction === "") {
      rect = moveRect(rect, [dx, dy]);
      rect = constraintRect(rect, imageBox);
    } else {
      rect = expandRect(rect, [dx, dy], direction);
      rect = intersectionRect(rect, imageBox);
    }
    let minCropRect = [Math.min(imageBox.width, MIN_CROP_SIZE), Math.min(imageBox.height, MIN_CROP_SIZE)];
    rect = minRectSize(rect, minCropRect, direction);
    if (!Object.values(rect).every((number) => Number.isFinite(number) && number >= 0)) {
      console.error("CropFrame is trying to create invalid rectangle", {
        payload: rect
      });
      return;
    }
    this.$["*cropBox"] = rect;
  }
  _handleSvgPointerMove_(e) {
    let hoverThumb = Object.values(this._frameThumbs).find((thumb) => {
      if (this._shouldThumbBeDisabled(thumb.direction)) {
        return false;
      }
      let node = thumb.groupNode;
      let bounds = node.getBoundingClientRect();
      let rect = {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height
      };
      let hover = rectContainsPoint(rect, [e.x, e.y]);
      return hover;
    });
    this._hoverThumb = hoverThumb;
    this._updateCursor();
  }
  _updateCursor() {
    let hoverThumb = this._hoverThumb;
    this.ref["svg-el"].style.cursor = hoverThumb ? thumbCursor(hoverThumb.direction) : "initial";
  }
  _render() {
    this._updateBackdrop();
    this._updateFrame();
  }
  toggleThumbs(visible) {
    Object.values(this._frameThumbs).map(({ groupNode }) => groupNode).forEach((groupNode) => {
      groupNode.setAttribute(
        "class",
        classNames("thumb", {
          "thumb--hidden": !visible,
          "thumb--visible": visible
        })
      );
    });
  }
  initCallback() {
    super.initCallback();
    this._createBackdrop();
    this._createFrame();
    this.sub("*imageBox", () => {
      this._resizeBackdrop();
      window.requestAnimationFrame(() => {
        this._render();
      });
    });
    this.sub("*cropBox", (cropBox) => {
      if (!cropBox) {
        return;
      }
      this._guidesHidden = cropBox.height <= MIN_CROP_SIZE || cropBox.width <= MIN_CROP_SIZE;
      window.requestAnimationFrame(() => {
        this._render();
      });
    });
    this.sub("dragging", (dragging) => {
      this._frameGuides.setAttribute(
        "class",
        classNames({
          "guides--hidden": this._guidesHidden,
          "guides--visible": !this._guidesHidden && dragging,
          "guides--semi-hidden": !this._guidesHidden && !dragging
        })
      );
    });
    this.ref["svg-el"].addEventListener("pointermove", this._handleSvgPointerMove, true);
    document.addEventListener("pointermove", this._handlePointerMove, true);
    document.addEventListener("pointerup", this._handlePointerUp, true);
  }
  destroyCallback() {
    super.destroyCallback();
    document.removeEventListener("pointermove", this._handlePointerMove);
    document.removeEventListener("pointerup", this._handlePointerUp);
  }
};
CropFrame.template = /* HTML */
` <svg class="svg" ref="svg-el" xmlns="http://www.w3.org/2000/svg"></svg> `;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorButtonControl.js
var EditorButtonControl = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      active: false,
      title: "",
      icon: "",
      "on.click": null
    });
  }
  initCallback() {
    super.initCallback();
    this._titleEl = this.ref["title-el"];
    this._iconEl = this.ref["icon-el"];
    this.setAttribute("role", "button");
    if (this.tabIndex === -1) {
      this.tabIndex = 0;
    }
    this.sub("title", (title) => {
      let titleEl = this._titleEl;
      if (titleEl) {
        this._titleEl.style.display = title ? "block" : "none";
      }
    });
    this.sub("active", (active) => {
      this.className = classNames({
        active,
        not_active: !active
      });
    });
    this.sub("on.click", (onClick) => {
      this.onclick = onClick;
    });
  }
};
EditorButtonControl.template = /* HTML */
`
  <div class="before"></div>
  <lr-icon size="20" set="@name: icon;"></lr-icon>
  <div class="title" ref="title-el">{{title}}</div>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorCropButtonControl.js
function nextAngle(prev) {
  let angle = prev + 90;
  angle = angle >= 360 ? 0 : angle;
  return angle;
}
function nextValue(operation, prev) {
  if (operation === "rotate") {
    return nextAngle(prev);
  }
  if (["mirror", "flip"].includes(operation)) {
    return !prev;
  }
  return null;
}
var EditorCropButtonControl = class extends EditorButtonControl {
  initCallback() {
    super.initCallback();
    this.defineAccessor("operation", (operation) => {
      if (!operation) {
        return;
      }
      this._operation = operation;
      this.$["icon"] = operation;
    });
    this.$["on.click"] = (e) => {
      let prev = this.$["*cropperEl"].getValue(this._operation);
      let next = nextValue(this._operation, prev);
      this.$["*cropperEl"].setValue(this._operation, next);
    };
  }
};

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorSlider.js
var ControlType = {
  FILTER: "filter",
  COLOR_OPERATION: "color_operation"
};
var FAKE_ORIGINAL_FILTER = "original";
var EditorSlider = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      disabled: false,
      min: 0,
      max: 100,
      value: 0,
      defaultValue: 0,
      zero: 0,
      "on.input": (value) => {
        this.$["*faderEl"].set(value);
        this.$.value = value;
      }
    });
  }
  /**
   * @param {String} operation
   * @param {String} [filter]
   */
  setOperation(operation, filter) {
    this._controlType = operation === "filter" ? ControlType.FILTER : ControlType.COLOR_OPERATION;
    this._operation = operation;
    this._iconName = operation;
    this._title = operation.toUpperCase();
    this._filter = filter;
    this._initializeValues();
    this.$["*faderEl"].activate({
      url: this.$["*originalUrl"],
      operation: this._operation,
      value: this._filter === FAKE_ORIGINAL_FILTER ? void 0 : this.$.value,
      filter: this._filter === FAKE_ORIGINAL_FILTER ? void 0 : this._filter,
      fromViewer: false
    });
  }
  /** @private */
  _initializeValues() {
    let { range, zero } = COLOR_OPERATIONS_CONFIG[this._operation];
    let [min, max] = range;
    this.$.min = min;
    this.$.max = max;
    this.$.zero = zero;
    let transformation = this.$["*editorTransformations"][this._operation];
    if (this._controlType === ControlType.FILTER) {
      let value = max;
      if (transformation) {
        let { name, amount } = transformation;
        value = name === this._filter ? amount : max;
      }
      this.$.value = value;
      this.$.defaultValue = value;
    }
    if (this._controlType === ControlType.COLOR_OPERATION) {
      let value = typeof transformation !== "undefined" ? transformation : zero;
      this.$.value = value;
      this.$.defaultValue = value;
    }
  }
  apply() {
    let operationValue;
    if (this._controlType === ControlType.FILTER) {
      if (this._filter === FAKE_ORIGINAL_FILTER) {
        operationValue = null;
      } else {
        operationValue = { name: this._filter, amount: this.$.value };
      }
    } else {
      operationValue = this.$.value;
    }
    let transformations = {
      ...this.$["*editorTransformations"],
      [this._operation]: operationValue
    };
    this.$["*editorTransformations"] = transformations;
  }
  cancel() {
    this.$["*faderEl"].deactivate({ hide: false });
  }
  initCallback() {
    super.initCallback();
    this.sub("*originalUrl", (originalUrl) => {
      this._originalUrl = originalUrl;
    });
    this.sub("value", (value) => {
      let tooltip = `${this._filter || this._operation} ${value}`;
      this.$["*operationTooltip"] = tooltip;
    });
  }
};
EditorSlider.template = /* HTML */
`
  <lr-slider-ui
    ref="slider-el"
    set="disabled: disabled; min: min; max: max; defaultValue: defaultValue; zero: zero; onInput: on.input;"
  ></lr-slider-ui>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/preloadImage.js
function preloadImage(src) {
  let image = new Image();
  let promise = new Promise((resolve, reject) => {
    image.src = src;
    image.onload = resolve;
    image.onerror = reject;
  });
  let cancel = () => {
    if (image.naturalWidth === 0) {
      image.src = TRANSPARENT_PIXEL_SRC;
    }
  };
  return { promise, image, cancel };
}
function batchPreloadImages(list) {
  let preloaders = [];
  for (let src of list) {
    let preload = preloadImage(src);
    preloaders.push(preload);
  }
  let images = preloaders.map((preload) => preload.image);
  let promise = Promise.allSettled(preloaders.map((preload) => preload.promise));
  let cancel = () => {
    preloaders.forEach((preload) => {
      preload.cancel();
    });
  };
  return { promise, images, cancel };
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorFilterControl.js
var EditorFilterControl = class extends EditorButtonControl {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      active: false,
      title: "",
      icon: "",
      isOriginal: false,
      iconSize: "20",
      "on.click": null
    });
  }
  _previewSrc() {
    let previewSize = parseInt(window.getComputedStyle(this).getPropertyValue("--l-base-min-width"), 10);
    let dpr = window.devicePixelRatio;
    let size = Math.ceil(dpr * previewSize);
    let quality = dpr >= 2 ? "lightest" : "normal";
    let filterValue = 100;
    let transformations = { ...this.$["*editorTransformations"] };
    transformations[this._operation] = this._filter !== FAKE_ORIGINAL_FILTER ? {
      name: this._filter,
      amount: filterValue
    } : void 0;
    return createCdnUrl(
      this._originalUrl,
      createCdnUrlModifiers(
        COMMON_OPERATIONS,
        transformationsToOperations(transformations),
        `quality/${quality}`,
        `scale_crop/${size}x${size}/center`
      )
    );
  }
  /**
   * @param {IntersectionObserverEntry[]} entries
   * @param {IntersectionObserver} observer
   */
  _observerCallback(entries, observer) {
    let intersectionEntry = entries[0];
    if (intersectionEntry.isIntersecting) {
      let src = this.proxyUrl(this._previewSrc());
      let previewEl = this.ref["preview-el"];
      let { promise, cancel } = preloadImage(src);
      this._cancelPreload = cancel;
      promise.catch((err) => {
        this.$["*networkProblems"] = true;
        console.error("Failed to load image", { error: err });
      }).finally(() => {
        previewEl.style.backgroundImage = `url(${src})`;
        previewEl.setAttribute("loaded", "");
        observer.unobserve(this);
      });
    } else {
      this._cancelPreload && this._cancelPreload();
    }
  }
  initCallback() {
    super.initCallback();
    this.$["on.click"] = (e) => {
      if (!this.$.active) {
        this.$["*sliderEl"].setOperation(this._operation, this._filter);
        this.$["*sliderEl"].apply();
      } else if (!this.$.isOriginal) {
        this.$["*sliderEl"].setOperation(this._operation, this._filter);
        this.$["*showSlider"] = true;
      }
      this.$["*currentFilter"] = this._filter;
    };
    this.defineAccessor("filter", (filter) => {
      this._operation = "filter";
      this._filter = filter;
      this.$.isOriginal = filter === FAKE_ORIGINAL_FILTER;
      this.$.icon = this.$.isOriginal ? "original" : "slider";
    });
    this._observer = new window.IntersectionObserver(this._observerCallback.bind(this), {
      threshold: [0, 1]
    });
    let originalUrl = this.$["*originalUrl"];
    this._originalUrl = originalUrl;
    if (this.$.isOriginal) {
      this.ref["icon-el"].classList.add("original-icon");
    } else {
      this._observer.observe(this);
    }
    this.sub("*currentFilter", (currentFilter) => {
      this.$.active = currentFilter && currentFilter === this._filter;
    });
    this.sub("isOriginal", (isOriginal) => {
      this.$.iconSize = isOriginal ? 40 : 20;
    });
    this.sub("active", (active) => {
      if (this.$.isOriginal) {
        return;
      }
      let iconEl = this.ref["icon-el"];
      iconEl.style.opacity = active ? "1" : "0";
      let previewEl = this.ref["preview-el"];
      if (active) {
        previewEl.style.opacity = "0";
      } else if (previewEl.style.backgroundImage) {
        previewEl.style.opacity = "1";
      }
    });
    this.sub("*networkProblems", (networkProblems) => {
      if (!networkProblems) {
        let src = this.proxyUrl(this._previewSrc());
        let previewEl = this.ref["preview-el"];
        if (previewEl.style.backgroundImage) {
          previewEl.style.backgroundImage = "none";
          previewEl.style.backgroundImage = `url(${src})`;
        }
      }
    });
  }
  destroyCallback() {
    var _a2;
    super.destroyCallback();
    (_a2 = this._observer) == null ? void 0 : _a2.disconnect();
    this._cancelPreload && this._cancelPreload();
  }
};
EditorFilterControl.template = /* HTML */
`
  <div class="before"></div>
  <div class="preview" ref="preview-el"></div>
  <lr-icon size="40" ref="icon-el" set="@name: icon; @size: iconSize;"></lr-icon>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorOperationControl.js
var EditorOperationControl = class extends EditorButtonControl {
  constructor() {
    super(...arguments);
    /**
     * @private
     * @type {String}
     */
    __publicField(this, "_operation", "");
  }
  initCallback() {
    super.initCallback();
    this.$["on.click"] = (e) => {
      this.$["*sliderEl"].setOperation(this._operation);
      this.$["*showSlider"] = true;
      this.$["*currentOperation"] = this._operation;
    };
    this.defineAccessor("operation", (operation) => {
      if (operation) {
        this._operation = operation;
        this.$["icon"] = operation;
        this.$.title = this.l10n(operation);
      }
    });
    this.sub("*editorTransformations", (editorTransformations) => {
      if (!this._operation) {
        return;
      }
      let { zero } = COLOR_OPERATIONS_CONFIG[this._operation];
      let value = editorTransformations[this._operation];
      let isActive = typeof value !== "undefined" ? value !== zero : false;
      this.$.active = isActive;
    });
  }
};

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/pick.js
function pick(obj, keys) {
  let result = {};
  for (let key of keys) {
    let value = obj[key];
    if (obj.hasOwnProperty(key) || value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/util.js
function viewerImageSrc(originalUrl, width, transformations) {
  const MAX_CDN_DIMENSION = 3e3;
  let dpr = window.devicePixelRatio;
  let size = Math.min(Math.ceil(width * dpr), MAX_CDN_DIMENSION);
  let quality = dpr >= 2 ? "lightest" : "normal";
  return createCdnUrl(
    originalUrl,
    createCdnUrlModifiers(
      COMMON_OPERATIONS,
      transformationsToOperations(transformations),
      `quality/${quality}`,
      `stretch/off/-/resize/${size}x`
    )
  );
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorImageCropper.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function rotateSize({ width, height }, angle) {
  let swap = angle / 90 % 2 !== 0;
  return { width: swap ? height : width, height: swap ? width : height };
}
function validateCrop(crop) {
  if (!crop) {
    return true;
  }
  let shouldMatch = [
    ({ dimensions, coords }) => [...dimensions, ...coords].every((number) => Number.isInteger(number) && Number.isFinite(number)),
    ({ dimensions, coords }) => dimensions.every((d) => d > 0) && coords.every((c) => c >= 0)
  ];
  return shouldMatch.every((matcher) => matcher(crop));
}
var EditorImageCropper = class extends Block {
  constructor() {
    super();
    __publicField(this, "init$", {
      ...this.ctxInit,
      image: null,
      "*padding": CROP_PADDING,
      /** @type {Operations} */
      "*operations": {
        rotate: 0,
        mirror: false,
        flip: false
      },
      /** @type {import('./types.js').Rectangle} */
      "*imageBox": {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      /** @type {import('./types.js').Rectangle} */
      "*cropBox": {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    });
    this._commitDebounced = debounce2(this._commit.bind(this), 300);
    this._handleResizeDebounced = debounce2(this._handleResize.bind(this), 10);
  }
  /** @private */
  _handleResize() {
    if (!this.isConnected) {
      return;
    }
    this.deactivate();
    this.activate(this._imageSize, { fromViewer: false });
  }
  /** @private */
  _syncTransformations() {
    let transformations = this.$["*editorTransformations"];
    let pickedTransformations = pick(transformations, Object.keys(this.$["*operations"]));
    let operations = { ...this.$["*operations"], ...pickedTransformations };
    this.$["*operations"] = operations;
  }
  /** @private */
  _initCanvas() {
    let canvas = this.ref["canvas-el"];
    let ctx = canvas.getContext("2d");
    let width = this.offsetWidth;
    let height = this.offsetHeight;
    let dpr = window.devicePixelRatio;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    this._canvas = canvas;
    this._ctx = ctx;
  }
  /** @private */
  _alignImage() {
    if (!this._isActive || !this.$.image) {
      return;
    }
    let image = this.$.image;
    let padding = this.$["*padding"];
    let operations = this.$["*operations"];
    let { rotate } = operations;
    let bounds = { width: this.offsetWidth, height: this.offsetHeight };
    let naturalSize = rotateSize({ width: image.naturalWidth, height: image.naturalHeight }, rotate);
    if (naturalSize.width > bounds.width - padding * 2 || naturalSize.height > bounds.height - padding * 2) {
      let imageAspectRatio = naturalSize.width / naturalSize.height;
      let viewportAspectRatio = bounds.width / bounds.height;
      if (imageAspectRatio > viewportAspectRatio) {
        let width = bounds.width - padding * 2;
        let height = width / imageAspectRatio;
        let x = 0 + padding;
        let y = padding + (bounds.height - padding * 2) / 2 - height / 2;
        this.$["*imageBox"] = { x, y, width, height };
      } else {
        let height = bounds.height - padding * 2;
        let width = height * imageAspectRatio;
        let x = padding + (bounds.width - padding * 2) / 2 - width / 2;
        let y = 0 + padding;
        this.$["*imageBox"] = { x, y, width, height };
      }
    } else {
      let { width, height } = naturalSize;
      let x = padding + (bounds.width - padding * 2) / 2 - width / 2;
      let y = padding + (bounds.height - padding * 2) / 2 - height / 2;
      this.$["*imageBox"] = { x, y, width, height };
    }
  }
  /** @private */
  _alignCrop() {
    let cropBox = this.$["*cropBox"];
    let imageBox = this.$["*imageBox"];
    let operations = this.$["*operations"];
    let { rotate } = operations;
    let transformation = this.$["*editorTransformations"]["crop"];
    if (transformation) {
      let {
        dimensions: [width, height],
        coords: [x, y]
      } = transformation;
      let { width: previewWidth, x: previewX, y: previewY } = this.$["*imageBox"];
      let { width: sourceWidth } = rotateSize(this._imageSize, rotate);
      let ratio = previewWidth / sourceWidth;
      cropBox = {
        x: previewX + x * ratio,
        y: previewY + y * ratio,
        width: width * ratio,
        height: height * ratio
      };
    } else {
      cropBox = {
        x: imageBox.x,
        y: imageBox.y,
        width: imageBox.width,
        height: imageBox.height
      };
    }
    let minCropRect = [Math.min(imageBox.width, MIN_CROP_SIZE), Math.min(imageBox.height, MIN_CROP_SIZE)];
    cropBox = minRectSize(cropBox, minCropRect, "se");
    cropBox = constraintRect(cropBox, imageBox);
    this.$["*cropBox"] = cropBox;
  }
  /** @private */
  _drawImage() {
    let image = this.$.image;
    let imageBox = this.$["*imageBox"];
    let operations = this.$["*operations"];
    let { mirror, flip, rotate } = operations;
    let ctx = this._ctx;
    let rotated = rotateSize({ width: imageBox.width, height: imageBox.height }, rotate);
    ctx.save();
    ctx.translate(imageBox.x + imageBox.width / 2, imageBox.y + imageBox.height / 2);
    ctx.rotate(rotate * Math.PI * -1 / 180);
    ctx.scale(mirror ? -1 : 1, flip ? -1 : 1);
    ctx.drawImage(image, -rotated.width / 2, -rotated.height / 2, rotated.width, rotated.height);
    ctx.restore();
  }
  /** @private */
  _draw() {
    if (!this._isActive || !this.$.image) {
      return;
    }
    let canvas = this._canvas;
    let ctx = this._ctx;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    this._drawImage();
  }
  /** @private */
  _animateIn({ fromViewer }) {
    if (this.$.image) {
      this.ref["frame-el"].toggleThumbs(true);
      this._transitionToImage();
      setTimeout(() => {
        this.className = classNames({
          active_from_viewer: fromViewer,
          active_from_editor: !fromViewer,
          inactive_to_editor: false
        });
      });
    }
  }
  /**
   * @private
   * @returns {import('./types.js').Transformations['crop']['dimensions']}
   */
  _calculateDimensions() {
    let cropBox = this.$["*cropBox"];
    let imageBox = this.$["*imageBox"];
    let operations = this.$["*operations"];
    let { rotate } = operations;
    let { width: previewWidth, height: previewHeight } = imageBox;
    let { width: sourceWidth, height: sourceHeight } = rotateSize(this._imageSize, rotate);
    let { width: cropWidth, height: cropHeight } = cropBox;
    let ratioW = previewWidth / sourceWidth;
    let ratioH = previewHeight / sourceHeight;
    let dimensions = [
      clamp(Math.round(cropWidth / ratioW), 1, sourceWidth),
      clamp(Math.round(cropHeight / ratioH), 1, sourceHeight)
    ];
    return dimensions;
  }
  /**
   * @private
   * @returns {import('./types.js').Transformations['crop']}
   */
  _calculateCrop() {
    let cropBox = this.$["*cropBox"];
    let imageBox = this.$["*imageBox"];
    let operations = this.$["*operations"];
    let { rotate } = operations;
    let { width: previewWidth, height: previewHeight, x: previewX, y: previewY } = imageBox;
    let { width: sourceWidth, height: sourceHeight } = rotateSize(this._imageSize, rotate);
    let { x: cropX, y: cropY } = cropBox;
    let ratioW = previewWidth / sourceWidth;
    let ratioH = previewHeight / sourceHeight;
    let dimensions = this._calculateDimensions();
    let crop = {
      dimensions,
      coords: (
        /** @type {[Number, Number]} */
        [
          clamp(Math.round((cropX - previewX) / ratioW), 0, sourceWidth - dimensions[0]),
          clamp(Math.round((cropY - previewY) / ratioH), 0, sourceHeight - dimensions[1])
        ]
      )
    };
    if (!validateCrop(crop)) {
      console.error("Cropper is trying to create invalid crop object", {
        payload: crop
      });
      return void 0;
    }
    if (dimensions[0] === sourceWidth && dimensions[1] === sourceHeight) {
      return void 0;
    }
    return crop;
  }
  /** @private */
  _commit() {
    if (!this.isConnected) {
      return;
    }
    let operations = this.$["*operations"];
    let { rotate, mirror, flip } = operations;
    let crop = this._calculateCrop();
    let editorTransformations = this.$["*editorTransformations"];
    let transformations = {
      ...editorTransformations,
      crop,
      rotate,
      mirror,
      flip
    };
    this.$["*editorTransformations"] = transformations;
  }
  /**
   * @param {String} operation
   * @param {Number} value
   * @returns {void}
   */
  setValue(operation, value) {
    console.log(`Apply cropper operation [${operation}=${value}]`);
    this.$["*operations"] = {
      ...this.$["*operations"],
      [operation]: value
    };
    if (!this._isActive) {
      return;
    }
    this._alignImage();
    this._alignCrop();
    this._draw();
  }
  /**
   * @param {keyof Operations} operation
   * @returns {Number | boolean}
   */
  getValue(operation) {
    return this.$["*operations"][operation];
  }
  /**
   * @param {import('./types.js').ImageSize} imageSize
   * @param {{ fromViewer?: boolean }} options
   */
  async activate(imageSize, { fromViewer }) {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    this._imageSize = imageSize;
    this.removeEventListener("transitionend", this._reset);
    this._initCanvas();
    try {
      this.$.image = await this._waitForImage(this.$["*originalUrl"], this.$["*editorTransformations"]);
      this._syncTransformations();
      this._alignImage();
      this._alignCrop();
      this._draw();
      this._animateIn({ fromViewer });
    } catch (err) {
      console.error("Failed to activate cropper", { error: err });
    }
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._commit();
    this._isActive = false;
    this._transitionToCrop();
    this.className = classNames({
      active_from_viewer: false,
      active_from_editor: false,
      inactive_to_editor: true
    });
    this.ref["frame-el"].toggleThumbs(false);
    this.addEventListener("transitionend", this._reset, { once: true });
  }
  /** @private */
  _transitionToCrop() {
    let dimensions = this._calculateDimensions();
    let scaleX = Math.min(this.offsetWidth, dimensions[0]) / this.$["*cropBox"].width;
    let scaleY = Math.min(this.offsetHeight, dimensions[1]) / this.$["*cropBox"].height;
    let scale = Math.min(scaleX, scaleY);
    let cropCenterX = this.$["*cropBox"].x + this.$["*cropBox"].width / 2;
    let cropCenterY = this.$["*cropBox"].y + this.$["*cropBox"].height / 2;
    this.style.transform = `scale(${scale}) translate(${(this.offsetWidth / 2 - cropCenterX) / scale}px, ${(this.offsetHeight / 2 - cropCenterY) / scale}px)`;
    this.style.transformOrigin = `${cropCenterX}px ${cropCenterY}px`;
  }
  /** @private */
  _transitionToImage() {
    let cropCenterX = this.$["*cropBox"].x + this.$["*cropBox"].width / 2;
    let cropCenterY = this.$["*cropBox"].y + this.$["*cropBox"].height / 2;
    this.style.transform = `scale(1)`;
    this.style.transformOrigin = `${cropCenterX}px ${cropCenterY}px`;
  }
  /** @private */
  _reset() {
    if (this._isActive) {
      return;
    }
    this.$.image = null;
  }
  /**
   * @private
   * @param {String} originalUrl
   * @param {import('./types.js').Transformations} transformations
   * @returns {Promise<HTMLImageElement>}
   */
  _waitForImage(originalUrl, transformations) {
    let width = this.offsetWidth;
    transformations = {
      ...transformations,
      crop: void 0,
      rotate: void 0,
      flip: void 0,
      mirror: void 0
    };
    let src = this.proxyUrl(viewerImageSrc(originalUrl, width, transformations));
    let { promise, cancel, image } = preloadImage(src);
    let stop = this._handleImageLoading(src);
    image.addEventListener("load", stop, { once: true });
    image.addEventListener("error", stop, { once: true });
    this._cancelPreload && this._cancelPreload();
    this._cancelPreload = cancel;
    return promise.then(() => image).catch((err) => {
      console.error("Failed to load image", { error: err });
      this.$["*networkProblems"] = true;
      return Promise.resolve(image);
    });
  }
  /**
   * @private
   * @param {String} src
   * @returns {() => void} Destructor
   */
  _handleImageLoading(src) {
    let operation = "crop";
    let loadingOperations = this.$["*loadingOperations"];
    if (!loadingOperations.get(operation)) {
      loadingOperations.set(operation, /* @__PURE__ */ new Map());
    }
    if (!loadingOperations.get(operation).get(src)) {
      loadingOperations.set(operation, loadingOperations.get(operation).set(src, true));
      this.$["*loadingOperations"] = loadingOperations;
    }
    return () => {
      var _a2;
      if ((_a2 = loadingOperations == null ? void 0 : loadingOperations.get(operation)) == null ? void 0 : _a2.has(src)) {
        loadingOperations.get(operation).delete(src);
        this.$["*loadingOperations"] = loadingOperations;
      }
    };
  }
  initCallback() {
    super.initCallback();
    this._observer = new ResizeObserver(([entry]) => {
      const nonZeroSize = entry.contentRect.width > 0 && entry.contentRect.height > 0;
      if (nonZeroSize && this._isActive && this.$.image) {
        this._handleResizeDebounced();
      }
    });
    this._observer.observe(this);
    this.sub("*imageBox", () => {
      this._draw();
    });
    this.sub("*cropBox", (cropBox) => {
      if (this.$.image) {
        this._commitDebounced();
      }
    });
    setTimeout(() => {
      this.sub("*networkProblems", (networkProblems) => {
        if (!networkProblems) {
          this._isActive && this.activate(this._imageSize, { fromViewer: false });
        }
      });
    }, 0);
  }
  destroyCallback() {
    var _a2;
    super.destroyCallback();
    (_a2 = this._observer) == null ? void 0 : _a2.disconnect();
  }
};
EditorImageCropper.template = /* HTML */
`
  <canvas class="canvas" ref="canvas-el"></canvas>
  <lr-crop-frame ref="frame-el"></lr-crop-frame>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/lib/linspace.js
function linspace(a, b, n) {
  let ret = Array(n);
  n--;
  for (let i = n; i >= 0; i--) {
    ret[i] = Math.ceil((i * b + (n - i) * a) / n);
  }
  return ret;
}

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorImageFader.js
function splitBySections(numbers) {
  return numbers.reduce(
    (acc, point, idx) => idx < numbers.length - 1 ? [...acc, [point, numbers[idx + 1]]] : acc,
    []
  );
}
function calculateOpacities(keypoints, value, zero) {
  let section = splitBySections(keypoints).find(([left, right]) => left <= value && value <= right);
  return keypoints.map((point) => {
    let distance2 = Math.abs(section[0] - section[1]);
    let relation = Math.abs(value - section[0]) / distance2;
    if (section[0] === point) {
      return value > zero ? 1 : 1 - relation;
    }
    if (section[1] === point) {
      return value >= zero ? relation : 1;
    }
    return 0;
  });
}
function calculateZIndices(keypoints, zero) {
  return keypoints.map((point, idx) => point < zero ? keypoints.length - idx : idx);
}
function keypointsRange(operation, value) {
  let n = COLOR_OPERATIONS_CONFIG[operation].keypointsNumber;
  let { range, zero } = COLOR_OPERATIONS_CONFIG[operation];
  return [.../* @__PURE__ */ new Set([...linspace(range[0], zero, n + 1), ...linspace(zero, range[1], n + 1), zero, value])].sort(
    (a, b) => a - b
  );
}
var EditorImageFader = class extends Block {
  constructor() {
    super();
    this._isActive = false;
    this._hidden = true;
    this._addKeypointDebounced = debounce2(this._addKeypoint.bind(this), 600);
    this.classList.add("inactive_to_cropper");
  }
  /**
   * @private
   * @param {String} src
   * @returns {() => void} Destructor
   */
  _handleImageLoading(src) {
    let operation = this._operation;
    let loadingOperations = this.$["*loadingOperations"];
    if (!loadingOperations.get(operation)) {
      loadingOperations.set(operation, /* @__PURE__ */ new Map());
    }
    if (!loadingOperations.get(operation).get(src)) {
      loadingOperations.set(operation, loadingOperations.get(operation).set(src, true));
      this.$["*loadingOperations"] = loadingOperations;
    }
    return () => {
      var _a2;
      if ((_a2 = loadingOperations == null ? void 0 : loadingOperations.get(operation)) == null ? void 0 : _a2.has(src)) {
        loadingOperations.get(operation).delete(src);
        this.$["*loadingOperations"] = loadingOperations;
      }
    };
  }
  /** @private */
  _flush() {
    window.cancelAnimationFrame(this._raf);
    this._raf = window.requestAnimationFrame(() => {
      for (let kp of this._keypoints) {
        let { image } = kp;
        if (image) {
          image.style.opacity = kp.opacity.toString();
          image.style.zIndex = kp.zIndex.toString();
        }
      }
    });
  }
  /**
   * @private
   * @param {Object} options
   * @param {String} [options.url]
   * @param {String} [options.filter]
   * @param {String} [options.operation]
   * @param {Number} [options.value]
   * @returns {String}
   */
  _imageSrc({ url = this._url, filter = this._filter, operation, value } = {}) {
    let transformations = { ...this._transformations };
    if (operation) {
      transformations[operation] = filter ? { name: filter, amount: value } : value;
    }
    let width = this.offsetWidth;
    return this.proxyUrl(viewerImageSrc(url, width, transformations));
  }
  /**
   * @private
   * @param {String} operation
   * @param {Number} value
   * @returns {Keypoint}
   */
  _constructKeypoint(operation, value) {
    let src = this._imageSrc({ operation, value });
    return {
      src,
      image: null,
      opacity: 0,
      zIndex: 0,
      value
    };
  }
  /**
   * Check if current operation and filter equals passed ones
   *
   * @private
   * @param {String} operation
   * @param {String} [filter]
   * @returns {Boolean}
   */
  _isSame(operation, filter) {
    return this._operation === operation && this._filter === filter;
  }
  /**
   * @private
   * @param {String} operation
   * @param {String | null} filter
   * @param {Number} value
   */
  _addKeypoint(operation, filter, value) {
    let shouldSkip = () => !this._isSame(operation, filter) || this._value !== value || !!this._keypoints.find((kp) => kp.value === value);
    if (shouldSkip()) {
      return;
    }
    let keypoint = this._constructKeypoint(operation, value);
    let image = new Image();
    image.src = keypoint.src;
    let stop = this._handleImageLoading(keypoint.src);
    image.addEventListener("load", stop, { once: true });
    image.addEventListener("error", stop, { once: true });
    keypoint.image = image;
    image.classList.add("fader-image");
    image.addEventListener(
      "load",
      () => {
        if (shouldSkip()) {
          return;
        }
        let keypoints = this._keypoints;
        let idx = keypoints.findIndex((kp) => kp.value > value);
        let insertBeforeNode = idx < keypoints.length ? keypoints[idx].image : null;
        if (!this._container || insertBeforeNode && !this._container.contains(insertBeforeNode)) {
          return;
        }
        keypoints.splice(idx, 0, keypoint);
        this._container.insertBefore(image, insertBeforeNode);
        this._update(operation, value);
      },
      { once: true }
    );
    image.addEventListener(
      "error",
      () => {
        this.$["*networkProblems"] = true;
      },
      { once: true }
    );
  }
  /** @param {String | Number} value */
  set(value) {
    value = typeof value === "string" ? parseInt(value, 10) : value;
    this._update(this._operation, value);
    this._addKeypointDebounced(this._operation, this._filter, value);
  }
  /**
   * @private
   * @param {String} operation
   * @param {Number} value
   */
  _update(operation, value) {
    this._operation = operation;
    this._value = value;
    let { zero } = COLOR_OPERATIONS_CONFIG[operation];
    let keypointValues = this._keypoints.map((kp) => kp.value);
    let opacities = calculateOpacities(keypointValues, value, zero);
    let zIndices = calculateZIndices(keypointValues, zero);
    for (let [idx, kp] of Object.entries(this._keypoints)) {
      kp.opacity = opacities[idx];
      kp.zIndex = zIndices[idx];
    }
    this._flush();
  }
  /** @private */
  _createPreviewImage() {
    let image = new Image();
    image.classList.add("fader-image", "fader-image--preview");
    image.style.opacity = "0";
    return image;
  }
  /** @private */
  async _initNodes() {
    let fr = document.createDocumentFragment();
    this._previewImage = this._previewImage || this._createPreviewImage();
    !this.contains(this._previewImage) && fr.appendChild(this._previewImage);
    let container = document.createElement("div");
    fr.appendChild(container);
    let srcList = this._keypoints.map((kp) => kp.src);
    let { images, promise, cancel } = batchPreloadImages(srcList);
    images.forEach((node) => {
      let stop = this._handleImageLoading(node.src);
      node.addEventListener("load", stop);
      node.addEventListener("error", stop);
    });
    this._cancelLastImages = () => {
      cancel();
      this._cancelLastImages = void 0;
    };
    let operation = this._operation;
    let filter = this._filter;
    await promise;
    if (this._isActive && this._isSame(operation, filter)) {
      this._container && this._container.remove();
      this._container = container;
      this._keypoints.forEach((kp, idx) => {
        let kpImage = images[idx];
        kpImage.classList.add("fader-image");
        kp.image = kpImage;
        this._container.appendChild(kpImage);
      });
      this.appendChild(fr);
      this._flush();
    }
  }
  /** @param {import('./types.js').Transformations} transformations */
  setTransformations(transformations) {
    this._transformations = transformations;
    if (this._previewImage) {
      let src = this._imageSrc();
      let stop = this._handleImageLoading(src);
      this._previewImage.src = src;
      this._previewImage.addEventListener("load", stop, { once: true });
      this._previewImage.addEventListener("error", stop, { once: true });
      this._previewImage.style.opacity = "1";
      this._previewImage.addEventListener(
        "error",
        () => {
          this.$["*networkProblems"] = true;
        },
        { once: true }
      );
    }
  }
  /**
   * @param {object} options
   * @param {String} options.url
   * @param {String} options.operation
   * @param {Number} options.value
   * @param {String} [options.filter]
   */
  preload({ url, filter, operation, value }) {
    this._cancelBatchPreload && this._cancelBatchPreload();
    let keypoints = keypointsRange(operation, value);
    let srcList = keypoints.map((kp) => this._imageSrc({ url, filter, operation, value: kp }));
    let { cancel } = batchPreloadImages(srcList);
    this._cancelBatchPreload = cancel;
  }
  /** @private */
  _setOriginalSrc(src) {
    let image = this._previewImage || this._createPreviewImage();
    !this.contains(image) && this.appendChild(image);
    this._previewImage = image;
    if (image.src === src) {
      image.style.opacity = "1";
      image.style.transform = "scale(1)";
      this.className = classNames({
        active_from_viewer: this._fromViewer,
        active_from_cropper: !this._fromViewer,
        inactive_to_cropper: false
      });
      return;
    }
    image.style.opacity = "0";
    let stop = this._handleImageLoading(src);
    image.addEventListener("error", stop, { once: true });
    image.src = src;
    image.addEventListener(
      "load",
      () => {
        stop();
        if (image) {
          image.style.opacity = "1";
          image.style.transform = "scale(1)";
          this.className = classNames({
            active_from_viewer: this._fromViewer,
            active_from_cropper: !this._fromViewer,
            inactive_to_cropper: false
          });
        }
      },
      { once: true }
    );
    image.addEventListener(
      "error",
      () => {
        this.$["*networkProblems"] = true;
      },
      { once: true }
    );
  }
  /**
   * @param {object} options
   * @param {String} options.url
   * @param {String} [options.operation]
   * @param {Number} [options.value]
   * @param {String} [options.filter]
   * @param {Boolean} [options.fromViewer]
   */
  activate({ url, operation, value, filter, fromViewer }) {
    this._isActive = true;
    this._hidden = false;
    this._url = url;
    this._operation = operation || "initial";
    this._value = value;
    this._filter = filter;
    this._fromViewer = fromViewer;
    let isOriginal = typeof value !== "number" && !filter;
    if (isOriginal) {
      let src = this._imageSrc({ operation, value });
      this._setOriginalSrc(src);
      this._container && this._container.remove();
      return;
    }
    this._keypoints = keypointsRange(operation, value).map((keyValue) => this._constructKeypoint(operation, keyValue));
    this._update(operation, value);
    this._initNodes();
  }
  /** @param {{ hide?: Boolean }} options */
  deactivate({ hide = true } = {}) {
    this._isActive = false;
    this._cancelLastImages && this._cancelLastImages();
    this._cancelBatchPreload && this._cancelBatchPreload();
    if (hide && !this._hidden) {
      this._hidden = true;
      if (this._previewImage) {
        this._previewImage.style.transform = "scale(1)";
      }
      this.className = classNames({
        active_from_viewer: false,
        active_from_cropper: false,
        inactive_to_cropper: true
      });
      this.addEventListener(
        "transitionend",
        () => {
          this._container && this._container.remove();
        },
        { once: true }
      );
    } else {
      this._container && this._container.remove();
    }
  }
};

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorScroller.js
var X_THRESHOLD = 1;
var EditorScroller = class extends Block {
  initCallback() {
    super.initCallback();
    this.addEventListener("wheel", (e) => {
      e.preventDefault();
      let { deltaY, deltaX } = e;
      if (Math.abs(deltaX) > X_THRESHOLD) {
        this.scrollLeft += deltaX;
      } else {
        this.scrollLeft += deltaY;
      }
    });
  }
};
EditorScroller.template = /* HTML */
` <slot></slot> `;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/EditorToolbar.js
function renderTabToggle(id) {
  return (
    /* HTML */
    `
    <lr-btn-ui
      theme="boring"
      ref="tab-toggle-${id}"
      data-id="${id}"
      icon="${id}"
      tabindex="0"
      set="onclick: on.clickTab;"
    >
    </lr-btn-ui>
  `
  );
}
function renderTabContent(id) {
  return (
    /* HTML */
    `
    <lr-presence-toggle class="tab-content" set="visible: presence.tabContent.${id}; styles: presence.tabContentStyles">
      <lr-editor-scroller hidden-scrollbar>
        <div class="controls-list_align">
          <div class="controls-list_inner" ref="controls-list-${id}"></div>
        </div>
      </lr-editor-scroller>
    </lr-presence-toggle>
  `
  );
}
var EditorToolbar = class extends Block {
  constructor() {
    super();
    __publicField(this, "_updateInfoTooltip", debounce2(() => {
      var _a2, _b;
      let transformations = this.$["*editorTransformations"];
      let text = "";
      let visible = false;
      if (this.$["*tabId"] === TabId.FILTERS) {
        visible = true;
        if (this.$["*currentFilter"] && ((_a2 = transformations == null ? void 0 : transformations.filter) == null ? void 0 : _a2.name) === this.$["*currentFilter"]) {
          let value = ((_b = transformations == null ? void 0 : transformations.filter) == null ? void 0 : _b.amount) || 100;
          text = this.l10n(this.$["*currentFilter"]) + " " + value;
        } else {
          text = this.l10n(FAKE_ORIGINAL_FILTER);
        }
      } else if (this.$["*tabId"] === TabId.SLIDERS && this.$["*currentOperation"]) {
        visible = true;
        let value = (transformations == null ? void 0 : transformations[this.$["*currentOperation"]]) || COLOR_OPERATIONS_CONFIG[this.$["*currentOperation"]].zero;
        text = this.$["*currentOperation"] + " " + value;
      }
      if (visible) {
        this.$["*operationTooltip"] = text;
      }
      this.ref["tooltip-el"].classList.toggle("info-tooltip_visible", visible);
    }, 0));
    this.init$ = {
      ...this.ctxInit,
      "*sliderEl": null,
      /** @type {import('./types.js').LoadingOperations} */
      "*loadingOperations": /* @__PURE__ */ new Map(),
      "*showSlider": false,
      "*currentFilter": FAKE_ORIGINAL_FILTER,
      "*currentOperation": null,
      "*tabId": TabId.CROP,
      showLoader: false,
      filters: ALL_FILTERS,
      colorOperations: ALL_COLOR_OPERATIONS,
      cropOperations: ALL_CROP_OPERATIONS,
      "*operationTooltip": null,
      "l10n.cancel": this.l10n("cancel"),
      "l10n.apply": this.l10n("apply"),
      "presence.mainToolbar": true,
      "presence.subToolbar": false,
      "presence.tabContent.crop": false,
      "presence.tabContent.sliders": false,
      "presence.tabContent.filters": false,
      "presence.subTopToolbarStyles": {
        hidden: "sub-toolbar--top-hidden",
        visible: "sub-toolbar--visible"
      },
      "presence.subBottomToolbarStyles": {
        hidden: "sub-toolbar--bottom-hidden",
        visible: "sub-toolbar--visible"
      },
      "presence.tabContentStyles": {
        hidden: "tab-content--hidden",
        visible: "tab-content--visible"
      },
      "on.cancel": (e) => {
        this._cancelPreload && this._cancelPreload();
        this.$["*on.cancel"]();
      },
      "on.apply": (e) => {
        this.$["*on.apply"](this.$["*editorTransformations"]);
      },
      "on.applySlider": (e) => {
        this.ref["slider-el"].apply();
        this._onSliderClose();
      },
      "on.cancelSlider": (e) => {
        this.ref["slider-el"].cancel();
        this._onSliderClose();
      },
      "on.clickTab": (e) => {
        let id = e.currentTarget.getAttribute("data-id");
        this._activateTab(id, { fromViewer: false });
      }
    };
    this._debouncedShowLoader = debounce2(this._showLoader.bind(this), 500);
  }
  /** @private */
  _onSliderClose() {
    this.$["*showSlider"] = false;
    if (this.$["*tabId"] === TabId.SLIDERS) {
      this.ref["tooltip-el"].classList.toggle("info-tooltip_visible", false);
    }
  }
  /**
   * @private
   * @param {String} operation
   */
  _createOperationControl(operation) {
    let el = EditorOperationControl.is && new EditorOperationControl();
    el["operation"] = operation;
    return el;
  }
  /**
   * @private
   * @param {String} filter
   */
  _createFilterControl(filter) {
    let el = EditorFilterControl.is && new EditorFilterControl();
    el["filter"] = filter;
    return el;
  }
  /**
   * @private
   * @param {String} operation
   */
  _createToggleControl(operation) {
    let el = EditorCropButtonControl.is && new EditorCropButtonControl();
    el["operation"] = operation;
    return el;
  }
  /**
   * @private
   * @param {String} tabId
   */
  _renderControlsList(tabId) {
    let listEl = this.ref[`controls-list-${tabId}`];
    let fr = document.createDocumentFragment();
    if (tabId === TabId.CROP) {
      this.$.cropOperations.forEach((operation) => {
        let el = this._createToggleControl(operation);
        fr.appendChild(el);
      });
    } else if (tabId === TabId.FILTERS) {
      [FAKE_ORIGINAL_FILTER, ...this.$.filters].forEach((filterId) => {
        let el = this._createFilterControl(filterId);
        fr.appendChild(el);
      });
    } else if (tabId === TabId.SLIDERS) {
      this.$.colorOperations.forEach((operation) => {
        let el = this._createOperationControl(operation);
        fr.appendChild(el);
      });
    }
    fr.childNodes.forEach((el, idx) => {
      if (idx === fr.childNodes.length - 1) {
        el.classList.add("controls-list_last-item");
      }
    });
    listEl.innerHTML = "";
    listEl.appendChild(fr);
  }
  /**
   * @private
   * @param {String} id
   * @param {{ fromViewer?: Boolean }} options
   */
  _activateTab(id, { fromViewer }) {
    this.$["*tabId"] = id;
    if (id === TabId.CROP) {
      this.$["*faderEl"].deactivate();
      this.$["*cropperEl"].activate(this.$["*imageSize"], { fromViewer });
    } else {
      this.$["*faderEl"].activate({ url: this.$["*originalUrl"], fromViewer });
      this.$["*cropperEl"].deactivate();
    }
    for (let tabId of TABS) {
      let isCurrentTab = tabId === id;
      let tabToggleEl = this.ref[`tab-toggle-${tabId}`];
      tabToggleEl.active = isCurrentTab;
      if (isCurrentTab) {
        this._renderControlsList(id);
        this._syncTabIndicator();
      } else {
        this._unmountTabControls(tabId);
      }
      this.$[`presence.tabContent.${tabId}`] = isCurrentTab;
    }
  }
  /**
   * @private
   * @param {String} tabId
   */
  _unmountTabControls(tabId) {
    let listEl = this.ref[`controls-list-${tabId}`];
    if (listEl) {
      listEl.innerHTML = "";
    }
  }
  /** @private */
  _syncTabIndicator() {
    let tabToggleEl = this.ref[`tab-toggle-${this.$["*tabId"]}`];
    let indicatorEl = this.ref["tabs-indicator"];
    indicatorEl.style.transform = `translateX(${tabToggleEl.offsetLeft}px)`;
  }
  /** @private */
  _preloadEditedImage() {
    if (this.$["*imgContainerEl"] && this.$["*originalUrl"]) {
      let width = this.$["*imgContainerEl"].offsetWidth;
      let src = this.proxyUrl(viewerImageSrc(this.$["*originalUrl"], width, this.$["*editorTransformations"]));
      this._cancelPreload && this._cancelPreload();
      let { cancel } = batchPreloadImages([src]);
      this._cancelPreload = () => {
        cancel();
        this._cancelPreload = void 0;
      };
    }
  }
  /** @private */
  _showLoader(show) {
    this.$.showLoader = show;
  }
  initCallback() {
    super.initCallback();
    this.$["*sliderEl"] = this.ref["slider-el"];
    this.sub("*imageSize", (imageSize) => {
      if (imageSize) {
        setTimeout(() => {
          this._activateTab(this.$["*tabId"], { fromViewer: true });
        }, 0);
      }
    });
    this.sub("*editorTransformations", (editorTransformations) => {
      var _a2;
      let appliedFilter = (_a2 = editorTransformations == null ? void 0 : editorTransformations.filter) == null ? void 0 : _a2.name;
      if (this.$["*currentFilter"] !== appliedFilter) {
        this.$["*currentFilter"] = appliedFilter;
      }
    });
    this.sub("*currentFilter", () => {
      this._updateInfoTooltip();
    });
    this.sub("*currentOperation", () => {
      this._updateInfoTooltip();
    });
    this.sub("*tabId", () => {
      this._updateInfoTooltip();
    });
    this.sub("*originalUrl", (originalUrl) => {
      this.$["*faderEl"] && this.$["*faderEl"].deactivate();
    });
    this.sub("*editorTransformations", (transformations) => {
      this._preloadEditedImage();
      if (this.$["*faderEl"]) {
        this.$["*faderEl"].setTransformations(transformations);
      }
    });
    this.sub("*loadingOperations", (loadingOperations) => {
      let anyLoading = false;
      for (let [, mapping] of loadingOperations.entries()) {
        if (anyLoading) {
          break;
        }
        for (let [, loading] of mapping.entries()) {
          if (loading) {
            anyLoading = true;
            break;
          }
        }
      }
      this._debouncedShowLoader(anyLoading);
    });
    this.sub("*showSlider", (showSlider) => {
      this.$["presence.subToolbar"] = showSlider;
      this.$["presence.mainToolbar"] = !showSlider;
    });
    this._updateInfoTooltip();
  }
};
EditorToolbar.template = /* HTML */
`
  <lr-line-loader-ui set="active: showLoader"></lr-line-loader-ui>
  <div class="info-tooltip_container">
    <div class="info-tooltip_wrapper">
      <div ref="tooltip-el" class="info-tooltip info-tooltip_hidden">{{*operationTooltip}}</div>
    </div>
  </div>
  <div class="toolbar-container">
    <lr-presence-toggle class="sub-toolbar" set="visible: presence.mainToolbar; styles: presence.subTopToolbarStyles">
      <div class="tab-content-row">${TABS.map(renderTabContent).join("")}</div>
      <div class="controls-row">
        <lr-btn-ui theme="boring" icon="closeMax" set="onclick: on.cancel"> </lr-btn-ui>
        <div class="tab-toggles">
          <div ref="tabs-indicator" class="tab-toggles_indicator"></div>
          ${TABS.map(renderTabToggle).join("")}
        </div>
        <lr-btn-ui theme="primary" icon="done" set="onclick: on.apply"> </lr-btn-ui>
      </div>
    </lr-presence-toggle>
    <lr-presence-toggle class="sub-toolbar" set="visible: presence.subToolbar; styles: presence.subBottomToolbarStyles">
      <div class="slider">
        <lr-editor-slider ref="slider-el"></lr-editor-slider>
      </div>
      <div class="controls-row">
        <lr-btn-ui theme="boring" set="@text: l10n.cancel; onclick: on.cancelSlider;"> </lr-btn-ui>
        <lr-btn-ui theme="primary" set="@text: l10n.apply; onclick: on.applySlider;"> </lr-btn-ui>
      </div>
    </lr-presence-toggle>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/elements/button/LrBtnUi.js
var LrBtnUi = class extends Block {
  constructor() {
    super();
    this._iconReversed = false;
    this._iconSingle = false;
    this._iconHidden = false;
    this.init$ = {
      ...this.ctxInit,
      text: "",
      icon: "",
      iconCss: this._iconCss(),
      theme: null
    };
    this.defineAccessor("active", (active) => {
      if (active) {
        this.setAttribute("active", "");
      } else {
        this.removeAttribute("active");
      }
    });
  }
  _iconCss() {
    return classNames("icon", {
      icon_left: !this._iconReversed,
      icon_right: this._iconReversed,
      icon_hidden: this._iconHidden,
      icon_single: this._iconSingle
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("icon", (iconName) => {
      this._iconSingle = !this.$.text;
      this._iconHidden = !iconName;
      this.$.iconCss = this._iconCss();
    });
    this.sub("theme", (theme) => {
      if (theme !== "custom") {
        this.className = theme;
      }
    });
    this.sub("text", (txt) => {
      this._iconSingle = false;
    });
    this.setAttribute("role", "button");
    if (this.tabIndex === -1) {
      this.tabIndex = 0;
    }
    if (!this.hasAttribute("theme")) {
      this.setAttribute("theme", "default");
    }
  }
  set reverse(val) {
    if (this.hasAttribute("reverse")) {
      this.style.flexDirection = "row-reverse";
      this._iconReversed = true;
    } else {
      this._iconReversed = false;
      this.style.flexDirection = null;
    }
  }
};
LrBtnUi.bindAttributes({ text: "text", icon: "icon", reverse: "reverse", theme: "theme" });
LrBtnUi.template = /* HTML */
`
  <lr-icon size="20" set="className: iconCss; @name: icon;"></lr-icon>
  <div class="text">{{text}}</div>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/elements/line-loader/LineLoaderUi.js
var LineLoaderUi = class extends Block {
  constructor() {
    super();
    this._active = false;
    this._handleTransitionEndRight = () => {
      let lineEl = this.ref["line-el"];
      lineEl.style.transition = `initial`;
      lineEl.style.opacity = "0";
      lineEl.style.transform = `translateX(-101%)`;
      this._active && this._start();
    };
  }
  initCallback() {
    super.initCallback();
    this.defineAccessor("active", (active) => {
      if (typeof active === "boolean") {
        if (active) {
          this._start();
        } else {
          this._stop();
        }
      }
    });
  }
  _start() {
    this._active = true;
    let { width } = this.getBoundingClientRect();
    let lineEl = this.ref["line-el"];
    lineEl.style.transition = `transform 1s`;
    lineEl.style.opacity = "1";
    lineEl.style.transform = `translateX(${width}px)`;
    lineEl.addEventListener("transitionend", this._handleTransitionEndRight, {
      once: true
    });
  }
  _stop() {
    this._active = false;
  }
};
LineLoaderUi.template = /* HTML */
`
  <div class="inner">
    <div class="line" ref="line-el"></div>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/elements/presence-toggle/PresenceToggle.js
var DEFAULT_STYLE = {
  transition: "transition",
  visible: "visible",
  hidden: "hidden"
};
var PresenceToggle = class extends Block {
  constructor() {
    super();
    this._visible = false;
    this._visibleStyle = DEFAULT_STYLE.visible;
    this._hiddenStyle = DEFAULT_STYLE.hidden;
    this._externalTransitions = false;
    this.defineAccessor("styles", (styles) => {
      if (!styles) {
        return;
      }
      this._externalTransitions = true;
      this._visibleStyle = styles.visible;
      this._hiddenStyle = styles.hidden;
    });
    this.defineAccessor("visible", (visible) => {
      if (typeof visible !== "boolean") {
        return;
      }
      this._visible = visible;
      this._handleVisible();
    });
  }
  _handleVisible() {
    this.style.visibility = this._visible ? "inherit" : "hidden";
    applyClassNames(this, {
      [DEFAULT_STYLE.transition]: !this._externalTransitions,
      [this._visibleStyle]: this._visible,
      [this._hiddenStyle]: !this._visible
    });
    this.setAttribute("aria-hidden", this._visible ? "false" : "true");
  }
  initCallback() {
    super.initCallback();
    this.setAttribute("hidden", "");
    if (!this._externalTransitions) {
      this.classList.add(DEFAULT_STYLE.transition);
    }
    this._handleVisible();
    setTimeout(() => this.removeAttribute("hidden"), 0);
  }
};
PresenceToggle.template = /* HTML */
` <slot></slot> `;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/src/elements/slider/SliderUi.js
var SliderUi = class extends Block {
  constructor() {
    super();
    __publicField(this, "init$", {
      ...this.ctxInit,
      disabled: false,
      min: 0,
      max: 100,
      onInput: null,
      onChange: null,
      defaultValue: null,
      "on.sliderInput": () => {
        let value = parseInt(this.ref["input-el"].value, 10);
        this._updateValue(value);
        this.$.onInput && this.$.onInput(value);
      },
      "on.sliderChange": () => {
        let value = parseInt(this.ref["input-el"].value, 10);
        this.$.onChange && this.$.onChange(value);
      }
    });
    this.setAttribute("with-effects", "");
  }
  initCallback() {
    super.initCallback();
    this.defineAccessor("disabled", (disabled) => {
      this.$.disabled = disabled;
    });
    this.defineAccessor("min", (min) => {
      this.$.min = min;
    });
    this.defineAccessor("max", (max) => {
      this.$.max = max;
    });
    this.defineAccessor("defaultValue", (defaultValue) => {
      this.$.defaultValue = defaultValue;
      this.ref["input-el"].value = defaultValue;
      this._updateValue(defaultValue);
    });
    this.defineAccessor("zero", (zero) => {
      this._zero = zero;
    });
    this.defineAccessor("onInput", (onInput) => {
      if (!onInput)
        return;
      this.$.onInput = onInput;
    });
    this.defineAccessor("onChange", (onChange) => {
      if (!onChange)
        return;
      this.$.onChange = onChange;
    });
    this._updateSteps();
    this._observer = new ResizeObserver(() => {
      this._updateSteps();
      let value = parseInt(this.ref["input-el"].value, 10);
      this._updateValue(value);
    });
    this._observer.observe(this);
    this._thumbSize = parseInt(window.getComputedStyle(this).getPropertyValue("--l-thumb-size"), 10);
    setTimeout(() => {
      let value = parseInt(this.ref["input-el"].value, 10);
      this._updateValue(value);
    }, 0);
    this.sub("disabled", (disabled) => {
      let el = this.ref["input-el"];
      if (disabled) {
        el.setAttribute("disabled", "disabled");
      } else {
        el.removeAttribute("disabled");
      }
    });
    let inputEl = this.ref["input-el"];
    inputEl.addEventListener("focus", () => {
      this.style.setProperty("--color-effect", "var(--hover-color-rgb)");
    });
    inputEl.addEventListener("blur", () => {
      this.style.setProperty("--color-effect", "var(--idle-color-rgb)");
    });
  }
  _updateValue(value) {
    this._updateZeroDot(value);
    let { width } = this.getBoundingClientRect();
    let slope = 100 / (this.$.max - this.$.min);
    let mappedValue = slope * (value - this.$.min);
    let offset = mappedValue * (width - this._thumbSize) / 100;
    window.requestAnimationFrame(() => {
      this.ref["thumb-el"].style.transform = `translateX(${offset}px)`;
    });
  }
  _updateZeroDot(value) {
    if (!this._zeroDotEl) {
      return;
    }
    if (value === this._zero) {
      this._zeroDotEl.style.opacity = "0";
    } else {
      this._zeroDotEl.style.opacity = "0.2";
    }
    let { width } = this.getBoundingClientRect();
    let slope = 100 / (this.$.max - this.$.min);
    let mappedValue = slope * (this._zero - this.$.min);
    let offset = mappedValue * (width - this._thumbSize) / 100;
    window.requestAnimationFrame(() => {
      this._zeroDotEl.style.transform = `translateX(${offset}px)`;
    });
  }
  _updateSteps() {
    const STEP_GAP = 15;
    let stepsEl = this.ref["steps-el"];
    let { width } = stepsEl.getBoundingClientRect();
    let half = Math.ceil(width / 2);
    let count = Math.ceil(half / STEP_GAP) - 2;
    if (this._stepsCount === count) {
      return;
    }
    let fr = document.createDocumentFragment();
    let minorStepEl = document.createElement("div");
    let borderStepEl = document.createElement("div");
    minorStepEl.className = "minor-step";
    borderStepEl.className = "border-step";
    fr.appendChild(borderStepEl);
    for (let i = 0; i < count; i++) {
      fr.appendChild(minorStepEl.cloneNode());
    }
    fr.appendChild(borderStepEl.cloneNode());
    for (let i = 0; i < count; i++) {
      fr.appendChild(minorStepEl.cloneNode());
    }
    fr.appendChild(borderStepEl.cloneNode());
    let zeroDotEl = document.createElement("div");
    zeroDotEl.className = "zero-dot";
    fr.appendChild(zeroDotEl);
    this._zeroDotEl = zeroDotEl;
    stepsEl.innerHTML = "";
    stepsEl.appendChild(fr);
    this._stepsCount = count;
  }
  destroyCallback() {
    var _a2;
    (_a2 = this._observer) == null ? void 0 : _a2.disconnect();
  }
};
SliderUi.template = /* HTML */
`
  <div class="steps" ref="steps-el"></div>
  <div ref="thumb-el" class="thumb"></div>
  <input
    class="input"
    type="range"
    ref="input-el"
    tabindex="0"
    set="oninput: on.sliderInput; onchange: on.sliderChange; @min: min; @max: max; @value: defaultValue;"
  />
`;

// node_modules/@uploadcare/blocks/blocks/CloudImageEditor/CloudImageEditor.js
var CloudImageEditor = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.CLOUD_IMG_EDIT);
    __publicField(this, "init$", {
      ...this.ctxInit,
      cdnUrl: null
    });
  }
  initCallback() {
    super.initCallback();
    this.bindCssData("--cfg-pubkey");
    this.registerActivity(this.activityType, {
      onActivate: () => this.mountEditor(),
      onDeactivate: () => this.unmountEditor()
    });
    this.sub("*focusedEntry", (entry) => {
      if (!entry) {
        return;
      }
      this.entry = entry;
      this.entry.subscribe("cdnUrl", (cdnUrl) => {
        if (cdnUrl) {
          this.$.cdnUrl = cdnUrl;
        }
      });
    });
  }
  /** @param {CustomEvent<import('./src/types.js').ApplyResult>} e */
  handleApply(e) {
    let result = e.detail;
    this.entry.setMultipleValues({
      cdnUrl: result.cdnUrl,
      cdnUrlModifiers: result.cdnUrlModifiers
    });
    this.historyBack();
  }
  handleCancel() {
    this.historyBack();
  }
  mountEditor() {
    let instance = new CloudEditor();
    instance.classList.add("lr-cldtr-common");
    let cdnUrl = this.$.cdnUrl;
    instance.setAttribute("cdn-url", cdnUrl);
    instance.addEventListener("apply", (result) => this.handleApply(result));
    instance.addEventListener("cancel", () => this.handleCancel());
    this.innerHTML = "";
    this.appendChild(instance);
  }
  unmountEditor() {
    this.innerHTML = "";
  }
};

// node_modules/@uploadcare/blocks/blocks/ExternalSource/messages.js
var cbMapping = {};
window.addEventListener("message", (e) => {
  let message;
  try {
    message = JSON.parse(e.data);
  } catch (err) {
    return;
  }
  if ((message == null ? void 0 : message.type) in cbMapping) {
    let cbList = cbMapping[message.type];
    for (let [sender, callback] of cbList) {
      if (e.source === sender) {
        callback(message);
      }
    }
  }
});
var registerMessage = function(type, sender, callback) {
  if (!(type in cbMapping)) {
    cbMapping[type] = [];
  }
  cbMapping[type].push([sender, callback]);
};
var unregisterMessage = function(type, sender) {
  if (type in cbMapping) {
    cbMapping[type] = cbMapping[type].filter((item) => item[0] !== sender);
  }
};

// node_modules/@uploadcare/blocks/blocks/ExternalSource/buildStyles.js
var styleToCss = (style) => {
  let css = Object.keys(style).reduce((acc, selector) => {
    let propertiesObj = style[selector];
    let propertiesStr = Object.keys(propertiesObj).reduce((acc2, prop) => {
      let value = propertiesObj[prop];
      return acc2 + `${prop}: ${value};`;
    }, "");
    return acc + `${selector}{${propertiesStr}}`;
  }, "");
  return css;
};
function buildStyles({ textColor, backgroundColor, linkColor, linkColorHover, shadeColor }) {
  let border = `solid 1px ${shadeColor}`;
  return styleToCss({
    body: {
      color: textColor,
      "background-color": backgroundColor
    },
    ".side-bar": {
      background: "inherit",
      "border-right": border
    },
    ".main-content": {
      background: "inherit"
    },
    ".main-content-header": {
      background: "inherit"
    },
    ".main-content-footer": {
      background: "inherit"
    },
    ".list-table-row": {
      color: "inherit"
    },
    ".list-table-row:hover": {
      background: shadeColor
    },
    ".list-table-row .list-table-cell-a, .list-table-row .list-table-cell-b": {
      "border-top": border
    },
    ".list-table-body .list-items": {
      "border-bottom": border
    },
    ".bread-crumbs a": {
      color: linkColor
    },
    ".bread-crumbs a:hover": {
      color: linkColorHover
    },
    ".main-content.loading": {
      background: `${backgroundColor} url(/static/images/loading_spinner.gif) center no-repeat`,
      "background-size": "25px 25px"
    },
    ".list-icons-item": {
      background: `center no-repeat ${shadeColor}`
    },
    ".source-gdrive .side-bar-menu a, .source-gphotos .side-bar-menu a": {
      color: linkColor
    },
    ".source-gdrive .side-bar-menu a, .source-gphotos .side-bar-menu a:hover": {
      color: linkColorHover
    },
    ".side-bar-menu a": {
      color: linkColor
    },
    ".side-bar-menu a:hover": {
      color: linkColorHover
    },
    ".source-gdrive .side-bar-menu .current, .source-gdrive .side-bar-menu a:hover, .source-gphotos .side-bar-menu .current, .source-gphotos .side-bar-menu a:hover": {
      color: linkColorHover
    },
    ".source-vk .side-bar-menu a": {
      color: linkColor
    },
    ".source-vk .side-bar-menu a:hover": {
      color: linkColorHover,
      background: "none"
    }
  });
}

// node_modules/@uploadcare/blocks/blocks/ExternalSource/query-string.js
function queryString(params) {
  let list = [];
  for (let [key, value] of Object.entries(params)) {
    if (value === void 0 || value === null || typeof value === "string" && value.length === 0) {
      continue;
    }
    list.push(`${key}=${encodeURIComponent(value)}`);
  }
  return list.join("&");
}

// node_modules/@uploadcare/blocks/utils/wildcardRegexp.js
var escapeRegExp = function(str) {
  return str.replace(/[\\-\\[]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};
var wildcardRegexp = function(str, flags = "i") {
  const parts = str.split("*").map(escapeRegExp);
  return new RegExp("^" + parts.join(".+") + "$", flags);
};

// node_modules/@uploadcare/blocks/blocks/ExternalSource/ExternalSource.js
var ExternalSource = class extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "activityType", ActivityBlock.activities.EXTERNAL);
    __publicField(this, "init$", {
      ...this.ctxInit,
      activityIcon: "",
      activityCaption: "",
      counter: 0,
      onDone: () => {
        this.$["*currentActivity"] = ActivityBlock.activities.UPLOAD_LIST;
      },
      onCancel: () => {
        this.historyBack();
      }
    });
    /** @private */
    __publicField(this, "_iframe", null);
    __publicField(this, "_inheritedUpdateCssData", this.updateCssData);
    __publicField(this, "updateCssData", () => {
      if (this.isActivityActive) {
        this._inheritedUpdateCssData();
        this.applyStyles();
      }
    });
  }
  initCallback() {
    super.initCallback();
    this.registerActivity(this.activityType, {
      onActivate: () => {
        let { externalSourceType } = (
          /** @type {ActivityParams} */
          this.activityParams
        );
        this.set$({
          activityCaption: `${externalSourceType == null ? void 0 : externalSourceType[0].toUpperCase()}${externalSourceType == null ? void 0 : externalSourceType.slice(1)}`,
          activityIcon: externalSourceType
        });
        this.$.counter = 0;
        this.mountIframe();
      }
    });
    this.sub("*currentActivity", (val) => {
      if (val !== this.activityType) {
        this.unmountIframe();
      }
    });
  }
  sendMessage(message) {
    this._iframe.contentWindow.postMessage(JSON.stringify(message), "*");
  }
  async handleFileSelected(message) {
    this.$.counter = this.$.counter + 1;
    const url = (() => {
      if (message.alternatives) {
        const preferredTypes = stringToArray(this.getCssData("--cfg-external-sources-preferred-types"));
        for (const preferredType of preferredTypes) {
          const regexp = wildcardRegexp(preferredType);
          for (const [type, typeUrl] of Object.entries(message.alternatives)) {
            if (regexp.test(type)) {
              return typeUrl;
            }
          }
        }
      }
      return message.url;
    })();
    let { filename } = message;
    this.uploadCollection.add({
      externalUrl: url,
      fileName: filename ?? null
    });
  }
  handleIframeLoad() {
    this.applyStyles();
  }
  getCssValue(propName) {
    let style = window.getComputedStyle(this);
    return style.getPropertyValue(propName).trim();
  }
  applyStyles() {
    let colors = {
      backgroundColor: this.getCssValue("--clr-background-light"),
      textColor: this.getCssValue("--clr-txt"),
      shadeColor: this.getCssValue("--clr-shade-lv1"),
      linkColor: "#157cfc",
      linkColorHover: "#3891ff"
    };
    this.sendMessage({
      type: "embed-css",
      style: buildStyles(colors)
    });
  }
  remoteUrl() {
    let pubkey = this.getCssData("--cfg-pubkey");
    let imagesOnly = false.toString();
    let { externalSourceType } = this.activityParams;
    let params = {
      lang: "en",
      // TOOD: pass correct lang
      // TODO: we should add a new property to the social sources application
      // to collect lr-blocks data separately from legacy widget
      widget_version: "3.11.3",
      public_key: pubkey,
      images_only: imagesOnly,
      pass_window_open: false,
      session_key: this.getCssData("--cfg-remote-tab-session-key")
    };
    return `https://social.uploadcare.com/window3/${externalSourceType}?${queryString(params)}`;
  }
  mountIframe() {
    let iframe = create({
      tag: "iframe",
      attributes: {
        src: this.remoteUrl(),
        marginheight: 0,
        marginwidth: 0,
        frameborder: 0,
        allowTransparency: true
      }
    });
    iframe.addEventListener("load", this.handleIframeLoad.bind(this));
    this.ref.iframeWrapper.innerHTML = "";
    this.ref.iframeWrapper.appendChild(iframe);
    registerMessage("file-selected", iframe.contentWindow, this.handleFileSelected.bind(this));
    this._iframe = iframe;
  }
  unmountIframe() {
    this._iframe && unregisterMessage("file-selected", this._iframe.contentWindow);
    this.ref.iframeWrapper.innerHTML = "";
    this._iframe = void 0;
  }
};
ExternalSource.template = /* HTML */
`
  <lr-activity-header>
    <button type="button" class="mini-btn" set="onclick: *historyBack">
      <lr-icon name="back"></lr-icon>
    </button>
    <div>
      <lr-icon set="@name: activityIcon"></lr-icon>
      <span>{{activityCaption}}</span>
    </div>
    <button type="button" class="mini-btn close-btn" set="onclick: *historyBack">
      <lr-icon name="close"></lr-icon>
    </button>
  </lr-activity-header>
  <div class="content">
    <div ref="iframeWrapper" class="iframe-wrapper"></div>
    <div class="toolbar">
      <button type="button" class="cancel-btn secondary-btn" set="onclick: onCancel" l10n="cancel"></button>
      <div></div>
      <div class="selected-counter"><span l10n="selected-count"></span>{{counter}}</div>
      <button type="button" class="done-btn primary-btn" set="onclick: onDone; @disabled: !counter">
        <lr-icon name="check"></lr-icon>
      </button>
    </div>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/Tabs/Tabs.js
var Tabs = class extends Block {
  /** @param {String} tabL10nStr */
  setCurrentTab(tabL10nStr) {
    if (!tabL10nStr) {
      return;
    }
    let ctxList = [...this.ref.context.querySelectorAll("[tab-ctx]")];
    ctxList.forEach((ctxEl) => {
      if (ctxEl.getAttribute("tab-ctx") === tabL10nStr) {
        ctxEl.removeAttribute("hidden");
      } else {
        ctxEl.setAttribute("hidden", "");
      }
    });
    for (let lStr in this._tabMap) {
      if (lStr === tabL10nStr) {
        this._tabMap[lStr].setAttribute("current", "");
      } else {
        this._tabMap[lStr].removeAttribute("current");
      }
    }
  }
  initCallback() {
    super.initCallback();
    this._tabMap = {};
    this.defineAccessor("tab-list", (val) => {
      if (!val) {
        return;
      }
      let tabList = stringToArray(val);
      tabList.forEach((tabL10nStr) => {
        let tabEl = create({
          tag: "div",
          attributes: {
            class: "tab"
          },
          properties: {
            onclick: () => {
              this.setCurrentTab(tabL10nStr);
            }
          }
        });
        tabEl.textContent = this.l10n(tabL10nStr);
        this.ref.row.appendChild(tabEl);
        this._tabMap[tabL10nStr] = tabEl;
      });
    });
    this.defineAccessor("default", (val) => {
      this.setCurrentTab(val);
    });
    if (!this.hasAttribute("default")) {
      this.setCurrentTab(Object.keys(this._tabMap)[0]);
    }
  }
};
Tabs.bindAttributes({
  "tab-list": null,
  default: null
});
Tabs.template = /* HTML */
`
  <div ref="row" class="tabs-row"></div>
  <div ref="context" class="tabs-context">
    <slot></slot>
  </div>
`;

// node_modules/@uploadcare/blocks/blocks/DataOutput/DataOutput.js
var DataOutput = class _DataOutput extends UploaderBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "processInnerHtml", true);
    __publicField(this, "init$", {
      ...this.ctxInit,
      output: null,
      filesData: null
    });
    __publicField(this, "cssInit$", {
      "--cfg-group-output": 0
    });
  }
  get dict() {
    return _DataOutput.dict;
  }
  get validationInput() {
    return this._validationInputElement;
  }
  initCallback() {
    super.initCallback();
    if (this.hasAttribute(this.dict.FORM_INPUT_ATTR)) {
      this._dynamicInputsContainer = document.createElement("div");
      this.appendChild(this._dynamicInputsContainer);
      if (this.hasAttribute(this.dict.INPUT_REQUIRED)) {
        let input = document.createElement("input");
        input.type = "text";
        input.name = "__UPLOADCARE_VALIDATION_INPUT__";
        input.required = true;
        this.appendChild(input);
        this._validationInputElement = input;
      }
    }
    this.sub(
      "output",
      (data) => {
        if (!data) {
          return;
        }
        if (this.hasAttribute(this.dict.FIRE_EVENT_ATTR)) {
          this.dispatchEvent(
            new CustomEvent(this.dict.EVENT_NAME, {
              bubbles: true,
              composed: true,
              detail: {
                timestamp: Date.now(),
                ctxName: this.ctxName,
                data
              }
            })
          );
        }
        if (this.hasAttribute(this.dict.FORM_INPUT_ATTR)) {
          this._dynamicInputsContainer.innerHTML = "";
          let values = data.groupData ? [data.groupData.cdnUrl] : data.map((file) => file.cdnUrl);
          for (let value of values) {
            let input = document.createElement("input");
            input.type = "hidden";
            input.name = this.getAttribute(this.dict.INPUT_NAME_ATTR) || this.ctxName;
            input.value = value;
            this._dynamicInputsContainer.appendChild(input);
          }
          if (this.hasAttribute(this.dict.INPUT_REQUIRED)) {
            this._validationInputElement.value = values.length ? "__VALUE__" : "";
          }
        }
        if (this.hasAttribute(this.dict.CONSOLE_ATTR)) {
          console.log(data);
        }
      },
      false
    );
    this.sub(
      this.dict.SRC_CTX_KEY,
      async (data) => {
        if (!data) {
          this.$.output = null;
          this.$.filesData = null;
          return;
        }
        this.$.filesData = data;
        if (this.getCssData("--cfg-group-output") || this.hasAttribute(this.dict.GROUP_ATTR)) {
          let uuidList = data.map((fileDesc) => {
            return fileDesc.uuid;
          });
          let resp = await uploadFileGroup(uuidList, {
            ...this.getUploadClientOptions()
          });
          this.$.output = {
            groupData: resp,
            files: data
          };
        } else {
          this.$.output = data;
        }
      },
      false
    );
  }
};
DataOutput.dict = {
  SRC_CTX_KEY: "*outputData",
  EVENT_NAME: "lr-data-output",
  FIRE_EVENT_ATTR: "use-event",
  CONSOLE_ATTR: "use-console",
  GROUP_ATTR: "use-group",
  FORM_INPUT_ATTR: "use-input",
  INPUT_NAME_ATTR: "input-name",
  INPUT_REQUIRED: "input-required"
};

// node_modules/@uploadcare/blocks/blocks/ActivityHeader/ActivityHeader.js
var ActivityHeader = class extends ActivityBlock {
};

// node_modules/@uploadcare/blocks/blocks/Select/Select.js
var Select = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      currentText: "",
      options: [],
      selectHtml: "",
      onSelect: (e) => {
        var _a2;
        e.preventDefault();
        e.stopPropagation();
        this.value = this.ref.select.value;
        this.$.currentText = ((_a2 = this.$.options.find((opt) => {
          return opt.value == this.value;
        })) == null ? void 0 : _a2.text) || "";
        this.dispatchEvent(new Event("change"));
      }
    });
  }
  initCallback() {
    super.initCallback();
    this.sub("options", (options) => {
      var _a2;
      this.$.currentText = ((_a2 = options == null ? void 0 : options[0]) == null ? void 0 : _a2.text) || "";
      let html = "";
      options == null ? void 0 : options.forEach((opt) => {
        html += /* HTML */
        `<option value="${opt.value}">${opt.text}</option>`;
      });
      this.$.selectHtml = html;
    });
  }
};
Select.template = /* HTML */
`
  <button>
    {{currentText}}
    <lr-icon name="select"></lr-icon>
    <select ref="select" set="innerHTML: selectHtml; onchange: onSelect"></select>
  </button>
`;

// node_modules/@uploadcare/blocks/blocks/Video/Video.js
var ICO_MAP = {
  PLAY: "play",
  PAUSE: "pause",
  FS_ON: "fullscreen-on",
  FS_OFF: "fullscreen-off",
  VOL_ON: "unmute",
  VOL_OFF: "mute",
  CAP_ON: "captions",
  CAP_OFF: "captions-off"
};
var FSAPI = {
  requestFullscreen: (el) => {
    if (el.requestFullscreen) {
      el.requestFullscreen();
    } else if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
    }
  },
  exitFullscreen: () => {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document["webkitExitFullscreen"]) {
      document["webkitExitFullscreen"]();
    }
  }
};
var Video = class _Video extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", {
      ...this.ctxInit,
      src: "",
      ppIcon: ICO_MAP.PLAY,
      fsIcon: ICO_MAP.FS_ON,
      volIcon: ICO_MAP.VOL_ON,
      capIcon: ICO_MAP.CAP_OFF,
      totalTime: "00:00",
      currentTime: "00:00",
      progressCssWidth: "0",
      hasSubtitles: false,
      volumeDisabled: false,
      volumeValue: 0,
      onPP: () => {
        this.togglePlay();
      },
      onFs: () => {
        this.toggleFullscreen();
      },
      onCap: () => {
        this.toggleCaptions();
      },
      onMute: () => {
        this.toggleSound();
      },
      onVolChange: (e) => {
        let val = parseFloat(e.currentTarget.$.value);
        this.setVolume(val);
      },
      progressClicked: (e) => {
        let progressRect = this.progress.getBoundingClientRect();
        this._video.currentTime = this._video.duration * (e.offsetX / progressRect.width);
      }
    });
  }
  togglePlay() {
    if (this._video.paused || this._video.ended) {
      this._video.play();
    } else {
      this._video.pause();
    }
  }
  toggleFullscreen() {
    if ((document.fullscreenElement || document["webkitFullscreenElement"]) === this) {
      FSAPI.exitFullscreen();
    } else {
      FSAPI.requestFullscreen(this);
    }
  }
  toggleCaptions() {
    if (this.$.capIcon === ICO_MAP.CAP_OFF) {
      this.$.capIcon = ICO_MAP.CAP_ON;
      this._video.textTracks[0].mode = "showing";
      window.localStorage.setItem(_Video.is + ":captions", "1");
    } else {
      this.$.capIcon = ICO_MAP.CAP_OFF;
      this._video.textTracks[0].mode = "hidden";
      window.localStorage.removeItem(_Video.is + ":captions");
    }
  }
  toggleSound() {
    if (this.$.volIcon === ICO_MAP.VOL_ON) {
      this.$.volIcon = ICO_MAP.VOL_OFF;
      this.$.volumeDisabled = true;
      this._video.muted = true;
    } else {
      this.$.volIcon = ICO_MAP.VOL_ON;
      this.$.volumeDisabled = false;
      this._video.muted = false;
    }
  }
  setVolume(val) {
    window.localStorage.setItem(_Video.is + ":volume", val);
    let volume = val ? val / 100 : 0;
    this._video.volume = volume;
  }
  /** @type {HTMLElement} */
  get progress() {
    return this.ref.progress;
  }
  /**
   * @private
   * @param {String} input
   */
  _getUrl(input) {
    return input.includes("/") ? input : `https://ucarecdn.com/${input}/`;
  }
  /**
   * @private
   * @param {Object<string, any>} desc
   */
  _desc2attrs(desc) {
    let attrs = [];
    for (let attr in desc) {
      let val = attr === "src" ? this._getUrl(desc[attr]) : desc[attr];
      attrs.push(`${attr}="${val}"`);
    }
    return attrs.join(" ");
  }
  /**
   * @private
   * @param {Number} seconds
   */
  _timeFmt(seconds) {
    let date = new Date(Math.round(seconds) * 1e3);
    return [date.getMinutes(), date.getSeconds()].map((n) => {
      return n < 10 ? "0" + n : n;
    }).join(":");
  }
  /** @private */
  _initTracks() {
    [...this._video.textTracks].forEach((track) => {
      track.mode = "hidden";
    });
    if (window.localStorage.getItem(_Video.is + ":captions")) {
      this.toggleCaptions();
    }
  }
  /** @private */
  _castAttributes() {
    let toCast = ["autoplay", "loop", "muted"];
    [...this.attributes].forEach((attr) => {
      if (toCast.includes(attr.name)) {
        this._video.setAttribute(attr.name, attr.value);
      }
    });
  }
  initCallback() {
    super.initCallback();
    this._video = this.ref.video;
    this._castAttributes();
    this._video.addEventListener("play", () => {
      this.$.ppIcon = ICO_MAP.PAUSE;
      this.setAttribute("playback", "");
    });
    this._video.addEventListener("pause", () => {
      this.$.ppIcon = ICO_MAP.PLAY;
      this.removeAttribute("playback");
    });
    this.addEventListener("fullscreenchange", (e) => {
      console.log(e);
      if (document.fullscreenElement === this) {
        this.$.fsIcon = ICO_MAP.FS_OFF;
      } else {
        this.$.fsIcon = ICO_MAP.FS_ON;
      }
    });
    this.sub("src", (src) => {
      if (!src) {
        return;
      }
      let url = this._getUrl(src);
      this._video.src = url;
    });
    this.sub("video", async (descPath) => {
      if (!descPath) {
        return;
      }
      let desc = await (await window.fetch(this._getUrl(descPath))).json();
      if (desc.poster) {
        this._video.poster = this._getUrl(desc.poster);
      }
      let html = "";
      desc == null ? void 0 : desc.sources.forEach((srcDesc) => {
        html += /* HTML */
        `<source ${this._desc2attrs(srcDesc)} />`;
      });
      if (desc.tracks) {
        desc.tracks.forEach((trackDesc) => {
          html += /* HTML */
          `<track ${this._desc2attrs(trackDesc)} />`;
        });
        this.$.hasSubtitles = true;
      }
      this._video.innerHTML += html;
      this._initTracks();
      console.log(desc);
    });
    this._video.addEventListener("loadedmetadata", (e) => {
      this.$.currentTime = this._timeFmt(this._video.currentTime);
      this.$.totalTime = this._timeFmt(this._video.duration);
    });
    this._video.addEventListener("timeupdate", (e) => {
      let perc = Math.round(100 * (this._video.currentTime / this._video.duration));
      this.$.progressCssWidth = perc + "%";
      this.$.currentTime = this._timeFmt(this._video.currentTime);
    });
    let volume = window.localStorage.getItem(_Video.is + ":volume");
    if (volume) {
      let vol = parseFloat(volume);
      this.setVolume(vol);
      this.$.volumeValue = vol;
    }
  }
};
Video.template = /* HTML */
`
  <div class="video-wrapper">
    <video ref="video" preload="metadata" crossorigin="anonymous"></video>
  </div>

  <div class="toolbar">
    <div class="progress" ref="progress" set -onclick="progressClicked">
      <div class="bar" set -style.width="progressCssWidth"></div>
    </div>

    <div class="tb-block">
      <button set -onclick="onPP">
        <lr-icon set -@name="ppIcon"></lr-icon>
      </button>
      <div class="timer">{{currentTime}} / {{totalTime}}</div>
    </div>

    <div class="tb-block">
      <button set -onclick="onCap" -@hidden="!hasSubtitles">
        <lr-icon set -@name="capIcon"></lr-icon>
      </button>

      <button set -onclick="onMute">
        <lr-icon set -@name="volIcon"></lr-icon>
      </button>

      <lr-range type="range" set -onchange="onVolChange" -@disabled="volumeDisabled" -value="volumeValue"> </lr-range>

      <button set -onclick="onFs">
        <lr-icon set -@name="fsIcon"></lr-icon>
      </button>
    </div>
  </div>
`;
Video.bindAttributes({
  video: "video",
  src: "src"
});

// node_modules/@uploadcare/blocks/blocks/ShadowWrapper/ShadowWrapper.js
var CSS_ATTRIBUTE = "css-src";
var ShadowWrapper = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "pauseRender", true);
  }
  shadowReadyCallback() {
  }
  initCallback() {
    super.initCallback();
    this.setAttribute("hidden", "");
    let href = this.getAttribute(CSS_ATTRIBUTE);
    if (href) {
      this.renderShadow = true;
      this.attachShadow({
        mode: "open"
      });
      let link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = href;
      link.onload = () => {
        window.requestAnimationFrame(() => {
          this.render();
          window.setTimeout(() => {
            this.removeAttribute("hidden");
            this.shadowReadyCallback();
          });
        });
      };
      this.shadowRoot.prepend(link);
    } else {
      this.render();
      this.removeAttribute("hidden");
      this.shadowReadyCallback();
    }
  }
};

// node_modules/@uploadcare/blocks/blocks/Copyright/Copyright.js
var Copyright = class extends Block {
  constructor() {
    super(...arguments);
    __publicField(this, "cssInit$", {
      "--cfg-remove-copyright": 0
    });
    __publicField(this, "init$", {
      ...this.ctxInit,
      removeCopyright: false
    });
  }
  initCallback() {
    super.initCallback();
    this.sub(
      "--cfg-remove-copyright",
      /** @param {number} value */
      (value) => {
        this.$.removeCopyright = !!value;
      }
    );
  }
};
__publicField(
  Copyright,
  "template",
  /* HTML */
  `
    <a
      href="https://uploadcare.com/?utm_source=copyright&utm_medium=referral&utm_campaign=v4"
      target="_blank noopener"
      class="credits"
      set="@hidden: removeCopyright"
      >Powered by Uploadcare</a
    >
  `
);

// node_modules/@uploadcare/blocks/abstract/SolutionBlock.js
var SolutionBlock = class extends ShadowWrapper {
  constructor() {
    super(...arguments);
    __publicField(this, "ctxInit", uploaderBlockCtx(this));
    __publicField(this, "ctxOwner", true);
    __publicField(this, "_template", null);
  }
  static set template(value) {
    this._template = value + /** HTML */
    `<slot></slot>`;
  }
  static get template() {
    return this._template;
  }
};

// node_modules/@uploadcare/blocks/solutions/file-uploader/regular/FileUploaderRegular.js
var FileUploaderRegular = class extends SolutionBlock {
};
FileUploaderRegular.template = /* HTML */
`
  <lr-simple-btn></lr-simple-btn>

  <lr-modal strokes block-body-scrolling>
    <lr-start-from>
      <lr-drop-area with-icon clickable></lr-drop-area>
      <lr-source-list wrap></lr-source-list>
      <lr-copyright></lr-copyright>
    </lr-start-from>
    <lr-upload-list></lr-upload-list>
    <lr-camera-source></lr-camera-source>
    <lr-url-source></lr-url-source>
    <lr-external-source></lr-external-source>
    <lr-cloud-image-editor></lr-cloud-image-editor>
  </lr-modal>

  <lr-message-box></lr-message-box>
  <lr-progress-bar-common></lr-progress-bar-common>
`;

// node_modules/@uploadcare/blocks/solutions/file-uploader/minimal/FileUploaderMinimal.js
var FileUploaderMinimal = class extends SolutionBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "pauseRender", true);
    __publicField(this, "init$", {
      ...this.ctxInit,
      selectClicked: () => {
        this.ref.uBlock.openSystemDialog();
      }
    });
  }
  shadowReadyCallback() {
    const uBlock = this.ref.uBlock;
    this.sub("*currentActivity", (val) => {
      if (!val) {
        this.$["*currentActivity"] = uBlock.initActivity || ActivityBlock.activities.START_FROM;
      }
    });
    this.sub("*uploadList", (list) => {
      if ((list == null ? void 0 : list.length) === 0) {
        this.$["*currentActivity"] = uBlock.initActivity || ActivityBlock.activities.START_FROM;
      }
    });
  }
};
FileUploaderMinimal.template = /* HTML */
`
  <lr-start-from>
    <lr-drop-area clickable l10n="choose-file"></lr-drop-area>
    <lr-copyright></lr-copyright>
  </lr-start-from>
  <lr-upload-list ref="uBlock"></lr-upload-list>
  <lr-message-box></lr-message-box>
`;

// node_modules/@uploadcare/blocks/solutions/file-uploader/inline/FileUploaderInline.js
var FileUploaderInline = class extends SolutionBlock {
  constructor() {
    super(...arguments);
    __publicField(this, "init$", this.ctxInit);
  }
  shadowReadyCallback() {
    const uBlock = this.ref.uBlock;
    this.sub("*currentActivity", (val) => {
      if (!val) {
        this.$["*currentActivity"] = uBlock.initActivity || ActivityBlock.activities.START_FROM;
      }
    });
  }
};
FileUploaderInline.template = /* HTML */
` <lr-start-from>
    <lr-drop-area with-icon clickable></lr-drop-area>
    <lr-source-list wrap></lr-source-list>
    <lr-copyright></lr-copyright>
  </lr-start-from>
  <lr-upload-list ref="uBlock"></lr-upload-list>
  <lr-camera-source></lr-camera-source>
  <lr-url-source></lr-url-source>
  <lr-external-source></lr-external-source>
  <lr-message-box></lr-message-box>
  <lr-progress-bar></lr-progress-bar>
  <lr-cloud-image-editor></lr-cloud-image-editor>`;

// node_modules/@uploadcare/blocks/abstract/registerBlocks.js
function registerBlocks(blockExports) {
  for (let blockName in blockExports) {
    let tagName = [...blockName].reduce((name, char) => {
      if (char.toUpperCase() === char) {
        char = "-" + char.toLowerCase();
      }
      return name += char;
    }, "");
    if (tagName.startsWith("-")) {
      tagName = tagName.replace("-", "");
    }
    if (!tagName.startsWith("lr-")) {
      tagName = "lr-" + tagName;
    }
    if (blockExports[blockName].reg) {
      blockExports[blockName].reg(tagName);
    }
  }
}

// node_modules/@uploadcare/blocks/abstract/connectBlocksFrom.js
var LR_WINDOW_KEY = "__lr-blocks__";
async function connectBlocksFrom(url, register = false) {
  return new Promise((resolve, reject) => {
    if (typeof document !== "object") {
      resolve(null);
      return;
    }
    if (typeof window === "object" && window[LR_WINDOW_KEY]) {
      resolve(window[LR_WINDOW_KEY]);
      return;
    }
    let script = document.createElement("script");
    script.type = "module";
    script.src = url;
    script.onerror = () => {
      reject();
    };
    script.onload = () => {
      let blocks = window[LR_WINDOW_KEY];
      register && registerBlocks(blocks);
      resolve(blocks);
    };
    document.head.appendChild(script);
  });
}
export {
  ActivityBlock,
  ActivityHeader,
  BaseComponent,
  Block,
  CameraSource,
  CloudEditor,
  CloudImageEditor,
  ConfirmationDialog,
  Copyright,
  CropFrame,
  Data,
  DataOutput,
  DropArea,
  EditorCropButtonControl,
  EditorFilterControl,
  EditorImageCropper,
  EditorImageFader,
  EditorOperationControl,
  EditorScroller,
  EditorSlider,
  EditorToolbar,
  ExternalSource,
  FileItem,
  FilePreview,
  FileUploaderInline,
  FileUploaderMinimal,
  FileUploaderRegular,
  Icon,
  Img,
  LineLoaderUi,
  LrBtnUi,
  MessageBox,
  Modal,
  PACKAGE_NAME,
  PACKAGE_VERSION,
  PresenceToggle,
  ProgressBar,
  ProgressBarCommon,
  Select,
  ShadowWrapper,
  SimpleBtn,
  SliderUi,
  SourceBtn,
  SourceList,
  StartFrom,
  Tabs,
  UploadCtxProvider,
  UploadDetails,
  UploadList,
  UploaderBlock,
  UrlSource,
  Video,
  connectBlocksFrom,
  registerBlocks
};
//# sourceMappingURL=@uploadcare_blocks.js.map
